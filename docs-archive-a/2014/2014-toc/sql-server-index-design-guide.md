---
title: Guía de diseño de índices de SQL Server | Microsoft Docs
ms.custom: ''
ms.date: 06/14/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: ''
ms.topic: conceptual
ms.assetid: b856ee9a-49e7-4fab-a88d-48a633fce269
author: rothja
ms.author: jroth
ms.openlocfilehash: 1f5ad72413fe71004fb1c5f125969b984db815d3
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 08/04/2020
ms.locfileid: "87663216"
---
# <a name="sql-server-index-design-guide"></a><span data-ttu-id="d7707-102">Guía de diseño de índices de SQL Server</span><span class="sxs-lookup"><span data-stu-id="d7707-102">SQL Server Index Design Guide</span></span>

  <span data-ttu-id="d7707-103">Los índices mal diseñados y la falta de índices constituyen las principales fuentes de atascos en aplicaciones de base de datos.</span><span class="sxs-lookup"><span data-stu-id="d7707-103">Poorly designed indexes and a lack of indexes are primary sources of database application bottlenecks.</span></span> <span data-ttu-id="d7707-104">El diseño eficaz de los índices tiene gran importancia para conseguir un buen rendimiento de una base de datos y una aplicación.</span><span class="sxs-lookup"><span data-stu-id="d7707-104">Designing efficient indexes is paramount to achieving good database and application performance.</span></span> <span data-ttu-id="d7707-105">Esta guía de diseño de índices de SQL Server contiene información y prácticas recomendadas que le ayudarán a diseñar índices eficaces que resuelvan las necesidades de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d7707-105">This SQL Server index design guide contains information and best practices to help you design effective indexes to meet the needs of your application.</span></span>  
  
<span data-ttu-id="d7707-106">**Se aplica a**: a [!INCLUDE[ssVersion2005](../includes/ssversion2005-md.md)] [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)] menos que se indique lo contrario.</span><span class="sxs-lookup"><span data-stu-id="d7707-106">**Applies to**: [!INCLUDE[ssVersion2005](../includes/ssversion2005-md.md)] through [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)] unless noted otherwise.</span></span>  
  
 <span data-ttu-id="d7707-107">En esta guía se da por supuesto que el lector tiene información general sobre los tipos de índice disponibles en [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span><span class="sxs-lookup"><span data-stu-id="d7707-107">This guide assumes the reader has a general understanding of the index types available in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="d7707-108">Para obtener una descripción general de los tipos de índice, vea [Tipos de índice](../relational-databases/indexes/indexes.md).</span><span class="sxs-lookup"><span data-stu-id="d7707-108">For a general description of index types, see [Index Types](../relational-databases/indexes/indexes.md).</span></span>  
  
##  <a name="in-this-guide"></a><a name="Top"></a><span data-ttu-id="d7707-109">En esta guía</span><span class="sxs-lookup"><span data-stu-id="d7707-109">In This Guide</span></span>  

 [<span data-ttu-id="d7707-110">Conceptos básicos del diseño de índices</span><span class="sxs-lookup"><span data-stu-id="d7707-110">Index Design Basics</span></span>](#Basics)  
  
 [<span data-ttu-id="d7707-111">Instrucciones generales de diseño de índices</span><span class="sxs-lookup"><span data-stu-id="d7707-111">General Index Design Guidelines</span></span>](#General_Design)  
  
 [<span data-ttu-id="d7707-112">Directrices de diseño de índices agrupados</span><span class="sxs-lookup"><span data-stu-id="d7707-112">Clustered Index Design Guidelines</span></span>](#Clustered)  
  
 [<span data-ttu-id="d7707-113">Directrices para diseñar índices no clúster</span><span class="sxs-lookup"><span data-stu-id="d7707-113">Nonclustered Index Design Guidelines</span></span>](#Nonclustered)  
  
 [<span data-ttu-id="d7707-114">Directrices para diseñar índices únicos</span><span class="sxs-lookup"><span data-stu-id="d7707-114">Unique Index Design Guidelines</span></span>](#Unique)  
  
 [<span data-ttu-id="d7707-115">Directrices para diseñar índices filtrados</span><span class="sxs-lookup"><span data-stu-id="d7707-115">Filtered Index Design Guidelines</span></span>](#Filtered)  
  
 [<span data-ttu-id="d7707-116">Lecturas adicionales</span><span class="sxs-lookup"><span data-stu-id="d7707-116">Additional Reading</span></span>](#Additional_Reading)  
  
##  <a name="index-design-basics"></a><a name="Basics"></a> <span data-ttu-id="d7707-117">Conceptos básicos del diseño de índices</span><span class="sxs-lookup"><span data-stu-id="d7707-117">Index Design Basics</span></span>  

 <span data-ttu-id="d7707-118">Un índice es una estructura de disco asociada con una tabla o una vista que acelera la recuperación de filas de la tabla o de la vista.</span><span class="sxs-lookup"><span data-stu-id="d7707-118">An index is an on-disk structure associated with a table or view that speeds retrieval of rows from the table or view.</span></span> <span data-ttu-id="d7707-119">Un índice contiene claves generadas a partir de una o varias columnas de la tabla o la vista.</span><span class="sxs-lookup"><span data-stu-id="d7707-119">An index contains keys built from one or more columns in the table or view.</span></span> <span data-ttu-id="d7707-120">Dichas claves están almacenadas en una estructura (árbol b) que permite que SQL Server busque de forma rápida y eficiente la fila o filas asociadas a los valores de cada clave.</span><span class="sxs-lookup"><span data-stu-id="d7707-120">These keys are stored in a structure (B-tree) that enables SQL Server to find the row or rows associated with the key values quickly and efficiently.</span></span>  
  
 <span data-ttu-id="d7707-121">La selección de los índices apropiados para una base de datos y su carga de trabajo es una compleja operación que busca el equilibrio entre la velocidad de la consulta y el costo de actualización.</span><span class="sxs-lookup"><span data-stu-id="d7707-121">The selection of the right indexes for a database and its workload is a complex balancing act between query speed and update cost.</span></span> <span data-ttu-id="d7707-122">Los índices estrechos, o con pocas columnas en la clave de índice, necesitan menos espacio en el disco y son menos susceptibles de provocar sobrecargas debido a su mantenimiento.</span><span class="sxs-lookup"><span data-stu-id="d7707-122">Narrow indexes, or indexes with few columns in the index key, require less disk space and maintenance overhead.</span></span> <span data-ttu-id="d7707-123">Por otra parte, la ventaja de los índices anchos es que cubren más consultas.</span><span class="sxs-lookup"><span data-stu-id="d7707-123">Wide indexes, on the other hand, cover more queries.</span></span> <span data-ttu-id="d7707-124">Puede que tenga que experimentar con distintos diseños antes de encontrar el índice más eficaz.</span><span class="sxs-lookup"><span data-stu-id="d7707-124">You may have to experiment with several different designs before finding the most efficient index.</span></span> <span data-ttu-id="d7707-125">Es posible agregar, modificar y quitar índices sin que esto afecte al esquema de la base de datos o al diseño de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d7707-125">Indexes can be added, modified, and dropped without affecting the database schema or application design.</span></span> <span data-ttu-id="d7707-126">Por lo tanto, no debe dudar en experimentar con índices diferentes.</span><span class="sxs-lookup"><span data-stu-id="d7707-126">Therefore, you should not hesitate to experiment with different indexes.</span></span>  
  
 <span data-ttu-id="d7707-127">El optimizador de consultas de [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] elige de forma confiable el índice más eficaz en la mayoría de los casos.</span><span class="sxs-lookup"><span data-stu-id="d7707-127">The query optimizer in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] reliably chooses the most effective index in the vast majority of cases.</span></span> <span data-ttu-id="d7707-128">La estrategia general de diseño de índices debe proporcionar una buena selección de índices al optimizador de consultas y confiar en que tomará la decisión correcta.</span><span class="sxs-lookup"><span data-stu-id="d7707-128">Your overall index design strategy should provide a variety of indexes for the query optimizer to choose from and trust it to make the right decision.</span></span> <span data-ttu-id="d7707-129">Así se reduce el tiempo de análisis y se obtiene un buen rendimiento en diversas situaciones.</span><span class="sxs-lookup"><span data-stu-id="d7707-129">This reduces analysis time and produces good performance over a variety of situations.</span></span> <span data-ttu-id="d7707-130">Para saber qué índices utiliza el optimizador de consultas para determinada consulta, en [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)], en el menú **Consulta** , seleccione **Incluir plan de ejecución real**.</span><span class="sxs-lookup"><span data-stu-id="d7707-130">To see which indexes the query optimizer uses for a specific query, in [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)], on the **Query** menu, select **Include Actual Execution Plan**.</span></span>  
  
 <span data-ttu-id="d7707-131">No equipare siempre la utilización de índices con un buen rendimiento ni el buen rendimiento al uso eficaz del índice.</span><span class="sxs-lookup"><span data-stu-id="d7707-131">Do not always equate index usage with good performance, and good performance with efficient index use.</span></span> <span data-ttu-id="d7707-132">Si la utilización de un índice contribuyera siempre a producir el mejor rendimiento, el trabajo del optimizador de consultas sería muy sencillo.</span><span class="sxs-lookup"><span data-stu-id="d7707-132">If using an index always helped produce the best performance, the job of the query optimizer would be simple.</span></span> <span data-ttu-id="d7707-133">En realidad, una elección incorrecta de índice puede provocar un rendimiento bajo.</span><span class="sxs-lookup"><span data-stu-id="d7707-133">In reality, an incorrect index choice can cause less than optimal performance.</span></span> <span data-ttu-id="d7707-134">Por tanto, la tarea del optimizador de consultas consiste en seleccionar un índice o una combinación de índices solo si mejora el rendimiento, y evitar la recuperación indizada cuando afecte al mismo.</span><span class="sxs-lookup"><span data-stu-id="d7707-134">Therefore, the task of the query optimizer is to select an index, or combination of indexes, only when it will improve performance, and to avoid indexed retrieval when it will hinder performance.</span></span>  
  
### <a name="index-design-tasks"></a><span data-ttu-id="d7707-135">Tareas del diseño de índices</span><span class="sxs-lookup"><span data-stu-id="d7707-135">Index Design Tasks</span></span>  

 <span data-ttu-id="d7707-136">Las siguientes tareas componen la estrategia recomendada para el diseño de índices:</span><span class="sxs-lookup"><span data-stu-id="d7707-136">The follow tasks make up our recommended strategy for designing indexes:</span></span>  
  
1.  <span data-ttu-id="d7707-137">Comprender las características de la propia base de datos.</span><span class="sxs-lookup"><span data-stu-id="d7707-137">Understand the characteristics of the database itself.</span></span> <span data-ttu-id="d7707-138">Por ejemplo, se trata de una base de datos de procesamiento de transacciones en línea (OLTP) con modificaciones frecuentes de datos, o de una base de datos de sistema de ayuda a la toma de decisiones (DSS) o de almacenamiento de datos (OLAP) que contiene principalmente datos de solo lectura y debe procesar rápidamente conjuntos de datos muy grandes.</span><span class="sxs-lookup"><span data-stu-id="d7707-138">For example, is it an online transaction processing (OLTP) database with frequent data modifications, or a Decision Support System (DSS) or data warehousing (OLAP) database that contains primarily read-only data and must process very large data sets quickly.</span></span> <span data-ttu-id="d7707-139">En [!INCLUDE[ssSQL11](../includes/sssql11-md.md)], el índice de *almacén de columnas optimizado para memoria xVelocity* resulta especialmente indicado para los conjuntos de datos típicos de almacenamiento de datos.</span><span class="sxs-lookup"><span data-stu-id="d7707-139">In [!INCLUDE[ssSQL11](../includes/sssql11-md.md)], *xVelocity memory optimized columnstore* index is especially appropriate for typical data warehousing data sets.</span></span> <span data-ttu-id="d7707-140">Los índices de almacén de columnas pueden transformar la experiencia de almacenamiento de datos de los usuarios, ya que permite un rendimiento más rápido en las consultas habituales de almacenamiento de datos, como el filtrado, la agregación, la agrupación y la combinación en estrella de consultas.</span><span class="sxs-lookup"><span data-stu-id="d7707-140">Columnstore indexes can transform the data warehousing experience for users by enabling faster performance for common data warehousing queries such as filtering, aggregating, grouping, and star-join queries.</span></span> <span data-ttu-id="d7707-141">Para obtener más información, consulte los [índices de almacén de columnas descritos](../relational-databases/indexes/columnstore-indexes-described.md).</span><span class="sxs-lookup"><span data-stu-id="d7707-141">For more information, see [Columnstore Indexes Described](../relational-databases/indexes/columnstore-indexes-described.md).</span></span>  
  
2.  <span data-ttu-id="d7707-142">Comprender las características de las consultas utilizadas con frecuencia.</span><span class="sxs-lookup"><span data-stu-id="d7707-142">Understand the characteristics of the most frequently used queries.</span></span> <span data-ttu-id="d7707-143">Por ejemplo, saber que una consulta utilizada con frecuencia une dos o más tablas facilitará la determinación del mejor tipo de índices que se puede utilizar.</span><span class="sxs-lookup"><span data-stu-id="d7707-143">For example, knowing that a frequently used query joins two or more tables will help you determine the best type of indexes to use.</span></span>  
  
3.  <span data-ttu-id="d7707-144">Comprender las características de las columnas utilizadas en las consultas.</span><span class="sxs-lookup"><span data-stu-id="d7707-144">Understand the characteristics of the columns used in the queries.</span></span> <span data-ttu-id="d7707-145">Por ejemplo, un índice es idóneo para columnas que tienen un tipo de datos entero y además son columnas con valores NULL o no NULL.</span><span class="sxs-lookup"><span data-stu-id="d7707-145">For example, an index is ideal for columns that have an integer data type and are also unique or nonnull columns.</span></span> <span data-ttu-id="d7707-146">En el caso de columnas que tengan subconjuntos de datos bien definidos, puede usar un índice filtrado en [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] y en versiones posteriores.</span><span class="sxs-lookup"><span data-stu-id="d7707-146">For columns that have well-defined subsets of data, you can use a filtered index in [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] and higher versions.</span></span> <span data-ttu-id="d7707-147">Para obtener más información, vea [Directrices generales para diseñar índices filtrados](#Filtered) en esta guía.</span><span class="sxs-lookup"><span data-stu-id="d7707-147">For more information, see [Filtered Index Design Guidelines](#Filtered) in this guide.</span></span>  
  
4.  <span data-ttu-id="d7707-148">Determinar qué opciones de índice podrían mejorar el rendimiento al crear o mantener el índice.</span><span class="sxs-lookup"><span data-stu-id="d7707-148">Determine which index options might enhance performance when the index is created or maintained.</span></span> <span data-ttu-id="d7707-149">Por ejemplo, la creación de un índice clúster en una tabla grande existente se beneficiaría de la opción de índice ONLINE.</span><span class="sxs-lookup"><span data-stu-id="d7707-149">For example, creating a clustered index on an existing large table would benefit from the ONLINE index option.</span></span> <span data-ttu-id="d7707-150">La opción ONLINE permite que la actividad simultánea en los datos subyacentes continúe mientras el índice se crea o regenera.</span><span class="sxs-lookup"><span data-stu-id="d7707-150">The ONLINE option allows for concurrent activity on the underlying data to continue while the index is being created or rebuilt.</span></span> <span data-ttu-id="d7707-151">Para obtener más información, consulte [Establecer opciones de índice](../relational-databases/indexes/set-index-options.md).</span><span class="sxs-lookup"><span data-stu-id="d7707-151">For more information, see [Set Index Options](../relational-databases/indexes/set-index-options.md).</span></span>  
  
5.  <span data-ttu-id="d7707-152">Determinar la ubicación de almacenamiento óptima para el índice.</span><span class="sxs-lookup"><span data-stu-id="d7707-152">Determine the optimal storage location for the index.</span></span> <span data-ttu-id="d7707-153">Un índice no clúster se puede almacenar en el mismo grupo de archivos que la tabla subyacente o en un grupo distinto.</span><span class="sxs-lookup"><span data-stu-id="d7707-153">A nonclustered index can be stored in the same filegroup as the underlying table, or on a different filegroup.</span></span> <span data-ttu-id="d7707-154">La ubicación de almacenamiento de índices puede mejorar el rendimiento de las consultas aumentando el rendimiento de las operaciones de E/S en disco.</span><span class="sxs-lookup"><span data-stu-id="d7707-154">The storage location of indexes can improve query performance by increasing disk I/O performance.</span></span> <span data-ttu-id="d7707-155">Por ejemplo, el almacenamiento de un índice no clúster en un grupo de archivos que se encuentra en un disco distinto que el del grupo de archivos de la tabla puede mejorar el rendimiento, ya que se pueden leer varios discos al mismo tiempo.</span><span class="sxs-lookup"><span data-stu-id="d7707-155">For example, storing a nonclustered index on a filegroup that is on a different disk than the table filegroup can improve performance because multiple disks can be read at the same time.</span></span>  
  
     <span data-ttu-id="d7707-156">O bien, los índices clúster y no clúster pueden utilizar un esquema de particiones en varios grupos de archivos.</span><span class="sxs-lookup"><span data-stu-id="d7707-156">Alternatively, clustered and nonclustered indexes can use a partition scheme across multiple filegroups.</span></span> <span data-ttu-id="d7707-157">Las particiones facilitan la administración de índices y tablas grandes al permitir el acceso y la administración de subconjuntos de datos rápidamente y con eficacia, mientras se mantiene la integridad de la colección global.</span><span class="sxs-lookup"><span data-stu-id="d7707-157">Partitioning makes large tables or indexes more manageable by letting you access or manage subsets of data quickly and efficiently, while maintaining the integrity of the overall collection.</span></span> <span data-ttu-id="d7707-158">Para obtener más información, vea [Partitioned Tables and Indexes](../relational-databases/partitions/partitioned-tables-and-indexes.md).</span><span class="sxs-lookup"><span data-stu-id="d7707-158">For more information, see [Partitioned Tables and Indexes](../relational-databases/partitions/partitioned-tables-and-indexes.md).</span></span> <span data-ttu-id="d7707-159">Al considerar la posibilidad de utilizar particiones, determine si el índice debe alinearse; es decir, si las particiones se crean esencialmente del mismo modo que la tabla o de forma independiente.</span><span class="sxs-lookup"><span data-stu-id="d7707-159">When you consider partitioning, determine whether the index should be aligned, that is, partitioned in essentially the same manner as the table, or partitioned independently.</span></span>  
  
##  <a name="general-index-design-guidelines"></a><a name="General_Design"></a> <span data-ttu-id="d7707-160">Directrices generales para diseñar índices</span><span class="sxs-lookup"><span data-stu-id="d7707-160">General Index Design Guidelines</span></span>  

 <span data-ttu-id="d7707-161">Los administradores de bases de datos más experimentados pueden diseñar un buen conjunto de índices, pero esta tarea es muy compleja, consume mucho tiempo y está sujeta a errores, incluso con cargas de trabajo y bases de datos con un grado de complejidad no excesivo.</span><span class="sxs-lookup"><span data-stu-id="d7707-161">Experienced database administrators can design a good set of indexes, but this task is very complex, time-consuming, and error-prone even for moderately complex databases and workloads.</span></span> <span data-ttu-id="d7707-162">La comprensión de las características de la base de datos, las consultas y las columnas de datos facilita el diseño de los índices.</span><span class="sxs-lookup"><span data-stu-id="d7707-162">Understanding the characteristics of your database, queries, and data columns can help you design optimal indexes.</span></span>  
  
### <a name="database-considerations"></a><span data-ttu-id="d7707-163">Consideraciones acerca de la base de datos</span><span class="sxs-lookup"><span data-stu-id="d7707-163">Database Considerations</span></span>  

 <span data-ttu-id="d7707-164">Cuando diseñe un índice, tenga en cuenta las siguientes directrices acerca de la base de datos:</span><span class="sxs-lookup"><span data-stu-id="d7707-164">When you design an index, consider the following database guidelines:</span></span>  
  
-   <span data-ttu-id="d7707-165">Si se usa un gran número de índices en una tabla, el rendimiento de las instrucciones INSERT, UPDATE, DELETE y MERGE se verá afectado, ya que todos los índices deben ajustarse adecuadamente a medida que cambian los datos de la tabla.</span><span class="sxs-lookup"><span data-stu-id="d7707-165">Large numbers of indexes on a table affect the performance of INSERT, UPDATE, DELETE, and MERGE statements because all indexes must be adjusted appropriately as data in the table changes.</span></span> <span data-ttu-id="d7707-166">Por ejemplo, si una columna se usa en varios índices y ejecuta una instrucción UPDATE que modifica datos de esa columna, se deben actualizar todos los índices que contengan esa columna, así como la columna de la tabla base subyacente (índice de montón o clúster).</span><span class="sxs-lookup"><span data-stu-id="d7707-166">For example, if a column is used in several indexes and you execute an UPDATE statement that modifies that column's data, each index that contains that column must be updated as well as the column in the underlying base table (heap or clustered index).</span></span>  
  
    -   <span data-ttu-id="d7707-167">Evite crear demasiados índices en tablas que se actualizan con mucha frecuencia y mantenga los índices estrechos, es decir, defínalos con el menor número de columnas posible.</span><span class="sxs-lookup"><span data-stu-id="d7707-167">Avoid over-indexing heavily updated tables and keep indexes narrow, that is, with as few columns as possible.</span></span>  
  
    -   <span data-ttu-id="d7707-168">Utilice un número mayor de índices para mejorar el rendimiento de consultas en tablas con pocas necesidades de actualización, pero con grandes volúmenes de datos.</span><span class="sxs-lookup"><span data-stu-id="d7707-168">Use many indexes to improve query performance on tables with low update requirements, but large volumes of data.</span></span> <span data-ttu-id="d7707-169">Un gran número de índices contribuye a mejorar el rendimiento de las consultas que no modifican datos, como las instrucciones SELECT, ya que el optimizador de consultas dispone de más índices entre los que elegir para determinar el método de acceso más rápido.</span><span class="sxs-lookup"><span data-stu-id="d7707-169">Large numbers of indexes can help the performance of queries that do not modify data, such as SELECT statements, because the query optimizer has more indexes to choose from to determine the fastest access method.</span></span>  
  
-   <span data-ttu-id="d7707-170">La indización de tablas pequeñas puede no ser una solución óptima, porque puede provocar que el optimizador de consultas tarde más tiempo en realizar la búsqueda de los datos a través del índice que en realizar un simple recorrido de la tabla.</span><span class="sxs-lookup"><span data-stu-id="d7707-170">Indexing small tables may not be optimal because it can take the query optimizer longer to traverse the index searching for data than to perform a simple table scan.</span></span> <span data-ttu-id="d7707-171">De este modo, es posible que los índices de tablas pequeñas no se utilicen nunca; sin embargo, sigue siendo necesario su mantenimiento a medida que cambian los datos de la tabla.</span><span class="sxs-lookup"><span data-stu-id="d7707-171">Therefore, indexes on small tables might never be used, but must still be maintained as data in the table changes.</span></span>  
  
-   <span data-ttu-id="d7707-172">Los índices en vistas pueden mejorar de forma significativa el rendimiento si la vista contiene agregaciones, combinaciones de tabla o una mezcla de agregaciones y combinaciones.</span><span class="sxs-lookup"><span data-stu-id="d7707-172">Indexes on views can provide significant performance gains when the view contains aggregations, table joins, or a combination of aggregations and joins.</span></span> <span data-ttu-id="d7707-173">No es necesario hacer referencia de forma explícita a la vista en la consulta para que el optimizador de consultas la utilice.</span><span class="sxs-lookup"><span data-stu-id="d7707-173">The view does not have to be explicitly referenced in the query for the query optimizer to use it.</span></span>  
  
-   <span data-ttu-id="d7707-174">Utilice el Asistente para la optimización de motor de base de datos para analizar las bases de datos y crear recomendaciones de índices.</span><span class="sxs-lookup"><span data-stu-id="d7707-174">Use the Database Engine Tuning Advisor to analyze your database and make index recommendations.</span></span> <span data-ttu-id="d7707-175">Para obtener más información, vea [Database Engine Tuning Advisor](../relational-databases/performance/database-engine-tuning-advisor.md).</span><span class="sxs-lookup"><span data-stu-id="d7707-175">For more information, see [Database Engine Tuning Advisor](../relational-databases/performance/database-engine-tuning-advisor.md).</span></span>  
  
### <a name="query-considerations"></a><span data-ttu-id="d7707-176">Consideraciones sobre consultas</span><span class="sxs-lookup"><span data-stu-id="d7707-176">Query Considerations</span></span>  

 <span data-ttu-id="d7707-177">Cuando diseñe un índice, tenga en cuenta las siguientes directrices acerca de las consultas:</span><span class="sxs-lookup"><span data-stu-id="d7707-177">When you design an index, consider the following query guidelines:</span></span>  
  
-   <span data-ttu-id="d7707-178">Cree índices no clúster en las columnas que se usan con frecuencia en predicados y condiciones de combinación de las consultas.</span><span class="sxs-lookup"><span data-stu-id="d7707-178">Create nonclustered indexes on the columns that are frequently used in predicates and join conditions in queries.</span></span> <span data-ttu-id="d7707-179">Sin embargo, debe evitar agregar columnas innecesarias.</span><span class="sxs-lookup"><span data-stu-id="d7707-179">However, you should avoid adding unnecessary columns.</span></span> <span data-ttu-id="d7707-180">Si agrega demasiadas columnas de índice, puede reducir el espacio en disco y el rendimiento del mantenimiento del índice.</span><span class="sxs-lookup"><span data-stu-id="d7707-180">Adding too many index columns can adversely affect disk space and index maintenance performance.</span></span>  
  
-   <span data-ttu-id="d7707-181">La utilización de índices puede mejorar el rendimiento de las consultas, ya que los datos necesarios para satisfacer las necesidades de la consulta existen en el propio índice.</span><span class="sxs-lookup"><span data-stu-id="d7707-181">Covering indexes can improve query performance because all the data needed to meet the requirements of the query exists within the index itself.</span></span> <span data-ttu-id="d7707-182">Es decir, solo se requieren las páginas de índice, y no las páginas de datos de la tabla o el índice clúster, para recuperar los datos solicitados; por lo tanto, se reduce la E/S de disco global.</span><span class="sxs-lookup"><span data-stu-id="d7707-182">That is, only the index pages, and not the data pages of the table or clustered index, are required to retrieve the requested data; therefore, reducing overall disk I/O.</span></span> <span data-ttu-id="d7707-183">Por ejemplo, una consulta de las columnas **a** y **b** en una tabla que tiene un índice compuesto creado en las columnas **a**, **b**y **c** puede recuperar los datos especificados del índice.</span><span class="sxs-lookup"><span data-stu-id="d7707-183">For example, a query of columns **a** and **b** on a table that has a composite index created on columns **a**, **b**, and **c** can retrieve the specified data from the index alone.</span></span>  
  
-   <span data-ttu-id="d7707-184">Escriba consultas que inserten o modifiquen tantas filas como sea posible en una sola instrucción, en lugar de utilizar varias consultas para actualizar las mismas filas.</span><span class="sxs-lookup"><span data-stu-id="d7707-184">Write queries that insert or modify as many rows as possible in a single statement, instead of using multiple queries to update the same rows.</span></span> <span data-ttu-id="d7707-185">Al utilizar solo una instrucción, se puede aprovechar el mantenimiento de índices optimizados.</span><span class="sxs-lookup"><span data-stu-id="d7707-185">By using only one statement, optimized index maintenance could be exploited.</span></span>  
  
-   <span data-ttu-id="d7707-186">Analice el tipo de la consulta y cómo se utilizan las columnas en ella.</span><span class="sxs-lookup"><span data-stu-id="d7707-186">Evaluate the query type and how columns are used in the query.</span></span> <span data-ttu-id="d7707-187">Por ejemplo, una columna utilizada en una consulta de coincidencia exacta sería una buena candidata para un índice no clúster o clúster.</span><span class="sxs-lookup"><span data-stu-id="d7707-187">For example, a column used in an exact-match query type would be a good candidate for a nonclustered or clustered index.</span></span>  
  
### <a name="column-considerations"></a><span data-ttu-id="d7707-188">Consideraciones sobre columnas</span><span class="sxs-lookup"><span data-stu-id="d7707-188">Column Considerations</span></span>  

 <span data-ttu-id="d7707-189">Cuando diseñe un índice, tenga en cuenta las siguientes directrices acerca de las columnas:</span><span class="sxs-lookup"><span data-stu-id="d7707-189">When you design an index consider the following column guidelines:</span></span>  
  
-   <span data-ttu-id="d7707-190">Utilice una longitud corta en la clave de los índices clúster.</span><span class="sxs-lookup"><span data-stu-id="d7707-190">Keep the length of the index key short for clustered indexes.</span></span> <span data-ttu-id="d7707-191">Los índices clúster también mejoran si se crean en columnas únicas o que no admitan valores NULL.</span><span class="sxs-lookup"><span data-stu-id="d7707-191">Additionally, clustered indexes benefit from being created on unique or nonnull columns.</span></span>  
  
-   <span data-ttu-id="d7707-192">Las columnas con tipos de datos `ntext`, `text`, `image`, `varchar(max)`, `nvarchar(max)` y `varbinary(max)` no se pueden especificar como columnas de clave de índice.</span><span class="sxs-lookup"><span data-stu-id="d7707-192">Columns that are of the `ntext`, `text`, `image`, `varchar(max)`, `nvarchar(max)`, and `varbinary(max)` data types cannot be specified as index key columns.</span></span> <span data-ttu-id="d7707-193">Sin embargo, los tipos de datos `varchar(max)`, `nvarchar(max)`, `varbinary(max)` y `xml` pueden participar en un índice no clúster como columnas de índice sin clave.</span><span class="sxs-lookup"><span data-stu-id="d7707-193">However, `varchar(max)`, `nvarchar(max)`, `varbinary(max)`, and `xml` data types can participate in a nonclustered index as nonkey index columns.</span></span> <span data-ttu-id="d7707-194">Para obtener más información, vea la sección ['Índice con columnas incluidas](#Included_Columns)' en esta guía.</span><span class="sxs-lookup"><span data-stu-id="d7707-194">For more information, see the section ['Index with Included Columns](#Included_Columns)' in this guide.</span></span>  
  
-   <span data-ttu-id="d7707-195">El tipo de datos `xml` solo puede ser una columna de clave en un índice XML.</span><span class="sxs-lookup"><span data-stu-id="d7707-195">An `xml` data type can only be a key column only in an XML index.</span></span> <span data-ttu-id="d7707-196">Para obtener más información, consulte [Índices XML &#40;SQL Server&#41;](../relational-databases/xml/xml-indexes-sql-server.md).</span><span class="sxs-lookup"><span data-stu-id="d7707-196">For more information, see [XML Indexes &#40;SQL Server&#41;](../relational-databases/xml/xml-indexes-sql-server.md).</span></span> <span data-ttu-id="d7707-197">SQL Server 2012 SP1 presenta un nuevo tipo de índice XML denominado índice XML selectivo.</span><span class="sxs-lookup"><span data-stu-id="d7707-197">SQL Server 2012 SP1 introduces a new type of XML index known as a Selective XML Index.</span></span> <span data-ttu-id="d7707-198">Este nuevo índice puede mejorar el rendimiento de las consultas en datos almacenados como XML en SQL Server, lo que permitirá indizar mucho más rápidamente grandes cargas de trabajo de datos XML y mejorar la escalabilidad reduciendo los costos de almacenamiento del propio índice.</span><span class="sxs-lookup"><span data-stu-id="d7707-198">This new index can improve querying performance over data stored as XML in SQL Server, allow for much faster indexing of large XML data workloads, and improve scalability by reducing storage costs of the index itself.</span></span> <span data-ttu-id="d7707-199">Para obtener más información, consulte [Índices XML selectivos &#40;SXI&#41;](../relational-databases/xml/selective-xml-indexes-sxi.md).</span><span class="sxs-lookup"><span data-stu-id="d7707-199">For more information, see [Selective XML Indexes &#40;SXI&#41;](../relational-databases/xml/selective-xml-indexes-sxi.md).</span></span>  
  
-   <span data-ttu-id="d7707-200">Examine la unicidad de las columnas.</span><span class="sxs-lookup"><span data-stu-id="d7707-200">Examine column uniqueness.</span></span> <span data-ttu-id="d7707-201">Un índice único en lugar de un índice no único con la misma combinación de columnas proporciona información adicional al optimizador de consultas y, por tanto, resulta más útil.</span><span class="sxs-lookup"><span data-stu-id="d7707-201">A unique index instead of a nonunique index on the same combination of columns provides additional information for the query optimizer that makes the index more useful.</span></span> <span data-ttu-id="d7707-202">Para obtener más información, vea [Directrices para diseñar índices únicos](#Unique) en esta guía.</span><span class="sxs-lookup"><span data-stu-id="d7707-202">For more information, see [Unique Index Design Guidelines](#Unique) in this guide.</span></span>  
  
-   <span data-ttu-id="d7707-203">Examine la distribución de los datos en la columna.</span><span class="sxs-lookup"><span data-stu-id="d7707-203">Examine data distribution in the column.</span></span> <span data-ttu-id="d7707-204">A menudo, se crean consultas cuya ejecución es muy larga al indizar una columna con pocos valores únicos, o bien al realizar una combinación en dicha columna.</span><span class="sxs-lookup"><span data-stu-id="d7707-204">Frequently, a long-running query is caused by indexing a column with few unique values, or by performing a join on such a column.</span></span> <span data-ttu-id="d7707-205">Se trata de un problema fundamental con los datos y la consulta, y normalmente no se puede resolver sin identificar esta situación.</span><span class="sxs-lookup"><span data-stu-id="d7707-205">This is a fundamental problem with the data and query, and generally cannot be resolved without identifying this situation.</span></span> <span data-ttu-id="d7707-206">Por ejemplo, una agenda telefónica ordenada por apellidos no localizará rápidamente a una persona si todas las personas de la ciudad se llaman Smith o Jones.</span><span class="sxs-lookup"><span data-stu-id="d7707-206">For example, a physical telephone directory sorted alphabetically on last name will not expedite locating a person if all people in the city are named Smith or Jones.</span></span> <span data-ttu-id="d7707-207">Para obtener más información acerca de la distribución de datos, vea [Statistics](../relational-databases/statistics/statistics.md).</span><span class="sxs-lookup"><span data-stu-id="d7707-207">For more information about data distribution, see [Statistics](../relational-databases/statistics/statistics.md).</span></span>  
  
-   <span data-ttu-id="d7707-208">Considere la posibilidad de usar índices filtrados en columnas que tengan subconjuntos bien definidos, por ejemplo columnas dispersas, columnas con una mayoría de valores NULL, columnas con categorías de valores y columnas con intervalos de valores diferenciados.</span><span class="sxs-lookup"><span data-stu-id="d7707-208">Consider using filtered indexes on columns that have well-defined subsets, for example sparse columns, columns with mostly NULL values, columns with categories of values, and columns with distinct ranges of values.</span></span> <span data-ttu-id="d7707-209">Un índice filtrado bien diseñado puede mejorar el rendimiento de las consultas, así como reducir los costos de almacenamiento y de mantenimiento de los índices.</span><span class="sxs-lookup"><span data-stu-id="d7707-209">A well-designed filtered index can improve query performance, reduce index maintenance costs, and reduce storage costs.</span></span>  
  
-   <span data-ttu-id="d7707-210">Tenga en cuenta el orden de las columnas si el índice va a contener varias columnas.</span><span class="sxs-lookup"><span data-stu-id="d7707-210">Consider the order of the columns if the index will contain multiple columns.</span></span> <span data-ttu-id="d7707-211">La columna que se usa en la cláusula WHERE en una condición de búsqueda igual a (=), mayor que (>), menor que (<) o BETWEEN, o que participa en una combinación, debe situarse en primer lugar.</span><span class="sxs-lookup"><span data-stu-id="d7707-211">The column that is used in the WHERE clause in an equal to (=), greater than (>), less than (<), or BETWEEN search condition, or participates in a join, should be placed first.</span></span> <span data-ttu-id="d7707-212">Las demás columnas deben ordenarse basándose en su nivel de diferenciación, es decir, de más distintas a menos distintas.</span><span class="sxs-lookup"><span data-stu-id="d7707-212">Additional columns should be ordered based on their level of distinctness, that is, from the most distinct to the least distinct.</span></span>  
  
     <span data-ttu-id="d7707-213">Por ejemplo, si el índice se define como `LastName`, `FirstName` , resultará útil si el criterio de búsqueda es `WHERE LastName = 'Smith'` o `WHERE LastName = Smith AND FirstName LIKE 'J%'`.</span><span class="sxs-lookup"><span data-stu-id="d7707-213">For example, if the index is defined as `LastName`, `FirstName` the index will be useful when the search criterion is `WHERE LastName = 'Smith'` or `WHERE LastName = Smith AND FirstName LIKE 'J%'`.</span></span> <span data-ttu-id="d7707-214">Sin embargo, el optimizador de consultas no utilizará el índice en una consulta que solo busque `FirstName (WHERE FirstName = 'Jane')`.</span><span class="sxs-lookup"><span data-stu-id="d7707-214">However, the query optimizer would not use the index for a query that searched only on `FirstName (WHERE FirstName = 'Jane')`.</span></span>  
  
-   <span data-ttu-id="d7707-215">Tenga en cuenta la indización de columnas calculadas.</span><span class="sxs-lookup"><span data-stu-id="d7707-215">Consider indexing computed columns.</span></span> <span data-ttu-id="d7707-216">Para obtener más información, vea [Indexes on Computed Columns](../relational-databases/indexes/indexes-on-computed-columns.md).</span><span class="sxs-lookup"><span data-stu-id="d7707-216">For more information, see [Indexes on Computed Columns](../relational-databases/indexes/indexes-on-computed-columns.md).</span></span>  
  
### <a name="index-characteristics"></a><span data-ttu-id="d7707-217">Características de los índices</span><span class="sxs-lookup"><span data-stu-id="d7707-217">Index Characteristics</span></span>  

 <span data-ttu-id="d7707-218">Después de determinar que un índice resulta adecuado para una consulta, puede seleccionar el tipo de índice que mejor se ajusta a la situación.</span><span class="sxs-lookup"><span data-stu-id="d7707-218">After you have determined that an index is appropriate for a query, you can select the type of index that best fits your situation.</span></span> <span data-ttu-id="d7707-219">Entre las características de los índices se incluyen:</span><span class="sxs-lookup"><span data-stu-id="d7707-219">Index characteristics include the following:</span></span>  
  
-   <span data-ttu-id="d7707-220">Índices agrupados y no agrupados</span><span class="sxs-lookup"><span data-stu-id="d7707-220">Clustered versus nonclustered</span></span>  
  
-   <span data-ttu-id="d7707-221">Índices exclusivos y no exclusivos</span><span class="sxs-lookup"><span data-stu-id="d7707-221">Unique versus nonunique</span></span>  
  
-   <span data-ttu-id="d7707-222">Índices de una sola columna y de varias columnas</span><span class="sxs-lookup"><span data-stu-id="d7707-222">Single column versus multicolumn</span></span>  
  
-   <span data-ttu-id="d7707-223">Orden ascendente o descendente en las columnas del índice</span><span class="sxs-lookup"><span data-stu-id="d7707-223">Ascending or descending order on the columns in the index</span></span>  
  
-   <span data-ttu-id="d7707-224">Índices de tabla completa y filtrados en índices no clúster</span><span class="sxs-lookup"><span data-stu-id="d7707-224">Full-table versus filtered for nonclustered indexes</span></span>  
  
 <span data-ttu-id="d7707-225">También puede personalizar las características iniciales de almacenamiento del índice para optimizar su rendimiento o mantenimiento; por ejemplo, puede establecer una opción como FILLFACTOR.</span><span class="sxs-lookup"><span data-stu-id="d7707-225">You can also customize the initial storage characteristics of the index to optimize its performance or maintenance by setting an option such as FILLFACTOR.</span></span> <span data-ttu-id="d7707-226">Además, puede determinar la ubicación de almacenamiento del índice si utiliza grupos de archivos o esquemas de partición y mejorar así el rendimiento.</span><span class="sxs-lookup"><span data-stu-id="d7707-226">Also, you can determine the index storage location by using filegroups or partition schemes to optimize performance.</span></span>  
  
###  <a name="index-placement-on-filegroups-or-partitions-schemes"></a><a name="Index_placement"></a> <span data-ttu-id="d7707-227">Colocación de índices en grupos de archivos o esquemas de particiones</span><span class="sxs-lookup"><span data-stu-id="d7707-227">Index Placement on Filegroups or Partitions Schemes</span></span>  

 <span data-ttu-id="d7707-228">Al desarrollar la estrategia de diseño del índice, debe tener en cuenta la ubicación de los índices en los grupos de archivos asociados con la base de datos.</span><span class="sxs-lookup"><span data-stu-id="d7707-228">As you develop your index design strategy, you should consider the placement of the indexes on the filegroups associated with the database.</span></span> <span data-ttu-id="d7707-229">La selección cuidadosa del grupo de archivos o del esquema de partición puede mejorar el rendimiento de la consulta.</span><span class="sxs-lookup"><span data-stu-id="d7707-229">Careful selection of the filegroup or partition scheme can improve query performance.</span></span>  
  
 <span data-ttu-id="d7707-230">De forma predeterminada, los índices se almacenan en el mismo grupo de archivos que la tabla base en la que se crea el índice.</span><span class="sxs-lookup"><span data-stu-id="d7707-230">By default, indexes are stored in the same filegroup as the base table on which the index is created.</span></span> <span data-ttu-id="d7707-231">Un índice clúster sin particiones y la tabla base siempre residen en el mismo grupo de archivos.</span><span class="sxs-lookup"><span data-stu-id="d7707-231">A nonpartitioned clustered index and the base table always reside in the same filegroup.</span></span> <span data-ttu-id="d7707-232">Sin embargo, puede hacer lo siguiente:</span><span class="sxs-lookup"><span data-stu-id="d7707-232">However, you can do the following:</span></span>  
  
-   <span data-ttu-id="d7707-233">Crear índices no clúster en un grupo de archivos diferente del grupo de archivos de la tabla base o el índice clúster.</span><span class="sxs-lookup"><span data-stu-id="d7707-233">Create nonclustered indexes on a filegroup other than the filegroup of the base table or clustered index.</span></span>  
  
-   <span data-ttu-id="d7707-234">Crear particiones de índices clúster y no clúster repartidos en varios grupos de archivos.</span><span class="sxs-lookup"><span data-stu-id="d7707-234">Partition clustered and nonclustered indexes to span multiple filegroups.</span></span>  
  
-   <span data-ttu-id="d7707-235">Mover una tabla de un grupo de archivos a otro quitando el índice clúster y especificando un nuevo grupo de archivos o un esquema de partición en la cláusula MOVE TO de la instrucción DROP INDEX o utilizando la instrucción CREATE INDEX con la cláusula DROP_EXISTING.</span><span class="sxs-lookup"><span data-stu-id="d7707-235">Move a table from one filegroup to another by dropping the clustered index and specifying a new filegroup or partition scheme in the MOVE TO clause of the DROP INDEX statement or by using the CREATE INDEX statement with the DROP_EXISTING clause.</span></span>  
  
 <span data-ttu-id="d7707-236">Si se crea el índice no clúster en otro grupo de archivos, es posible mejorar el rendimiento si los grupos de archivos utilizan distintas unidades físicas con sus propios controladores.</span><span class="sxs-lookup"><span data-stu-id="d7707-236">By creating the nonclustered index on a different filegroup, you can achieve performance gains if the filegroups are using different physical drives with their own controllers.</span></span> <span data-ttu-id="d7707-237">De ese modo, la información de índice y los datos pueden leerse en paralelo mediante varios cabezales de disco.</span><span class="sxs-lookup"><span data-stu-id="d7707-237">Data and index information can then be read in parallel by the multiple disk heads.</span></span> <span data-ttu-id="d7707-238">Por ejemplo, si la misma consulta emplea `Table_A` del grupo de archivos `f1` e `Index_A` del grupo de archivos `f2` , se puede mejorar el rendimiento porque ambos grupos de archivos se están usando sin contención.</span><span class="sxs-lookup"><span data-stu-id="d7707-238">For example, if `Table_A` on filegroup `f1` and `Index_A` on filegroup `f2` are both being used by the same query, performance gains can be achieved because both filegroups are being fully used without contention.</span></span> <span data-ttu-id="d7707-239">Sin embargo, si la consulta examina `Table_A` pero no se hace referencia a `Index_A` , solo se usará el grupo de archivos `f1` .</span><span class="sxs-lookup"><span data-stu-id="d7707-239">However, if `Table_A` is scanned by the query but `Index_A` is not referenced, only filegroup `f1` is used.</span></span> <span data-ttu-id="d7707-240">Esto no produce ninguna mejora de rendimiento.</span><span class="sxs-lookup"><span data-stu-id="d7707-240">This creates no performance gain.</span></span>  
  
 <span data-ttu-id="d7707-241">Como no se puede predecir qué tipo de acceso tendrá lugar ni cuándo, la mejor decisión consiste en repartir las tablas e índices en todos los grupos de archivos.</span><span class="sxs-lookup"><span data-stu-id="d7707-241">Because you cannot predict what type of access will occur and when it will occur, it could be a better decision to spread your tables and indexes across all filegroups.</span></span> <span data-ttu-id="d7707-242">De este modo se garantiza el acceso a todos los discos, ya que todos los datos e índices están repartidos por igual entre todos los discos independientemente de la forma de acceso a los datos.</span><span class="sxs-lookup"><span data-stu-id="d7707-242">This would guarantee that all disks are being accessed because all data and indexes are spread evenly across all disks, regardless of which way the data is accessed.</span></span> <span data-ttu-id="d7707-243">También se trata de un método más sencillo para los administradores de sistemas.</span><span class="sxs-lookup"><span data-stu-id="d7707-243">This is also a simpler approach for system administrators.</span></span>  
  
#### <a name="partitions-across-multiple-filegroups"></a><span data-ttu-id="d7707-244">Particiones entre varios grupos de archivos</span><span class="sxs-lookup"><span data-stu-id="d7707-244">Partitions Across Multiple Filegroups</span></span>  

 <span data-ttu-id="d7707-245">También puede considerar la opción de crear particiones de clúster y no clúster en varios grupos de archivos.</span><span class="sxs-lookup"><span data-stu-id="d7707-245">You can also consider partitioning clustered and nonclustered indexes across multiple filegroups.</span></span> <span data-ttu-id="d7707-246">Los índices con particiones se dividen horizontalmente o por filas, basándose en una función de partición.</span><span class="sxs-lookup"><span data-stu-id="d7707-246">Partitioned indexes are partitioned horizontally, or by row, based on a partition function.</span></span> <span data-ttu-id="d7707-247">La función de partición define cómo se asigna cada fila a un conjunto de particiones en los valores de ciertas columnas, denominadas columnas de partición.</span><span class="sxs-lookup"><span data-stu-id="d7707-247">The partition function defines how each row is mapped to a set of partitions based on the values of certain columns, called partitioning columns.</span></span> <span data-ttu-id="d7707-248">Un esquema de partición especifica la asignación de las particiones a un conjunto de grupos de archivos.</span><span class="sxs-lookup"><span data-stu-id="d7707-248">A partition scheme specifies the mapping of the partitions to a set of filegroups.</span></span>  
  
 <span data-ttu-id="d7707-249">La creación de particiones de un índice puede proporcionar las siguientes ventajas:</span><span class="sxs-lookup"><span data-stu-id="d7707-249">Partitioning an index can provide the following benefits:</span></span>  
  
-   <span data-ttu-id="d7707-250">Proporcionar sistemas escalables que hacen que los índices grandes sean más fáciles de administrar.</span><span class="sxs-lookup"><span data-stu-id="d7707-250">Provide scalable systems that make large indexes more manageable.</span></span> <span data-ttu-id="d7707-251">Los sistemas OLTP, por ejemplo, pueden implementar aplicaciones orientadas a particiones que gestionan índices grandes.</span><span class="sxs-lookup"><span data-stu-id="d7707-251">OLTP systems, for example, can implement partition-aware applications that deal with large indexes.</span></span>  
  
-   <span data-ttu-id="d7707-252">Realizar consultas de forma más rápida y eficiente.</span><span class="sxs-lookup"><span data-stu-id="d7707-252">Make queries run faster and more efficiently.</span></span> <span data-ttu-id="d7707-253">Cuando las consultas tienen acceso a varias particiones de un índice, el optimizador de consultas puede procesar particiones individuales simultáneamente y excluir particiones que no están afectadas por la consulta.</span><span class="sxs-lookup"><span data-stu-id="d7707-253">When queries access several partitions of an index, the query optimizer can process individual partitions at the same time and exclude partitions that are not affected by the query.</span></span>  
  
 <span data-ttu-id="d7707-254">Para obtener más información, vea [Partitioned Tables and Indexes](../relational-databases/partitions/partitioned-tables-and-indexes.md).</span><span class="sxs-lookup"><span data-stu-id="d7707-254">For more information, see [Partitioned Tables and Indexes](../relational-databases/partitions/partitioned-tables-and-indexes.md).</span></span>  
  
###  <a name="index-sort-order-design-guidelines"></a><a name="Sort_Order"></a> <span data-ttu-id="d7707-255">Directrices para diseñar el criterio de ordenación de los índices</span><span class="sxs-lookup"><span data-stu-id="d7707-255">Index Sort Order Design Guidelines</span></span>  

 <span data-ttu-id="d7707-256">Al definir índices, debe tenerse en cuenta si los datos de la columna de clave de índice se almacenan en orden ascendente o descendente.</span><span class="sxs-lookup"><span data-stu-id="d7707-256">When defining indexes, you should consider whether the data for the index key column should be stored in ascending or descending order.</span></span> <span data-ttu-id="d7707-257">El orden ascendente es el predeterminado y mantiene la compatibilidad con las versiones anteriores de [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span><span class="sxs-lookup"><span data-stu-id="d7707-257">Ascending is the default and maintains compatibility with earlier versions of [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="d7707-258">La sintaxis de las instrucciones CREATE INDEX, CREATE TABLE y ALTER TABLE admite las palabras clave ASC (ascendente) y DESC (descendente) en columnas individuales de índices y restricciones.</span><span class="sxs-lookup"><span data-stu-id="d7707-258">The syntax of the CREATE INDEX, CREATE TABLE, and ALTER TABLE statements supports the keywords ASC (ascending) and DESC (descending) on individual columns in indexes and constraints.</span></span>  
  
 <span data-ttu-id="d7707-259">La especificación del orden en que se almacenan los valores de clave en un índice es de utilidad cuando las consultas que hacen referencia a la tabla tienen cláusulas ORDER BY que especifican distintas direcciones para las columnas de clave del índice.</span><span class="sxs-lookup"><span data-stu-id="d7707-259">Specifying the order in which key values are stored in an index is useful when queries referencing the table have ORDER BY clauses that specify different directions for the key column or columns in that index.</span></span> <span data-ttu-id="d7707-260">En estos casos, el índice puede eliminar la necesidad de un operador SORT en el plan de consultas, lo que aumenta la eficacia de la consulta.</span><span class="sxs-lookup"><span data-stu-id="d7707-260">In these cases, the index can remove the need for a SORT operator in the query plan; therefore, this makes the query more efficient.</span></span> <span data-ttu-id="d7707-261">Por ejemplo, los compradores del departamento de compras de [!INCLUDE[ssSampleDBCoFull](../includes/sssampledbcofull-md.md)] tienen que evaluar la calidad de los productos que compran a los proveedores.</span><span class="sxs-lookup"><span data-stu-id="d7707-261">For example, the buyers in the [!INCLUDE[ssSampleDBCoFull](../includes/sssampledbcofull-md.md)] purchasing department have to evaluate the quality of products they purchase from vendors.</span></span> <span data-ttu-id="d7707-262">Los compradores están especialmente interesados en buscar productos enviados por estos proveedores con una tasa alta de rechazos.</span><span class="sxs-lookup"><span data-stu-id="d7707-262">The buyers are most interested in finding products sent by these vendors with a high rejection rate.</span></span> <span data-ttu-id="d7707-263">Como se muestra en la siguiente consulta, para recuperar los datos que cumplen estos criterios es necesario organizar la columna `RejectedQty` de la tabla `Purchasing.PurchaseOrderDetail` en orden descendente (de mayor a menor) y la columna `ProductID` en orden ascendente (de menor a mayor).</span><span class="sxs-lookup"><span data-stu-id="d7707-263">As shown in the following query, retrieving the data to meet this criteria requires the `RejectedQty` column in the `Purchasing.PurchaseOrderDetail` table to be sorted in descending order (large to small) and the `ProductID` column to be sorted in ascending order (small to large).</span></span>  
  
```sql
SELECT RejectedQty, ((RejectedQty/OrderQty)*100) AS RejectionRate,  
    ProductID, DueDate  
FROM Purchasing.PurchaseOrderDetail  
ORDER BY RejectedQty DESC, ProductID ASC;  
```  
  
 <span data-ttu-id="d7707-264">El siguiente plan de ejecución para esta consulta muestra que el optimizador de consultas utilizó un operador SORT para devolver el conjunto de resultados en el orden especificado mediante la cláusula ORDER BY.</span><span class="sxs-lookup"><span data-stu-id="d7707-264">The following execution plan for this query shows that the query optimizer used a SORT operator to return the result set in the order specified by the ORDER BY clause.</span></span>  
  
 <span data-ttu-id="d7707-265">![El plan de ejecución muestra el uso de un operador SORT](media/indexsort1.gif "El plan de ejecución muestra el uso de un operador SORT")</span><span class="sxs-lookup"><span data-stu-id="d7707-265">![Execution plan shows a SORT operator is used.](media/indexsort1.gif "Execution plan shows a SORT operator is used.")</span></span>  
  
 <span data-ttu-id="d7707-266">Si se crea un índice con columnas de clave que coincidan con las de la cláusula ORDER BY de la consulta, se puede eliminar el operador SORT del plan de consultas y éste resulta más eficaz.</span><span class="sxs-lookup"><span data-stu-id="d7707-266">If an index is created with key columns that match those in the ORDER BY clause in the query, the SORT operator can be eliminated in the query plan and the query plan is more efficient.</span></span>  
  
```sql
CREATE NONCLUSTERED INDEX IX_PurchaseOrderDetail_RejectedQty  
ON Purchasing.PurchaseOrderDetail  
    (RejectedQty DESC, ProductID ASC, DueDate, OrderQty);  
```  
  
 <span data-ttu-id="d7707-267">Cuando se ejecuta de nuevo la consulta, el plan de consultas siguiente muestra que se ha eliminado el operador SORT y se utiliza el índice no clúster que se acaba de crear.</span><span class="sxs-lookup"><span data-stu-id="d7707-267">After the query is executed again, the following execution plan shows that the SORT operator has been eliminated and the newly created nonclustered index is used.</span></span>  
  
 <span data-ttu-id="d7707-268">![El plan de ejecución muestra que no se usa un operador SORT](media/insertsort2.gif "El plan de ejecución muestra que no se usa un operador SORT")</span><span class="sxs-lookup"><span data-stu-id="d7707-268">![Execution plan shows a SORT operator is not used](media/insertsort2.gif "Execution plan shows a SORT operator is not used")</span></span>  
  
 <span data-ttu-id="d7707-269">[!INCLUDE[ssDE](../includes/ssde-md.md)] puede moverse con la misma eficacia en cualquier dirección.</span><span class="sxs-lookup"><span data-stu-id="d7707-269">The [!INCLUDE[ssDE](../includes/ssde-md.md)] can move equally efficiently in either direction.</span></span> <span data-ttu-id="d7707-270">Un índice definido como `(RejectedQty DESC, ProductID ASC)` se puede seguir utilizando para una consulta en la que se invierte la dirección de ordenación de las columnas en la cláusula ORDER BY.</span><span class="sxs-lookup"><span data-stu-id="d7707-270">An index defined as `(RejectedQty DESC, ProductID ASC)` can still be used for a query in which the sort direction of the columns in the ORDER BY clause are reversed.</span></span> <span data-ttu-id="d7707-271">Por ejemplo, una consulta con la cláusula ORDER BY `ORDER BY RejectedQty ASC, ProductID DESC` puede utilizar el índice.</span><span class="sxs-lookup"><span data-stu-id="d7707-271">For example, a query with the ORDER BY clause `ORDER BY RejectedQty ASC, ProductID DESC` can use the index.</span></span>  
  
 <span data-ttu-id="d7707-272">Solo se pueden especificar criterios de ordenación para columnas de clave.</span><span class="sxs-lookup"><span data-stu-id="d7707-272">Sort order can be specified only for key columns.</span></span> <span data-ttu-id="d7707-273">La vista de catálogo [sys.index_columns](/sql/relational-databases/system-catalog-views/sys-indexes-transact-sql) y la función INDEXKEY_PROPERTY informan de si una columna de índice está almacenada en orden ascendente o descendente.</span><span class="sxs-lookup"><span data-stu-id="d7707-273">The [sys.index_columns](/sql/relational-databases/system-catalog-views/sys-indexes-transact-sql) catalog view and the INDEXKEY_PROPERTY function report whether an index column is stored in ascending or descending order.</span></span>  
  
 <span data-ttu-id="d7707-274">![Icono de flecha usado con el vínculo volver al principio](media/uparrow16x16.gif "Icono de flecha usado con el vínculo Volver al principio") [de esta guía](#Top)</span><span class="sxs-lookup"><span data-stu-id="d7707-274">![Arrow icon used with Back to Top link](media/uparrow16x16.gif "Arrow icon used with Back to Top link") [In This Guide](#Top)</span></span>  
  
##  <a name="clustered-index-design-guidelines"></a><a name="Clustered"></a> <span data-ttu-id="d7707-275">Directrices para diseñar índices clúster</span><span class="sxs-lookup"><span data-stu-id="d7707-275">Clustered Index Design Guidelines</span></span>  

 <span data-ttu-id="d7707-276">Los índices clúster ordenan y almacenan las filas de los datos de la tabla de acuerdo con los valores de la clave del índice.</span><span class="sxs-lookup"><span data-stu-id="d7707-276">Clustered indexes sort and store the data rows in the table based on their key values.</span></span> <span data-ttu-id="d7707-277">Solo puede haber un índice clúster por cada tabla, porque las filas de datos solo pueden estar ordenadas de una forma.</span><span class="sxs-lookup"><span data-stu-id="d7707-277">There can only be one clustered index per table, because the data rows themselves can only be sorted in one order.</span></span> <span data-ttu-id="d7707-278">Salvo excepciones, todas las tablas deben incluir un índice clúster definido en las columnas que presenten las siguientes características:</span><span class="sxs-lookup"><span data-stu-id="d7707-278">With few exceptions, every table should have a clustered index defined on the column, or columns, that offer the following:</span></span>  
  
-   <span data-ttu-id="d7707-279">Se pueden utilizar en consultas frecuentes.</span><span class="sxs-lookup"><span data-stu-id="d7707-279">Can be used for frequently used queries.</span></span>  
  
-   <span data-ttu-id="d7707-280">Proporcionan un alto grado de unicidad.</span><span class="sxs-lookup"><span data-stu-id="d7707-280">Provide a high degree of uniqueness.</span></span>  
  
    > [!NOTE]  
    >  <span data-ttu-id="d7707-281">Cuando crea una restricción PRIMARY KEY, se crea automáticamente un índice único en las columnas.</span><span class="sxs-lookup"><span data-stu-id="d7707-281">When you create a PRIMARY KEY constraint, a unique index on the column, or columns, is automatically created.</span></span> <span data-ttu-id="d7707-282">De forma predeterminada, este índice es clúster; sin embargo, puede especificar un índice no clúster cuando crea la restricción.</span><span class="sxs-lookup"><span data-stu-id="d7707-282">By default, this index is clustered; however, you can specify a nonclustered index when you create the constraint.</span></span>  
  
-   <span data-ttu-id="d7707-283">Se pueden utilizar en consultas por rango.</span><span class="sxs-lookup"><span data-stu-id="d7707-283">Can be used in range queries.</span></span>  
  
 <span data-ttu-id="d7707-284">Si el índice clúster no se crea con la propiedad UNIQUE, el [!INCLUDE[ssDE](../includes/ssde-md.md)] agrega automáticamente una columna uniquifier de 4 bytes a la tabla.</span><span class="sxs-lookup"><span data-stu-id="d7707-284">If the clustered index is not created with the UNIQUE property, the [!INCLUDE[ssDE](../includes/ssde-md.md)] automatically adds a 4-byte uniquifier column to the table.</span></span> <span data-ttu-id="d7707-285">Cuando es necesario, el [!INCLUDE[ssDE](../includes/ssde-md.md)] agrega automáticamente un valor de uniquifier a una fila para que cada clave sea única.</span><span class="sxs-lookup"><span data-stu-id="d7707-285">When it is required, the [!INCLUDE[ssDE](../includes/ssde-md.md)] automatically adds a uniquifier value to a row to make each key unique.</span></span> <span data-ttu-id="d7707-286">Esta columna y sus valores se utilizan de forma interna; los usuarios no pueden verlos ni tener acceso a ellos.</span><span class="sxs-lookup"><span data-stu-id="d7707-286">This column and its values are used internally and cannot be seen or accessed by users.</span></span>  
  
### <a name="clustered-index-architecture"></a><span data-ttu-id="d7707-287">Arquitectura de los índices clúster</span><span class="sxs-lookup"><span data-stu-id="d7707-287">Clustered Index Architecture</span></span>  

 <span data-ttu-id="d7707-288">En [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)], los índices se organizan como árboles b.</span><span class="sxs-lookup"><span data-stu-id="d7707-288">In [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)], indexes are organized as B-trees.</span></span> <span data-ttu-id="d7707-289">Las páginas de un árbol b de índice se llaman nodos del índice.</span><span class="sxs-lookup"><span data-stu-id="d7707-289">Each page in an index B-tree is called an index node.</span></span> <span data-ttu-id="d7707-290">El nodo superior del árbol b se llama nodo raíz.</span><span class="sxs-lookup"><span data-stu-id="d7707-290">The top node of the B-tree is called the root node.</span></span> <span data-ttu-id="d7707-291">Los nodos inferiores del índice se denominan nodos hoja.</span><span class="sxs-lookup"><span data-stu-id="d7707-291">The bottom nodes in the index are called the leaf nodes.</span></span> <span data-ttu-id="d7707-292">Los niveles del índice entre el nodo raíz y los nodos hoja se conocen en conjunto como niveles intermedios.</span><span class="sxs-lookup"><span data-stu-id="d7707-292">Any index levels between the root and the leaf nodes are collectively known as intermediate levels.</span></span> <span data-ttu-id="d7707-293">En un índice clúster, los nodos hoja contienen las páginas de datos de la tabla subyacente.</span><span class="sxs-lookup"><span data-stu-id="d7707-293">In a clustered index, the leaf nodes contain the data pages of the underlying table.</span></span> <span data-ttu-id="d7707-294">El nodo raíz y los nodos intermedios incluyen páginas de índice que contienen filas de índice.</span><span class="sxs-lookup"><span data-stu-id="d7707-294">The root and intermediate level nodes contain index pages holding index rows.</span></span> <span data-ttu-id="d7707-295">Cada fila de índice contiene un valor clave y un puntero a una página de nivel intermedio en el árbol b, o bien a una fila de datos del nivel hoja del índice.</span><span class="sxs-lookup"><span data-stu-id="d7707-295">Each index row contains a key value and a pointer to either an intermediate level page in the B-tree, or a data row in the leaf level of the index.</span></span> <span data-ttu-id="d7707-296">Las páginas de cada nivel del índice se vinculan en una lista con vínculos dobles.</span><span class="sxs-lookup"><span data-stu-id="d7707-296">The pages in each level of the index are linked in a doubly-linked list.</span></span>  
  
 <span data-ttu-id="d7707-297">Los índices clúster tienen una fila en [sys.partitions](/sql/relational-databases/system-catalog-views/sys-partitions-transact-sql), con **index_id** = 1 para cada partición usada por el índice.</span><span class="sxs-lookup"><span data-stu-id="d7707-297">Clustered indexes have one row in [sys.partitions](/sql/relational-databases/system-catalog-views/sys-partitions-transact-sql), with **index_id** = 1 for each partition used by the index.</span></span> <span data-ttu-id="d7707-298">De forma predeterminada, un índice clúster tiene una sola partición.</span><span class="sxs-lookup"><span data-stu-id="d7707-298">By default, a clustered index has a single partition.</span></span> <span data-ttu-id="d7707-299">Cuando un índice clúster tiene múltiples particiones, cada partición tiene una estructura de árbol b que contiene los datos de esa partición específica.</span><span class="sxs-lookup"><span data-stu-id="d7707-299">When a clustered index has multiple partitions, each partition has a B-tree structure that contains the data for that specific partition.</span></span> <span data-ttu-id="d7707-300">Por ejemplo, si un índice clúster tiene cuatro particiones, hay cuatro estructuras de árbol b, una en cada partición.</span><span class="sxs-lookup"><span data-stu-id="d7707-300">For example, if a clustered index has four partitions, there are four B-tree structures; one in each partition.</span></span>  
  
 <span data-ttu-id="d7707-301">En función de los tipos de datos del índice clúster, cada estructura de índice clúster tendrá una o más unidades de asignación en las que almacenar y administrar los datos de una partición específica.</span><span class="sxs-lookup"><span data-stu-id="d7707-301">Depending on the data types in the clustered index, each clustered index structure will have one or more allocation units in which to store and manage the data for a specific partition.</span></span> <span data-ttu-id="d7707-302">Como mínimo, cada índice clúster tendrá una unidad de asignación IN_ROW_DATA por partición.</span><span class="sxs-lookup"><span data-stu-id="d7707-302">At a minimum, each clustered index will have one IN_ROW_DATA allocation unit per partition.</span></span> <span data-ttu-id="d7707-303">El índice clúster también tendrá una unidad de asignación LOB_DATA por partición si contiene columnas de objetos grandes (LOB).</span><span class="sxs-lookup"><span data-stu-id="d7707-303">The clustered index will also have one LOB_DATA allocation unit per partition if it contains large object (LOB) columns.</span></span> <span data-ttu-id="d7707-304">También tendrá una unidad de asignación ROW_OVERFLOW_DATA por partición si contiene columnas de longitud variable que superen el límite de tamaño de fila de 8.060 bytes.</span><span class="sxs-lookup"><span data-stu-id="d7707-304">It will also have one ROW_OVERFLOW_DATA allocation unit per partition if it contains variable length columns that exceed the 8,060 byte row size limit.</span></span>  
  
 <span data-ttu-id="d7707-305">Las páginas de la cadena de datos y las filas que contienen se ordenan según el valor de la clave de índice clúster.</span><span class="sxs-lookup"><span data-stu-id="d7707-305">The pages in the data chain and the rows in them are ordered on the value of the clustered index key.</span></span> <span data-ttu-id="d7707-306">Todas las inserciones se hacen en el punto en el que el valor de clave de la fila insertada quede dentro de la secuencia de orden entre las filas existentes.</span><span class="sxs-lookup"><span data-stu-id="d7707-306">All inserts are made at the point where the key value in the inserted row fits in the ordering sequence among existing rows.</span></span>  
  
 <span data-ttu-id="d7707-307">En esta ilustración se muestra la estructura de un índice clúster en una sola partición.</span><span class="sxs-lookup"><span data-stu-id="d7707-307">This illustration shows the structure of a clustered index in a single partition.</span></span>  
  
 <span data-ttu-id="d7707-308">![Niveles de un índice clúster](media/bokind2.gif "Niveles de un índice clúster")</span><span class="sxs-lookup"><span data-stu-id="d7707-308">![Levels of a clustered index](media/bokind2.gif "Levels of a clustered index")</span></span>  
  
### <a name="query-considerations"></a><span data-ttu-id="d7707-309">Consideraciones sobre consultas</span><span class="sxs-lookup"><span data-stu-id="d7707-309">Query Considerations</span></span>  

 <span data-ttu-id="d7707-310">Antes de crear índices clúster, debe conocer cómo se tiene acceso a los datos.</span><span class="sxs-lookup"><span data-stu-id="d7707-310">Before you create clustered indexes, understand how your data will be accessed.</span></span> <span data-ttu-id="d7707-311">Considere que utiliza un índice clúster en consultas que realizan lo siguiente:</span><span class="sxs-lookup"><span data-stu-id="d7707-311">Consider using a clustered index for queries that do the following:</span></span>  
  
-   <span data-ttu-id="d7707-312">Devuelven un intervalo de valores mediante la utilización de operadores como BETWEEN, >, >=, < y <=.</span><span class="sxs-lookup"><span data-stu-id="d7707-312">Return a range of values by using operators such as BETWEEN, >, >=, <, and <=.</span></span>  
  
     <span data-ttu-id="d7707-313">Cuando la fila se encuentra con el primer valor mediante el índice clúster, se garantiza que las filas con los valores indizados posteriores son físicamente adyacentes.</span><span class="sxs-lookup"><span data-stu-id="d7707-313">After the row with the first value is found by using the clustered index, rows with subsequent indexed values are guaranteed to be physically adjacent.</span></span> <span data-ttu-id="d7707-314">Por ejemplo, si una consulta recupera registros entre un intervalo de números de pedidos de ventas, un índice clúster en la columna `SalesOrderNumber` puede encontrar rápidamente la fila que contiene el número de pedido de ventas inicial y, a continuación, recuperar todas las filas sucesivas de la tabla hasta llegar al último número de pedido de ventas.</span><span class="sxs-lookup"><span data-stu-id="d7707-314">For example, if a query retrieves records between a range of sales order numbers, a clustered index on the column `SalesOrderNumber` can quickly locate the row that contains the starting sales order number, and then retrieve all successive rows in the table until the last sales order number is reached.</span></span>  
  
-   <span data-ttu-id="d7707-315">Devuelven grandes conjuntos de resultados.</span><span class="sxs-lookup"><span data-stu-id="d7707-315">Return large result sets.</span></span>  
  
-   <span data-ttu-id="d7707-316">Utilizan cláusulas JOIN; por lo general, son columnas de clave externa.</span><span class="sxs-lookup"><span data-stu-id="d7707-316">Use JOIN clauses; typically these are foreign key columns.</span></span>  
  
-   <span data-ttu-id="d7707-317">Utilizan cláusulas ORDER BY o GROUP BY.</span><span class="sxs-lookup"><span data-stu-id="d7707-317">Use ORDER BY, or GROUP BY clauses.</span></span>  
  
     <span data-ttu-id="d7707-318">Un índice en las columnas especificadas en la cláusula ORDER BY o GROUP BY puede eliminar la necesidad de que [!INCLUDE[ssDE](../includes/ssde-md.md)] ordene los datos, puesto que las filas ya están ordenadas.</span><span class="sxs-lookup"><span data-stu-id="d7707-318">An index on the columns specified in the ORDER BY or GROUP BY clause may remove the need for the [!INCLUDE[ssDE](../includes/ssde-md.md)] to sort the data, because the rows are already sorted.</span></span> <span data-ttu-id="d7707-319">De ese modo, el rendimiento de las consultas aumenta.</span><span class="sxs-lookup"><span data-stu-id="d7707-319">This improves query performance.</span></span>  
  
### <a name="column-considerations"></a><span data-ttu-id="d7707-320">Consideraciones sobre columnas</span><span class="sxs-lookup"><span data-stu-id="d7707-320">Column Considerations</span></span>  

 <span data-ttu-id="d7707-321">Por regla genera, debe definir la clave de índice clúster con el menor número de columnas posible.</span><span class="sxs-lookup"><span data-stu-id="d7707-321">Generally, you should define the clustered index key with as few columns as possible.</span></span> <span data-ttu-id="d7707-322">Considere columnas que cuentan con uno o varios de los siguientes atributos:</span><span class="sxs-lookup"><span data-stu-id="d7707-322">Consider columns that have one or more of the following attributes:</span></span>  
  
-   <span data-ttu-id="d7707-323">Son únicas o contienen muchos valores distintos</span><span class="sxs-lookup"><span data-stu-id="d7707-323">Are unique or contain many distinct values</span></span>  
  
     <span data-ttu-id="d7707-324">Por ejemplo, un Id. de empleado identifica de forma exclusiva a los empleados.</span><span class="sxs-lookup"><span data-stu-id="d7707-324">For example, an employee ID uniquely identifies employees.</span></span> <span data-ttu-id="d7707-325">Un índice clúster o una restricción PRIMARY KEY en la columna `EmployeeID` mejoraría el rendimiento de las consultas que buscan información de empleado según el número de identificador del empleado.</span><span class="sxs-lookup"><span data-stu-id="d7707-325">A clustered index or PRIMARY KEY constraint on the `EmployeeID` column would improve the performance of queries that search for employee information based on the employee ID number.</span></span> <span data-ttu-id="d7707-326">También se podría crear un índice clúster en las columnas `LastName`, `FirstName`y `MiddleName` , ya que los registros de empleados se suelen agrupar y consultar de esta forma, y la combinación de estas columnas seguiría proporcionando un alto grado de diferencia.</span><span class="sxs-lookup"><span data-stu-id="d7707-326">Alternatively, a clustered index could be created on `LastName`, `FirstName`, `MiddleName` because employee records are frequently grouped and queried in this way, and the combination of these columns would still provide a high degree of difference.</span></span>  
  
-   <span data-ttu-id="d7707-327">Se tiene acceso a ellas de forma secuencial</span><span class="sxs-lookup"><span data-stu-id="d7707-327">Are accessed sequentially</span></span>  
  
     <span data-ttu-id="d7707-328">Por ejemplo, un identificador de producto identifica de forma exclusiva los productos de la tabla `Production.Product` en la base de datos [!INCLUDE[ssSampleDBobject](../includes/sssampledbobject-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="d7707-328">For example, a product ID uniquely identifies products in the `Production.Product` table in the [!INCLUDE[ssSampleDBobject](../includes/sssampledbobject-md.md)] database.</span></span> <span data-ttu-id="d7707-329">Un índice clúster en `WHERE ProductID BETWEEN 980 and 999`mejoraría las consultas en las que se especifica una búsqueda secuencial, como `ProductID`.</span><span class="sxs-lookup"><span data-stu-id="d7707-329">Queries in which a sequential search is specified, such as `WHERE ProductID BETWEEN 980 and 999`, would benefit from a clustered index on `ProductID`.</span></span> <span data-ttu-id="d7707-330">Esto se debe a que las filas se almacenan de forma ordenada en esta columna de clave.</span><span class="sxs-lookup"><span data-stu-id="d7707-330">This is because the rows would be stored in sorted order on that key column.</span></span>  
  
-   <span data-ttu-id="d7707-331">Se define como IDENTITY.</span><span class="sxs-lookup"><span data-stu-id="d7707-331">Defined as IDENTITY.</span></span>  
  
-   <span data-ttu-id="d7707-332">Se utilizan con frecuencia para ordenar los datos recuperados de una tabla</span><span class="sxs-lookup"><span data-stu-id="d7707-332">Used frequently to sort the data retrieved from a table.</span></span>  
  
     <span data-ttu-id="d7707-333">Puede resultar conveniente agrupar, es decir, ordenar físicamente la tabla de dicha columna para evitar una operación de ordenación cada vez que se consulta la columna.</span><span class="sxs-lookup"><span data-stu-id="d7707-333">It can be a good idea to cluster, that is physically sort, the table on that column to save the cost of a sort operation every time the column is queried.</span></span>  
  
 <span data-ttu-id="d7707-334">Los índices clúster no son adecuados para los siguientes atributos:</span><span class="sxs-lookup"><span data-stu-id="d7707-334">Clustered indexes are not a good choice for the following attributes:</span></span>  
  
-   <span data-ttu-id="d7707-335">Columnas sometidas a cambios frecuentes</span><span class="sxs-lookup"><span data-stu-id="d7707-335">Columns that undergo frequent changes</span></span>  
  
     <span data-ttu-id="d7707-336">Esto hace que se mueva toda la fila, ya que [!INCLUDE[ssDE](../includes/ssde-md.md)] debe mantener los valores de datos de una fila en orden físico.</span><span class="sxs-lookup"><span data-stu-id="d7707-336">This causes the whole row to move, because the [!INCLUDE[ssDE](../includes/ssde-md.md)] must keep the data values of a row in physical order.</span></span> <span data-ttu-id="d7707-337">Esta consideración es importante en sistemas de procesamiento de transacciones de gran volumen en los que los datos tienden a ser volátiles.</span><span class="sxs-lookup"><span data-stu-id="d7707-337">This is an important consideration in high-volume transaction processing systems in which data is typically volatile.</span></span>  
  
-   <span data-ttu-id="d7707-338">Claves amplias</span><span class="sxs-lookup"><span data-stu-id="d7707-338">Wide keys</span></span>  
  
     <span data-ttu-id="d7707-339">Las claves amplias se componen de varias columnas o varias columnas de gran tamaño.</span><span class="sxs-lookup"><span data-stu-id="d7707-339">Wide keys are a composite of several columns or several large-size columns.</span></span> <span data-ttu-id="d7707-340">Los valores clave del índice clúster se utilizan en todos los índices no clúster como claves de búsqueda.</span><span class="sxs-lookup"><span data-stu-id="d7707-340">The key values from the clustered index are used by all nonclustered indexes as lookup keys.</span></span> <span data-ttu-id="d7707-341">Los índices no clúster definidos en la misma tabla serán bastante más grandes, ya que sus entradas contienen la clave de agrupación en clústeres y las columnas de clave definidas para dicho índice no clúster.</span><span class="sxs-lookup"><span data-stu-id="d7707-341">Any nonclustered indexes defined on the same table will be significantly larger because the nonclustered index entries contain the clustering key and also the key columns defined for that nonclustered index.</span></span>  
  
 <span data-ttu-id="d7707-342">![Icono de flecha usado con el vínculo volver al principio](media/uparrow16x16.gif "Icono de flecha usado con el vínculo Volver al principio") [de esta guía](#Top)</span><span class="sxs-lookup"><span data-stu-id="d7707-342">![Arrow icon used with Back to Top link](media/uparrow16x16.gif "Arrow icon used with Back to Top link") [In This Guide](#Top)</span></span>  
  
##  <a name="nonclustered-index-design-guidelines"></a><a name="Nonclustered"></a> <span data-ttu-id="d7707-343">Directrices para diseñar índices no clúster</span><span class="sxs-lookup"><span data-stu-id="d7707-343">Nonclustered Index Design Guidelines</span></span>  

 <span data-ttu-id="d7707-344">Un índice no clúster contiene los valores de clave del índice y localizadores de fila que apuntan a la ubicación de almacenamiento de los datos de tabla.</span><span class="sxs-lookup"><span data-stu-id="d7707-344">A nonclustered index contains the index key values and row locators that point to the storage location of the table data.</span></span> <span data-ttu-id="d7707-345">Se pueden crear varios índices no clúster en una tabla o una vista indizada.</span><span class="sxs-lookup"><span data-stu-id="d7707-345">You can create multiple nonclustered indexes on a table or indexed view.</span></span> <span data-ttu-id="d7707-346">Por lo general, se deben diseñar índices no clúster para mejorar el rendimiento de consultas utilizadas con frecuencia no cubiertas por el índice clúster.</span><span class="sxs-lookup"><span data-stu-id="d7707-346">Generally, nonclustered indexes should be designed to improve the performance of frequently used queries that are not covered by the clustered index.</span></span>  
  
 <span data-ttu-id="d7707-347">Al igual que cuando se utiliza un índice de un libro, el optimizador de consultas busca valores de datos en el índice no clúster para encontrar la ubicación del valor de datos en la tabla y, a continuación, recupera los datos directamente de esa ubicación.</span><span class="sxs-lookup"><span data-stu-id="d7707-347">Similar to the way you use an index in a book, the query optimizer searches for a data value by searching the nonclustered index to find the location of the data value in the table and then retrieves the data directly from that location.</span></span> <span data-ttu-id="d7707-348">Este sistema convierte a los índices no clúster en la opción más apropiada para las consultas de coincidencia exacta, dado que el índice contiene entradas que describen la ubicación exacta en la tabla de los valores de datos que se buscan en las consultas.</span><span class="sxs-lookup"><span data-stu-id="d7707-348">This makes nonclustered indexes the optimal choice for exact match queries because the index contains entries describing the exact location in the table of the data values being searched for in the queries.</span></span> <span data-ttu-id="d7707-349">Por ejemplo, para consultar la tabla `HumanResources. Employee` con el fin de ver todos los subordinados de un jefe determinado, el optimizador de consultas podría usar el índice no clúster `IX_Employee_ManagerID`, que tiene `ManagerID` como columna de clave.</span><span class="sxs-lookup"><span data-stu-id="d7707-349">For example, to query the `HumanResources. Employee` table for all employees that report to a specific manager, the query optimizer might use the nonclustered index `IX_Employee_ManagerID`; this has `ManagerID` as its key column.</span></span> <span data-ttu-id="d7707-350">El optimizador de consultas puede buscar rápidamente todas las entradas del índice que coinciden con el `ManagerID`especificado.</span><span class="sxs-lookup"><span data-stu-id="d7707-350">The query optimizer can quickly find all entries in the index that match the specified `ManagerID`.</span></span> <span data-ttu-id="d7707-351">Cada entrada de índice apunta a la página y fila exactas de la tabla, o índice clúster, en que se pueden encontrar los datos correspondientes.</span><span class="sxs-lookup"><span data-stu-id="d7707-351">Each index entry points to the exact page and row in the table, or clustered index, in which the corresponding data can be found.</span></span> <span data-ttu-id="d7707-352">Una vez que el optimizador de consultas busca todas las entradas del índice, puede ir directamente a la página y fila exactas para recuperar los datos.</span><span class="sxs-lookup"><span data-stu-id="d7707-352">After the query optimizer finds all entries in the index, it can go directly to the exact page and row to retrieve the data.</span></span>  
  
### <a name="nonclustered-index-architecture"></a><span data-ttu-id="d7707-353">Arquitectura de los índices no clúster</span><span class="sxs-lookup"><span data-stu-id="d7707-353">Nonclustered Index Architecture</span></span>  

 <span data-ttu-id="d7707-354">Los índices no clúster tienen la misma estructura de árbol b que los índices clúster, excepto por las siguientes diferencias importantes:</span><span class="sxs-lookup"><span data-stu-id="d7707-354">Nonclustered indexes have the same B-tree structure as clustered indexes, except for the following significant differences:</span></span>  
  
-   <span data-ttu-id="d7707-355">Las filas de datos de la tabla subyacente no están ordenadas ni almacenadas basándose en sus claves no agrupadas.</span><span class="sxs-lookup"><span data-stu-id="d7707-355">The data rows of the underlying table are not sorted and stored in order based on their nonclustered keys.</span></span>  
  
-   <span data-ttu-id="d7707-356">La capa de hoja de un índice no clúster está compuesta por páginas de índices, en lugar de páginas de datos.</span><span class="sxs-lookup"><span data-stu-id="d7707-356">The leaf layer of a nonclustered index is made up of index pages instead of data pages.</span></span>  
  
 <span data-ttu-id="d7707-357">Los localizadores de filas de las filas de índices no clúster pueden ser un puntero a la fila o una clave de índice clúster para una fila, tal como se describe a continuación:</span><span class="sxs-lookup"><span data-stu-id="d7707-357">The row locators in nonclustered index rows are either a pointer to a row or are a clustered index key for a row, as described in the following:</span></span>  
  
-   <span data-ttu-id="d7707-358">Si la tabla es un montón, lo que significa que no tiene ningún índice clúster, el localizador de fila es un puntero a la fila.</span><span class="sxs-lookup"><span data-stu-id="d7707-358">If the table is a heap, which means it does not have a clustered index, the row locator is a pointer to the row.</span></span> <span data-ttu-id="d7707-359">El puntero se genera a partir del identificador (Id.) de archivo, el número de página y el número de la fila dentro de la página.</span><span class="sxs-lookup"><span data-stu-id="d7707-359">The pointer is built from the file identifier (ID), page number, and number of the row on the page.</span></span> <span data-ttu-id="d7707-360">El puntero completo se conoce como Id. de fila (RID).</span><span class="sxs-lookup"><span data-stu-id="d7707-360">The whole pointer is known as a Row ID (RID).</span></span>  
  
-   <span data-ttu-id="d7707-361">Si la tabla tiene un índice clúster o si el índice está en una vista indizada, el localizador de fila es la clave del índice clúster para la fila.</span><span class="sxs-lookup"><span data-stu-id="d7707-361">If the table has a clustered index, or the index is on an indexed view, the row locator is the clustered index key for the row.</span></span>  
  
 <span data-ttu-id="d7707-362">Los índices no agrupados tienen una fila en [sys.partitions](/sql/relational-databases/system-catalog-views/sys-partitions-transact-sql), con **index_id** >1 para cada partición usada por el índice.</span><span class="sxs-lookup"><span data-stu-id="d7707-362">Nonclustered indexes have one row in [sys.partitions](/sql/relational-databases/system-catalog-views/sys-partitions-transact-sql) with **index_id** >1 for each partition used by the index.</span></span> <span data-ttu-id="d7707-363">De forma predeterminada, un índice no clúster tiene una sola partición.</span><span class="sxs-lookup"><span data-stu-id="d7707-363">By default, a nonclustered index has a single partition.</span></span> <span data-ttu-id="d7707-364">Cuando un índice no clúster tiene varias particiones, cada una tiene una estructura de árbol b que contiene las filas de índice de esa partición específica.</span><span class="sxs-lookup"><span data-stu-id="d7707-364">When a nonclustered index has multiple partitions, each partition has a B-tree structure that contains the index rows for that specific partition.</span></span> <span data-ttu-id="d7707-365">Por ejemplo, si un índice no clúster tiene cuatro particiones, habrá cuatro estructuras de árbol b, una en cada partición.</span><span class="sxs-lookup"><span data-stu-id="d7707-365">For example, if a nonclustered index has four partitions, there are four B-tree structures, with one in each partition.</span></span>  
  
 <span data-ttu-id="d7707-366">En función de los tipos de datos del índice no clúster, cada estructura de índice no clúster tendrá una o más unidades de asignación en las que almacenar y administrar los datos de una partición específica.</span><span class="sxs-lookup"><span data-stu-id="d7707-366">Depending on the data types in the nonclustered index, each nonclustered index structure will have one or more allocation units in which to store and manage the data for a specific partition.</span></span> <span data-ttu-id="d7707-367">Como mínimo, cada índice no clúster tendrá una unidad de asignación IN_ROW_DATA por partición encargada de almacenar las páginas de árbol b del índice.</span><span class="sxs-lookup"><span data-stu-id="d7707-367">At a minimum, each nonclustered index will have one IN_ROW_DATA allocation unit per partition that stores the index B-tree pages.</span></span> <span data-ttu-id="d7707-368">El índice no clúster también tendrá una unidad de asignación LOB_DATA por partición si contiene columnas de objetos grandes (LOB).</span><span class="sxs-lookup"><span data-stu-id="d7707-368">The nonclustered index will also have one LOB_DATA allocation unit per partition if it contains large object (LOB) columns .</span></span> <span data-ttu-id="d7707-369">También tendrá una unidad de asignación ROW_OVERFLOW_DATA por partición si contiene columnas de longitud variable que superen el límite de tamaño de fila de 8.060 bytes.</span><span class="sxs-lookup"><span data-stu-id="d7707-369">Additionally, it will have one ROW_OVERFLOW_DATA allocation unit per partition if it contains variable length columns that exceed the 8,060 byte row size limit.</span></span>  
  
 <span data-ttu-id="d7707-370">En la siguiente ilustración se muestra la estructura de un índice no clúster en una sola partición.</span><span class="sxs-lookup"><span data-stu-id="d7707-370">The following illustration shows the structure of a nonclustered index in a single partition.</span></span>  
  
 <span data-ttu-id="d7707-371">![Niveles de un índice no clúster](media/bokind1.gif "Niveles de un índice no clúster")</span><span class="sxs-lookup"><span data-stu-id="d7707-371">![Levels of a nonclustered index](media/bokind1.gif "Levels of a nonclustered index")</span></span>  
  
### <a name="database-considerations"></a><span data-ttu-id="d7707-372">Consideraciones acerca de la base de datos</span><span class="sxs-lookup"><span data-stu-id="d7707-372">Database Considerations</span></span>  

 <span data-ttu-id="d7707-373">Tenga en cuenta las características de la base de datos al diseñar índices no clúster.</span><span class="sxs-lookup"><span data-stu-id="d7707-373">Consider the characteristics of the database when designing nonclustered indexes.</span></span>  
  
-   <span data-ttu-id="d7707-374">Las bases de datos o tablas que exigen pocos requisitos para la actualización, pero suelen contener un gran volumen de datos, se pueden beneficiar de muchos índices no clúster para mejorar el optimizador de consultas.</span><span class="sxs-lookup"><span data-stu-id="d7707-374">Databases or tables with low update requirements, but large volumes of data can benefit from many nonclustered indexes to improve query performance.</span></span> <span data-ttu-id="d7707-375">Considere la creación de índices filtrados para subconjuntos bien definidos de datos con el fin de mejorar el rendimiento de las consultas, reducir los costos de almacenamiento del índice y reducir los costos de mantenimiento del índice en comparación con índices no clúster de la tabla completa.</span><span class="sxs-lookup"><span data-stu-id="d7707-375">Consider creating filtered indexes for well-defined subsets of data to improve query performance, reduce index storage costs, and reduce index maintenance costs compared with full-table nonclustered indexes.</span></span>  
  
     <span data-ttu-id="d7707-376">Las aplicaciones y bases de datos del sistema de ayuda para la toma de decisiones que contienen principalmente datos de solo lectura se pueden beneficiar de muchos índices no clúster.</span><span class="sxs-lookup"><span data-stu-id="d7707-376">Decision Support System applications and databases that contain primarily read-only data can benefit from many nonclustered indexes.</span></span> <span data-ttu-id="d7707-377">El optimizador de consultas tiene más índices entre los que elegir para determinar el método de acceso más rápido. Además, las características que exigen pocos requisitos para la actualización de la base de datos se traducen en que el mantenimiento de los índices no reducirá el rendimiento.</span><span class="sxs-lookup"><span data-stu-id="d7707-377">The query optimizer has more indexes to choose from to determine the fastest access method, and the low update characteristics of the database mean index maintenance will not impede performance.</span></span>  
  
-   <span data-ttu-id="d7707-378">Las aplicaciones y bases de datos de procesamiento de transacciones en línea (OLTP) que contienen tablas deben evitar el exceso de índices.</span><span class="sxs-lookup"><span data-stu-id="d7707-378">Online Transaction Processing applications and databases that contain heavily updated tables should avoid over-indexing.</span></span> <span data-ttu-id="d7707-379">Además, los índices deben ser estrechos, es decir, con la menor cantidad de columnas posible.</span><span class="sxs-lookup"><span data-stu-id="d7707-379">Additionally, indexes should be narrow, that is, with as few columns as possible.</span></span>  
  
     <span data-ttu-id="d7707-380">Si se utiliza un gran número de índices en una tabla, el rendimiento de las instrucciones INSERT, UPDATE, DELETE y MERGE se verá afectado, ya que todos los índices deben ajustarse adecuadamente a medida que cambian los datos de la tabla.</span><span class="sxs-lookup"><span data-stu-id="d7707-380">Large numbers of indexes on a table affect the performance of INSERT, UPDATE, DELETE, and MERGE  statements because all indexes must be adjusted appropriately as data in the table changes.</span></span>  
  
### <a name="query-considerations"></a><span data-ttu-id="d7707-381">Consideraciones sobre consultas</span><span class="sxs-lookup"><span data-stu-id="d7707-381">Query Considerations</span></span>  

 <span data-ttu-id="d7707-382">Antes de crear índices no clúster, debe conocer cómo se tiene acceso a los datos.</span><span class="sxs-lookup"><span data-stu-id="d7707-382">Before you create nonclustered indexes, you should understand how your data will be accessed.</span></span> <span data-ttu-id="d7707-383">Considere la posibilidad de utilizar un índice no clúster para consultas que cuentan con los siguientes atributos:</span><span class="sxs-lookup"><span data-stu-id="d7707-383">Consider using a nonclustered index for queries that have the following attributes:</span></span>  
  
-   <span data-ttu-id="d7707-384">Utilizan cláusulas JOIN o GROUP BY.</span><span class="sxs-lookup"><span data-stu-id="d7707-384">Use JOIN or GROUP BY clauses.</span></span>  
  
     <span data-ttu-id="d7707-385">Crean varios índices no clúster para las columnas que intervienen en operaciones de combinación y de agrupación, y un índice clúster para las columnas de clave externa.</span><span class="sxs-lookup"><span data-stu-id="d7707-385">Create multiple nonclustered indexes on columns involved in join and grouping operations, and a clustered index on any foreign key columns.</span></span>  
  
-   <span data-ttu-id="d7707-386">No devuelven conjuntos de resultados de gran tamaño.</span><span class="sxs-lookup"><span data-stu-id="d7707-386">Queries that do not return large result sets.</span></span>  
  
     <span data-ttu-id="d7707-387">Cree índices filtrados para atender consultas que devuelven un subconjunto bien definido de filas en una tabla grande.</span><span class="sxs-lookup"><span data-stu-id="d7707-387">Create filtered indexes to cover queries that return a well-defined subset of rows from a large table.</span></span>  
  
-   <span data-ttu-id="d7707-388">Contienen columnas que suelen incluirse en las condiciones de búsqueda de una consulta, como la cláusula WHERE, que devuelven coincidencias exactas.</span><span class="sxs-lookup"><span data-stu-id="d7707-388">Contain columns frequently involved in search conditions of a query, such as WHERE clause, that return exact matches.</span></span>  
  
### <a name="column-considerations"></a><span data-ttu-id="d7707-389">Consideraciones sobre columnas</span><span class="sxs-lookup"><span data-stu-id="d7707-389">Column Considerations</span></span>  

 <span data-ttu-id="d7707-390">Tenga en cuenta las columnas que tengan uno o varios de estos atributos:</span><span class="sxs-lookup"><span data-stu-id="d7707-390">Consider columns that have one or more of these attributes:</span></span>  
  
-   <span data-ttu-id="d7707-391">Cubren la consulta.</span><span class="sxs-lookup"><span data-stu-id="d7707-391">Cover the query.</span></span>  
  
     <span data-ttu-id="d7707-392">Se obtienen mejoras de rendimiento cuando el índice contiene todas las columnas de la consulta.</span><span class="sxs-lookup"><span data-stu-id="d7707-392">Performance gains are achieved when the index contains all columns in the query.</span></span> <span data-ttu-id="d7707-393">El optimizador de consultas puede buscar todos los valores de columna del índice; no se tiene acceso a los datos de tabla o de índice clúster, lo que se traduce en menos operaciones de E/S de disco.</span><span class="sxs-lookup"><span data-stu-id="d7707-393">The query optimizer can locate all the column values within the index; table or clustered index data is not accessed resulting in fewer disk I/O operations.</span></span> <span data-ttu-id="d7707-394">Utilice un índice con columnas incluidas para agregar columnas de cobertura en lugar de crear una clave de índice ancho.</span><span class="sxs-lookup"><span data-stu-id="d7707-394">Use index with included columns to add covering columns instead of creating a wide index key.</span></span>  
  
     <span data-ttu-id="d7707-395">Si la tabla tiene un índice clúster, las columnas definidas en él se anexan automáticamente al final de cada índice no clúster de la tabla.</span><span class="sxs-lookup"><span data-stu-id="d7707-395">If the table has a clustered index, the column or columns defined in the clustered index are automatically appended to the end of each nonclustered index on the table.</span></span> <span data-ttu-id="d7707-396">Esto puede producir una consulta cubierta sin especificar las columnas de índice clúster en la definición del índice no clúster.</span><span class="sxs-lookup"><span data-stu-id="d7707-396">This can produce a covered query without specifying the clustered index columns in the definition of the nonclustered index.</span></span> <span data-ttu-id="d7707-397">Por ejemplo, si una tabla tiene un índice clúster en la columna `C`, un índice no clúster en las columnas `B` y `A` tendrá como columnas de valores de clave las columnas `B`, `A`y `C`.</span><span class="sxs-lookup"><span data-stu-id="d7707-397">For example, if a table has a clustered index on column `C`, a nonclustered index on columns `B` and `A` will have as its key values columns `B`, `A`, and `C`.</span></span>  
  
-   <span data-ttu-id="d7707-398">Gran número de valores distintos, como combinaciones de nombres y apellidos, si se utiliza un índice clúster para otras columnas.</span><span class="sxs-lookup"><span data-stu-id="d7707-398">Lots of distinct values, such as a combination of last name and first name, if a clustered index is used for other columns.</span></span>  
  
     <span data-ttu-id="d7707-399">Si hay muy pocos valores distintos, como solo 1 y 0, la mayoría de las consultas no utilizarán el índice, ya que una exploración de la tabla suele ser más eficaz.</span><span class="sxs-lookup"><span data-stu-id="d7707-399">If there are very few distinct values, such as only 1 and 0, most queries will not use the index because a table scan is generally more efficient.</span></span> <span data-ttu-id="d7707-400">Para este tipo de datos, considere la creación de un índice filtrado en un valor distintivo que solo se da en un número pequeño de filas.</span><span class="sxs-lookup"><span data-stu-id="d7707-400">For this type of data, consider creating a filtered index on a distinct value that only occurs in a small number of rows.</span></span> <span data-ttu-id="d7707-401">Por ejemplo, si la mayoría de los valores es 0, el optimizador de consultas puede utilizar un índice filtrado para las filas de datos que contienen 1.</span><span class="sxs-lookup"><span data-stu-id="d7707-401">For example, if most of the values are 0, the query optimizer might use a filtered index for the data rows that contain 1.</span></span>  
  
####  <a name="use-included-columns-to-extend-nonclustered-indexes"></a><a name="Included_Columns"></a> <span data-ttu-id="d7707-402">Usar columnas incluidas para ampliar índices no clúster</span><span class="sxs-lookup"><span data-stu-id="d7707-402">Use Included Columns to Extend Nonclustered Indexes</span></span>  

 <span data-ttu-id="d7707-403">Puede ampliar la funcionalidad de índices no clúster agregando columnas sin clave en el nivel hoja del índice no clúster.</span><span class="sxs-lookup"><span data-stu-id="d7707-403">You can extend the functionality of nonclustered indexes by adding nonkey columns to the leaf level of the nonclustered index.</span></span> <span data-ttu-id="d7707-404">Al incluir columnas sin clave, puede crear índices no clúster que abarcan más consultas.</span><span class="sxs-lookup"><span data-stu-id="d7707-404">By including nonkey columns, you can create nonclustered indexes that cover more queries.</span></span> <span data-ttu-id="d7707-405">Esto se debe a que las columnas sin clave tienen las siguientes ventajas:</span><span class="sxs-lookup"><span data-stu-id="d7707-405">This is because the nonkey columns have the following benefits:</span></span>  
  
-   <span data-ttu-id="d7707-406">Pueden ser tipos de datos que no están permitidos como columnas de clave de índice.</span><span class="sxs-lookup"><span data-stu-id="d7707-406">They can be data types not allowed as index key columns.</span></span>  
  
-   <span data-ttu-id="d7707-407">El [!INCLUDE[ssDE](../includes/ssde-md.md)] no las tiene en cuenta cuando calcula el número de columnas de clave de índice o el tamaño de las claves de índice.</span><span class="sxs-lookup"><span data-stu-id="d7707-407">They are not considered by the [!INCLUDE[ssDE](../includes/ssde-md.md)] when calculating the number of index key columns or index key size.</span></span>  
  
 <span data-ttu-id="d7707-408">Un índice con columnas sin clave incluidas puede mejorar significativamente el rendimiento de una consulta cuando todas las columnas de la consulta se incluyen como columnas de clave o columnas sin clave.</span><span class="sxs-lookup"><span data-stu-id="d7707-408">An index with included nonkey columns can significantly improve query performance when all columns in the query are included in the index either as key or nonkey columns.</span></span> <span data-ttu-id="d7707-409">Las mejoras en el rendimiento se consiguen porque el optimizador de consultas puede localizar todos los valores de las columnas del índice, sin tener acceso a los datos de la tabla o del índice clúster, lo que da como resultado menos operaciones de E/S de disco.</span><span class="sxs-lookup"><span data-stu-id="d7707-409">Performance gains are achieved because the query optimizer can locate all the column values within the index; table or clustered index data is not accessed resulting in fewer disk I/O operations.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="d7707-410">Cuando un índice contiene todas las columnas a las que hace referencia la consulta, normalmente se dice que abarca la consulta.</span><span class="sxs-lookup"><span data-stu-id="d7707-410">When an index contains all the columns referenced by the query it is typically referred to as covering the query.</span></span>  
  
 <span data-ttu-id="d7707-411">Las columnas de clave se almacenan en todos los niveles del índice, mientras que las columnas sin clave solo se almacenan en el nivel hoja.</span><span class="sxs-lookup"><span data-stu-id="d7707-411">While key columns are stored at all levels of the index, nonkey columns are stored only at the leaf level.</span></span>  
  
##### <a name="using-included-columns-to-avoid-size-limits"></a><span data-ttu-id="d7707-412">Usar columnas incluidas para evitar límites de tamaño</span><span class="sxs-lookup"><span data-stu-id="d7707-412">Using Included Columns to Avoid Size Limits</span></span>  

 <span data-ttu-id="d7707-413">Puede incluir columnas sin clave en un índice no clúster para evitar que supere las limitaciones actuales de tamaño del índice de un máximo de 16 columnas de clave y un tamaño máximo de las claves de índice de 900 bytes.</span><span class="sxs-lookup"><span data-stu-id="d7707-413">You can include nonkey columns in a nonclustered index to avoid exceeding the current index size limitations of a maximum of 16 key columns and a maximum index key size of 900 bytes.</span></span> <span data-ttu-id="d7707-414">El [!INCLUDE[ssDE](../includes/ssde-md.md)] no tiene en cuenta las columnas sin clave al calcular el número de columnas de clave de índice o el tamaño de las claves de índice.</span><span class="sxs-lookup"><span data-stu-id="d7707-414">The [!INCLUDE[ssDE](../includes/ssde-md.md)] does not consider nonkey columns when calculating the number of index key columns or index key size.</span></span>  
  
 <span data-ttu-id="d7707-415">Por ejemplo, suponga que desea indizar las siguientes columnas de la tabla `Document` :</span><span class="sxs-lookup"><span data-stu-id="d7707-415">For example, assume that you want to index the following columns in the `Document` table:</span></span>  
  
 `Title nvarchar(50)`  
  
 `Revision nchar(5)`  
  
 `FileName nvarchar(400)`  
  
 <span data-ttu-id="d7707-416">Puesto que los tipos de datos `nchar` y `nvarchar` necesitan 2 bytes para cada carácter, un índice que contenga estas tres columnas superaría la limitación de tamaño de 900 bytes en 10 bytes (455 \* 2).</span><span class="sxs-lookup"><span data-stu-id="d7707-416">Because the `nchar` and `nvarchar` data types require 2 bytes for each character, an index that contains these three columns would exceed the 900 byte size limitation by 10 bytes (455 \* 2).</span></span> <span data-ttu-id="d7707-417">Al utilizar la cláusula `INCLUDE` de la instrucción `CREATE INDEX` , la clave de índice se puede definir como (`Title, Revision`) y `FileName` como columna sin clave.</span><span class="sxs-lookup"><span data-stu-id="d7707-417">By using the `INCLUDE` clause of the `CREATE INDEX` statement, the index key could be defined as (`Title, Revision`) and `FileName` defined as a nonkey column.</span></span> <span data-ttu-id="d7707-418">De esta forma, el tamaño de las claves de índice sería de 110 bytes (55 \* 2) y el índice seguiría conteniendo todas las columnas necesarias.</span><span class="sxs-lookup"><span data-stu-id="d7707-418">In this way, the index key size would be 110 bytes (55 \* 2), and the index would still contain all the required columns.</span></span> <span data-ttu-id="d7707-419">La siguiente instrucción crea ese índice.</span><span class="sxs-lookup"><span data-stu-id="d7707-419">The following statement creates such an index.</span></span>  
  
```sql
CREATE INDEX IX_Document_Title   
ON Production.Document (Title, Revision)   
INCLUDE (FileName);   
```  
  
##### <a name="index-with-included-columns-guidelines"></a><span data-ttu-id="d7707-420">Directrices del índice con columnas incluidas</span><span class="sxs-lookup"><span data-stu-id="d7707-420">Index with Included Columns Guidelines</span></span>  

 <span data-ttu-id="d7707-421">Cuando diseñe índices no clúster con columnas incluidas tenga en cuenta las siguientes directrices:</span><span class="sxs-lookup"><span data-stu-id="d7707-421">When you design nonclustered indexes with included columns consider the following guidelines:</span></span>  
  
-   <span data-ttu-id="d7707-422">Las columnas sin clave se definen en la cláusula INCLUDE de la instrucción CREATE INDEX.</span><span class="sxs-lookup"><span data-stu-id="d7707-422">Nonkey columns are defined in the INCLUDE clause of the CREATE INDEX statement.</span></span>  
  
-   <span data-ttu-id="d7707-423">Las columnas sin clave solo se pueden definir en índices no clúster en tablas o vistas indizadas.</span><span class="sxs-lookup"><span data-stu-id="d7707-423">Nonkey columns can only be defined on nonclustered indexes on tables or indexed views.</span></span>  
  
-   <span data-ttu-id="d7707-424">Se admiten todos los tipos de datos, a excepción de `text`, `ntext` e `image`.</span><span class="sxs-lookup"><span data-stu-id="d7707-424">All data types are allowed except `text`, `ntext`, and `image`.</span></span>  
  
-   <span data-ttu-id="d7707-425">Las columnas calculadas que son deterministas, y precisas o imprecisas, pueden ser columnas incluidas.</span><span class="sxs-lookup"><span data-stu-id="d7707-425">Computed columns that are deterministic and either precise or imprecise can be included columns.</span></span> <span data-ttu-id="d7707-426">Para obtener más información, vea [Indexes on Computed Columns](../relational-databases/indexes/indexes-on-computed-columns.md).</span><span class="sxs-lookup"><span data-stu-id="d7707-426">For more information, see [Indexes on Computed Columns](../relational-databases/indexes/indexes-on-computed-columns.md).</span></span>  
  
-   <span data-ttu-id="d7707-427">Al igual que con las columnas de clave, las columnas calculadas derivadas de los tipos de datos `image`, `ntext` y `text` pueden ser columnas sin clave (incluidas) siempre que se permita el tipo de datos de la columna calculada como columna de índice sin clave.</span><span class="sxs-lookup"><span data-stu-id="d7707-427">As with key columns, computed columns derived from `image`, `ntext`, and `text` data types can be nonkey (included) columns as long as the computed column data type is allowed as a nonkey index column.</span></span>  
  
-   <span data-ttu-id="d7707-428">Los nombres de columna no se pueden especificar en la lista INCLUDE y en la lista de columnas de clave.</span><span class="sxs-lookup"><span data-stu-id="d7707-428">Column names cannot be specified in both the INCLUDE list and in the key column list.</span></span>  
  
-   <span data-ttu-id="d7707-429">Los nombres de columna no se pueden repetir en la lista INCLUDE.</span><span class="sxs-lookup"><span data-stu-id="d7707-429">Column names cannot be repeated in the INCLUDE list.</span></span>  
  
##### <a name="column-size-guidelines"></a><span data-ttu-id="d7707-430">Directrices del tamaño de columnas</span><span class="sxs-lookup"><span data-stu-id="d7707-430">Column Size Guidelines</span></span>  
  
-   <span data-ttu-id="d7707-431">Es necesario definir como mínimo una columna de clave.</span><span class="sxs-lookup"><span data-stu-id="d7707-431">At least one key column must be defined.</span></span> <span data-ttu-id="d7707-432">El número máximo de columnas sin clave es de 1023 columnas.</span><span class="sxs-lookup"><span data-stu-id="d7707-432">The maximum number of nonkey columns is 1023 columns.</span></span> <span data-ttu-id="d7707-433">Éste es el número máximo de columnas de la tabla menos 1.</span><span class="sxs-lookup"><span data-stu-id="d7707-433">This is the maximum number of table columns minus 1.</span></span>  
  
-   <span data-ttu-id="d7707-434">Las columnas de clave de índice, excluyendo las sin clave, deben seguir las restricciones de tamaño de índice existentes de 16 columnas de clave como máximo y un tamaño de las claves de índice total de 900 bytes.</span><span class="sxs-lookup"><span data-stu-id="d7707-434">Index key columns, excluding nonkeys, must follow the existing index size restrictions of 16 key columns maximum, and a total index key size of 900 bytes.</span></span>  
  
-   <span data-ttu-id="d7707-435">El tamaño total de todas las columnas sin clave solo está limitado por el tamaño de las columnas especificadas en la cláusula INCLUDE; por ejemplo, las columnas `varchar(max)` están limitadas a 2 GB.</span><span class="sxs-lookup"><span data-stu-id="d7707-435">The total size of all nonkey columns is limited only by the size of the columns specified in the INCLUDE clause; for example, `varchar(max)` columns are limited to 2 GB.</span></span>  
  
##### <a name="column-modification-guidelines"></a><span data-ttu-id="d7707-436">Directrices para modificar columnas</span><span class="sxs-lookup"><span data-stu-id="d7707-436">Column Modification Guidelines</span></span>  

 <span data-ttu-id="d7707-437">Cuando se modifica una columna de tabla que se ha definido como una columna incluida, se aplican las siguientes restricciones:</span><span class="sxs-lookup"><span data-stu-id="d7707-437">When you modify a table column that has been defined as an included column, the following restrictions apply:</span></span>  
  
-   <span data-ttu-id="d7707-438">Las columnas sin clave no se pueden quitar de la tabla, a menos que antes se quite el índice.</span><span class="sxs-lookup"><span data-stu-id="d7707-438">Nonkey columns cannot be dropped from the table unless the index is dropped first.</span></span>  
  
-   <span data-ttu-id="d7707-439">Las columnas sin clave no se pueden cambiar, excepto para hacer lo siguiente:</span><span class="sxs-lookup"><span data-stu-id="d7707-439">Nonkey columns cannot be changed, except to do the following:</span></span>  
  
    -   <span data-ttu-id="d7707-440">Cambiar la nulabilidad de NOT NULL a NULL.</span><span class="sxs-lookup"><span data-stu-id="d7707-440">Change the nullability of the column from NOT NULL to NULL.</span></span>  
  
    -   <span data-ttu-id="d7707-441">Aumentar la longitud de las columnas `varchar`, `nvarchar` o `varbinary`.</span><span class="sxs-lookup"><span data-stu-id="d7707-441">Increase the length of `varchar`, `nvarchar`, or `varbinary` columns.</span></span>  
  
        > [!NOTE]  
        >  <span data-ttu-id="d7707-442">También se aplican restricciones de modificación a las columnas de clave de índice.</span><span class="sxs-lookup"><span data-stu-id="d7707-442">These column modification restrictions also apply to index key columns.</span></span>  
  
##### <a name="design-recommendations"></a><span data-ttu-id="d7707-443">Recomendaciones de diseño</span><span class="sxs-lookup"><span data-stu-id="d7707-443">Design Recommendations</span></span>  

 <span data-ttu-id="d7707-444">Rediseñe índices no clúster con un tamaño de las claves de índice grande para que solo las columnas utilizadas para búsquedas sean columnas de clave.</span><span class="sxs-lookup"><span data-stu-id="d7707-444">Redesign nonclustered indexes with a large index key size so that only columns used for searching and lookups are key columns.</span></span> <span data-ttu-id="d7707-445">Haga que todas las demás columnas que abarcan la consulta sean columnas sin clave incluidas.</span><span class="sxs-lookup"><span data-stu-id="d7707-445">Make all other columns that cover the query included nonkey columns.</span></span> <span data-ttu-id="d7707-446">De esta forma, tendrá todas las columnas necesarias para abarcar la consulta pero la clave de índice en sí será pequeña y eficaz.</span><span class="sxs-lookup"><span data-stu-id="d7707-446">In this way, you will have all columns needed to cover the query, but the index key itself is small and efficient.</span></span>  
  
 <span data-ttu-id="d7707-447">Por ejemplo, suponga que desea diseñar un índice para abarcar la siguiente consulta.</span><span class="sxs-lookup"><span data-stu-id="d7707-447">For example, assume that you want to design an index to cover the following query.</span></span>  
  
```sql
SELECT AddressLine1, AddressLine2, City, StateProvinceID, PostalCode  
FROM Person.Address  
WHERE PostalCode BETWEEN N'98000' and N'99999';  
```  
  
 <span data-ttu-id="d7707-448">Para abarcar la consulta, cada columna debe definirse en el índice.</span><span class="sxs-lookup"><span data-stu-id="d7707-448">To cover the query, each column must be defined in the index.</span></span> <span data-ttu-id="d7707-449">Aunque puede definir todas las columnas como columnas de clave, el tamaño de clave debe ser de 334 bytes.</span><span class="sxs-lookup"><span data-stu-id="d7707-449">Although you could define all columns as key columns, the key size would be 334 bytes.</span></span> <span data-ttu-id="d7707-450">Como la única columna que se usa de verdad como criterio de búsqueda es la columna `PostalCode` , que tiene una longitud de 30 bytes, un mejor diseño del índice definiría `PostalCode` como columna de clave e incluiría todas las demás columnas como columnas sin clave.</span><span class="sxs-lookup"><span data-stu-id="d7707-450">Because the only column actually used as search criteria is the `PostalCode` column, having a length of 30 bytes, a better index design would define `PostalCode` as the key column and include all other columns as nonkey columns.</span></span>  
  
 <span data-ttu-id="d7707-451">La siguiente instrucción crea un índice con columnas incluidas para abarcar la consulta.</span><span class="sxs-lookup"><span data-stu-id="d7707-451">The following statement creates an index with included columns to cover the query.</span></span>  
  
```sql
CREATE INDEX IX_Address_PostalCode  
ON Person.Address (PostalCode)  
INCLUDE (AddressLine1, AddressLine2, City, StateProvinceID);  
```  
  
##### <a name="performance-considerations"></a><span data-ttu-id="d7707-452">Consideraciones de rendimiento</span><span class="sxs-lookup"><span data-stu-id="d7707-452">Performance Considerations</span></span>  

 <span data-ttu-id="d7707-453">Evite agregar columnas que no sean necesarias.</span><span class="sxs-lookup"><span data-stu-id="d7707-453">Avoid adding unnecessary columns.</span></span> <span data-ttu-id="d7707-454">El hecho de agregar demasiadas columnas de índice, con o sin clave, puede tener las siguientes consecuencias en el rendimiento:</span><span class="sxs-lookup"><span data-stu-id="d7707-454">Adding too many index columns, key or nonkey, can have the following performance implications:</span></span>  
  
-   <span data-ttu-id="d7707-455">Cabrán menos filas de índice en una página.</span><span class="sxs-lookup"><span data-stu-id="d7707-455">Fewer index rows will fit on a page.</span></span> <span data-ttu-id="d7707-456">Esto puede crear incrementos de E/S y una reducción de la eficacia de la caché.</span><span class="sxs-lookup"><span data-stu-id="d7707-456">This could create I/O increases and reduced cache efficiency.</span></span>  
  
-   <span data-ttu-id="d7707-457">Se necesitará más espacio en disco para almacenar el índice.</span><span class="sxs-lookup"><span data-stu-id="d7707-457">More disk space will be required to store the index.</span></span> <span data-ttu-id="d7707-458">En concreto, al agregar los tipos de datos `varchar(max)`, `nvarchar(max)`, `varbinary(max)` o `xml` como columnas de índice sin clave, se pueden aumentar significativamente los requisitos de espacio en disco.</span><span class="sxs-lookup"><span data-stu-id="d7707-458">In particular, adding `varchar(max)`, `nvarchar(max)`, `varbinary(max)`, or `xml` data types as nonkey index columns may significantly increase disk space requirements.</span></span> <span data-ttu-id="d7707-459">Esto se debe a que los valores de columnas se copian en el nivel hoja del índice.</span><span class="sxs-lookup"><span data-stu-id="d7707-459">This is because the column values are copied into the index leaf level.</span></span> <span data-ttu-id="d7707-460">Por lo tanto, residen en el índice y en la tabla base.</span><span class="sxs-lookup"><span data-stu-id="d7707-460">Therefore, they reside in both the index and the base table.</span></span>  
  
-   <span data-ttu-id="d7707-461">Puede que el mantenimiento del índice haga aumentar el tiempo necesario para realizar operaciones de modificación, inserción, actualización o eliminación en la tabla subyacente o la vista indizada.</span><span class="sxs-lookup"><span data-stu-id="d7707-461">Index maintenance may increase the time that it takes to perform modifications, inserts, updates, or deletes, to the underlying table or indexed view.</span></span>  
  
 <span data-ttu-id="d7707-462">Debe determinar si la mejora del rendimiento de las consultas compensa el efecto en el rendimiento durante la modificación de datos y en los requisitos de espacio en disco adicionales.</span><span class="sxs-lookup"><span data-stu-id="d7707-462">You will have to determine whether the gains in query performance outweigh the affect to performance during data modification and in additional disk space requirements.</span></span>  
  
 <span data-ttu-id="d7707-463">![Icono de flecha usado con el vínculo volver al principio](media/uparrow16x16.gif "Icono de flecha usado con el vínculo Volver al principio") [de esta guía](#Top)</span><span class="sxs-lookup"><span data-stu-id="d7707-463">![Arrow icon used with Back to Top link](media/uparrow16x16.gif "Arrow icon used with Back to Top link") [In This Guide](#Top)</span></span>  
  
##  <a name="unique-index-design-guidelines"></a><a name="Unique"></a> <span data-ttu-id="d7707-464">Directrices para diseñar índices únicos</span><span class="sxs-lookup"><span data-stu-id="d7707-464">Unique Index Design Guidelines</span></span>  

 <span data-ttu-id="d7707-465">Un índice único garantiza que la clave de índice no contiene valores duplicados y, por tanto, cada fila de la tabla es en cierta forma única.</span><span class="sxs-lookup"><span data-stu-id="d7707-465">A unique index guarantees that the index key contains no duplicate values and therefore every row in the table is in some way unique.</span></span> <span data-ttu-id="d7707-466">Resulta conveniente especificar un índice único solo si los propios datos se caracterizan por ser únicos.</span><span class="sxs-lookup"><span data-stu-id="d7707-466">Specifying a unique index makes sense only when uniqueness is a characteristic of the data itself.</span></span> <span data-ttu-id="d7707-467">Por ejemplo, para asegurarse de que los valores de la columna `NationalIDNumber` de la tabla `HumanResources.Employee` son únicos, cuando la clave principal es `EmployeeID`, cree una restricción UNIQUE en la columna `NationalIDNumber` .</span><span class="sxs-lookup"><span data-stu-id="d7707-467">For example, if you want to make sure that the values in the `NationalIDNumber` column in the `HumanResources.Employee` table are unique, when the primary key is `EmployeeID`, create a UNIQUE constraint on the `NationalIDNumber` column.</span></span> <span data-ttu-id="d7707-468">Si el usuario intenta especificar el mismo valor en esa columna para más de un empleado, se mostrará un mensaje de error que impedirá la entrada del valor duplicado.</span><span class="sxs-lookup"><span data-stu-id="d7707-468">If the user tries to enter the same value in that column for more than one employee, an error message is displayed and the duplicate value is not entered.</span></span>  
  
 <span data-ttu-id="d7707-469">En el caso de índices únicos para varias columnas, el índice asegura que cada combinación de valores de la clave de índice sea única.</span><span class="sxs-lookup"><span data-stu-id="d7707-469">With multicolumn unique indexes, the index guarantees that each combination of values in the index key is unique.</span></span> <span data-ttu-id="d7707-470">Por ejemplo, si se crea un índice único en una combinación de columnas `LastName`, `FirstName`y `MiddleName` , dos filas de la tabla no podrán tener la misma combinación de valores para estas columnas.</span><span class="sxs-lookup"><span data-stu-id="d7707-470">For example, if a unique index is created on a combination of `LastName`, `FirstName`, and `MiddleName` columns, no two rows in the table could have the same combination of values for these columns.</span></span>  
  
 <span data-ttu-id="d7707-471">Tanto los índices clúster como los no clúster pueden ser únicos.</span><span class="sxs-lookup"><span data-stu-id="d7707-471">Both clustered and nonclustered indexes can be unique.</span></span> <span data-ttu-id="d7707-472">Siempre que los datos de la columna sean únicos, puede crear para la misma tabla un índice clúster único y varios índices clúster no únicos.</span><span class="sxs-lookup"><span data-stu-id="d7707-472">Provided that the data in the column is unique, you can create both a unique clustered index and multiple unique nonclustered indexes on the same table.</span></span>  
  
 <span data-ttu-id="d7707-473">Entre las ventajas de utilizar índices únicos se incluyen:</span><span class="sxs-lookup"><span data-stu-id="d7707-473">The benefits of unique indexes include the following:</span></span>  
  
-   <span data-ttu-id="d7707-474">Se garantiza la integridad de los datos de las columnas definidas.</span><span class="sxs-lookup"><span data-stu-id="d7707-474">Data integrity of the defined columns is ensured.</span></span>  
  
-   <span data-ttu-id="d7707-475">Se proporciona información adicional útil para el optimizador de consultas.</span><span class="sxs-lookup"><span data-stu-id="d7707-475">Additional information helpful to the query optimizer is provided.</span></span>  
  
 <span data-ttu-id="d7707-476">Si se crea una restricción PRIMARY KEY o UNIQUE, se creará automáticamente un índice único en las columnas especificadas.</span><span class="sxs-lookup"><span data-stu-id="d7707-476">Creating a PRIMARY KEY or UNIQUE constraint automatically creates a unique index on the specified columns.</span></span> <span data-ttu-id="d7707-477">No existen diferencias significativas entre la creación de una restricción UNIQUE y la creación de un índice único independiente de una restricción.</span><span class="sxs-lookup"><span data-stu-id="d7707-477">There are no significant differences between creating a UNIQUE constraint and creating a unique index independent of a constraint.</span></span> <span data-ttu-id="d7707-478">La validación de los datos tiene lugar de la misma manera y el optimizador de consultas no establece diferencias entre un índice único creado por una restricción y uno creado manualmente.</span><span class="sxs-lookup"><span data-stu-id="d7707-478">Data validation occurs in the same manner and the query optimizer does not differentiate between a unique index created by a constraint or manually created.</span></span> <span data-ttu-id="d7707-479">Sin embargo, deberá crear una restricción UNIQUE o PRIMARY KEY en la columna cuando el objetivo sea la integridad de los datos.</span><span class="sxs-lookup"><span data-stu-id="d7707-479">However, you should create a UNIQUE or PRIMARY KEY constraint on the column when data integrity is the objective.</span></span> <span data-ttu-id="d7707-480">Al hacer esto, el objetivo del índice quedará claro.</span><span class="sxs-lookup"><span data-stu-id="d7707-480">By doing this the objective of the index will be clear.</span></span>  
  
### <a name="considerations"></a><span data-ttu-id="d7707-481">Consideraciones</span><span class="sxs-lookup"><span data-stu-id="d7707-481">Considerations</span></span>  
  
-   <span data-ttu-id="d7707-482">Un índice único, una restricción UNIQUE o una restricción PRIMARY KEY no se pueden crear si existen valores de clave duplicados en los datos.</span><span class="sxs-lookup"><span data-stu-id="d7707-482">A unique index, UNIQUE constraint, or PRIMARY KEY constraint cannot be created if duplicate key values exist in the data.</span></span>  
  
-   <span data-ttu-id="d7707-483">Si los datos son únicos y desea hacer cumplir la exclusividad, la creación de un índice único en lugar de un índice no único en la misma combinación de columnas proporciona información adicional para el optimizador de consultas que puede dar como resultado unos planes de ejecución más eficaces.</span><span class="sxs-lookup"><span data-stu-id="d7707-483">If the data is unique and you want uniqueness enforced, creating a unique index instead of a nonunique index on the same combination of columns provides additional information for the query optimizer that can produce more efficient execution plans.</span></span> <span data-ttu-id="d7707-484">En este caso se recomienda crear un índice único (preferiblemente mediante una restricción UNIQUE).</span><span class="sxs-lookup"><span data-stu-id="d7707-484">Creating a unique index (preferably by creating a UNIQUE constraint) is recommended in this case.</span></span>  
  
-   <span data-ttu-id="d7707-485">Un índice no clúster único puede incluir columnas sin clave.</span><span class="sxs-lookup"><span data-stu-id="d7707-485">A unique nonclustered index can contain included nonkey columns.</span></span> <span data-ttu-id="d7707-486">Para obtener más información, vea [Índice con columnas incluidas](#Included_Columns).</span><span class="sxs-lookup"><span data-stu-id="d7707-486">For more information, see [Index with Included Columns](#Included_Columns).</span></span>  
  
 <span data-ttu-id="d7707-487">![Icono de flecha usado con el vínculo volver al principio](media/uparrow16x16.gif "Icono de flecha usado con el vínculo Volver al principio") [de esta guía](#Top)</span><span class="sxs-lookup"><span data-stu-id="d7707-487">![Arrow icon used with Back to Top link](media/uparrow16x16.gif "Arrow icon used with Back to Top link") [In This Guide](#Top)</span></span>  
  
##  <a name="filtered-index-design-guidelines"></a><a name="Filtered"></a> <span data-ttu-id="d7707-488">Directrices generales para diseñar índices filtrados</span><span class="sxs-lookup"><span data-stu-id="d7707-488">Filtered Index Design Guidelines</span></span>  

 <span data-ttu-id="d7707-489">Un índice filtrado es un índice no clúster optimizado, especialmente indicado para atender consultas que realizan selecciones a partir un subconjunto bien definido de datos.</span><span class="sxs-lookup"><span data-stu-id="d7707-489">A filtered index is an optimized nonclustered index, especially suited to cover queries that select from a well-defined subset of data.</span></span> <span data-ttu-id="d7707-490">Utiliza un predicado de filtro para indizar una parte de las filas de la tabla.</span><span class="sxs-lookup"><span data-stu-id="d7707-490">It uses a filter predicate to index a portion of rows in the table.</span></span> <span data-ttu-id="d7707-491">Un índice filtrado bien diseñado puede mejorar el rendimiento de las consultas y reducir los costos de almacenamiento del índice en relación con los índices de tabla completa, así como los costos de mantenimiento.</span><span class="sxs-lookup"><span data-stu-id="d7707-491">A well-designed filtered index can improve query performance, reduce index maintenance costs, and reduce index storage costs compared with full-table indexes.</span></span>  
  
||  
|-|  
|<span data-ttu-id="d7707-492">**Se aplica a**: desde [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] hasta [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].</span><span class="sxs-lookup"><span data-stu-id="d7707-492">**Applies to**: [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] through [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].</span></span>|  
  
 <span data-ttu-id="d7707-493">Los índices filtrados pueden proporcionar las siguientes ventajas respecto a los índices de tabla completa:</span><span class="sxs-lookup"><span data-stu-id="d7707-493">Filtered indexes can provide the following advantages over full-table indexes:</span></span>  
  
-   <span data-ttu-id="d7707-494">**Mejor rendimiento de las consultas y mayor calidad del plan**</span><span class="sxs-lookup"><span data-stu-id="d7707-494">**Improved query performance and plan quality**</span></span>  
  
     <span data-ttu-id="d7707-495">Un índice filtrado bien diseñado mejora el rendimiento de las consultas y la calidad del plan de ejecución porque es menor que un índice no clúster de tabla completa y tiene estadísticas filtradas.</span><span class="sxs-lookup"><span data-stu-id="d7707-495">A well-designed filtered index improves query performance and execution plan quality because it is smaller than a full-table nonclustered index and has filtered statistics.</span></span> <span data-ttu-id="d7707-496">Las estadísticas filtradas son más precisas que las de tabla completa porque corresponden solamente a las filas del índice filtrado.</span><span class="sxs-lookup"><span data-stu-id="d7707-496">The filtered statistics are more accurate than full-table statistics because they cover only the rows in the filtered index.</span></span>  
  
-   <span data-ttu-id="d7707-497">**Menor costo de mantenimiento de índices**</span><span class="sxs-lookup"><span data-stu-id="d7707-497">**Reduced index maintenance costs**</span></span>  
  
     <span data-ttu-id="d7707-498">El mantenimiento de un índice se realiza únicamente cuando las instrucciones de lenguaje de manipulación de datos (DML) afectan a los datos en el índice.</span><span class="sxs-lookup"><span data-stu-id="d7707-498">An index is maintained only when data manipulation language (DML) statements affect the data in the index.</span></span> <span data-ttu-id="d7707-499">Un índice filtrado reduce los costos de mantenimiento del índice en comparación con un índice no clúster de tabla completa, ya que es menor y el mantenimiento se realiza únicamente cuando se ven afectados los datos del índice.</span><span class="sxs-lookup"><span data-stu-id="d7707-499">A filtered index reduces index maintenance costs compared with a full-table nonclustered index because it is smaller and is only maintained when the data in the index is affected.</span></span> <span data-ttu-id="d7707-500">Se puede disponer de una gran cantidad de índices filtrados, sobre todo cuando contienen datos que raramente se ven afectados.</span><span class="sxs-lookup"><span data-stu-id="d7707-500">It is possible to have a large number of filtered indexes, especially when they contain data that is affected infrequently.</span></span> <span data-ttu-id="d7707-501">De igual forma, si un índice filtrado contiene únicamente datos que se ven afectados a menudo, el tamaño menor del índice reduce el costo de actualización de las estadísticas.</span><span class="sxs-lookup"><span data-stu-id="d7707-501">Similarly, if a filtered index contains only the frequently affected data, the smaller size of the index reduces the cost of updating the statistics.</span></span>  
  
-   <span data-ttu-id="d7707-502">**Costos reducidos de almacenamiento de índices**</span><span class="sxs-lookup"><span data-stu-id="d7707-502">**Reduced index storage costs**</span></span>  
  
     <span data-ttu-id="d7707-503">La creación de un índice filtrado puede reducir la cantidad de almacenamiento en disco de índices no clúster, cuando no sea necesario un índice de tabla completa.</span><span class="sxs-lookup"><span data-stu-id="d7707-503">Creating a filtered index can reduce disk storage for nonclustered indexes when a full-table index is not necessary.</span></span> <span data-ttu-id="d7707-504">Puede reemplazar un índice no clúster de tabla completa con varios índices filtrados sin aumentar de forma considerable los requisitos de almacenamiento.</span><span class="sxs-lookup"><span data-stu-id="d7707-504">You can replace a full-table nonclustered index with multiple filtered indexes without significantly increasing the storage requirements.</span></span>  
  
 <span data-ttu-id="d7707-505">Los índices filtrados son útiles cuando las columnas contienen subconjuntos de datos bien definidos a los que las consultas hacen referencia en instrucciones SELECT.</span><span class="sxs-lookup"><span data-stu-id="d7707-505">Filtered indexes are useful when columns contain well-defined subsets of data that queries reference in SELECT statements.</span></span> <span data-ttu-id="d7707-506">Algunos ejemplos son:</span><span class="sxs-lookup"><span data-stu-id="d7707-506">Examples are:</span></span>  
  
-   <span data-ttu-id="d7707-507">Columnas dispersas que contienen solamente unos pocos valores distintos de NULL.</span><span class="sxs-lookup"><span data-stu-id="d7707-507">Sparse columns that contain only a few non-NULL values.</span></span>  
  
-   <span data-ttu-id="d7707-508">Columnas heterogéneas que contienen categorías de datos.</span><span class="sxs-lookup"><span data-stu-id="d7707-508">Heterogeneous columns that contain categories of data.</span></span>  
  
-   <span data-ttu-id="d7707-509">Columnas que contienen intervalos de valores como cantidad de dinero, hora y fechas.</span><span class="sxs-lookup"><span data-stu-id="d7707-509">Columns that contain ranges of values such as dollar amounts, time, and dates.</span></span>  
  
-   <span data-ttu-id="d7707-510">Particiones de tablas definidas por lógica de comparación simple para los valores de las columnas.</span><span class="sxs-lookup"><span data-stu-id="d7707-510">Table partitions that are defined by simple comparison logic for column values.</span></span>  
  
 <span data-ttu-id="d7707-511">La reducción de los costos de mantenimiento para los índices filtrados es más apreciable cuando el número de filas del índice es pequeño en relación con un índice de tabla completa.</span><span class="sxs-lookup"><span data-stu-id="d7707-511">Reduced maintenance costs for filtered indexes are most noticeable when the number of rows in the index is small compared with a full-table index.</span></span> <span data-ttu-id="d7707-512">Si el índice filtrado incluye la mayoría de las filas en la tabla, puede resultar más costoso mantenerlo que un índice de tabla completa.</span><span class="sxs-lookup"><span data-stu-id="d7707-512">If the filtered index includes most of the rows in the table, it could cost more to maintain than a full-table index.</span></span> <span data-ttu-id="d7707-513">En ese caso, debe utilizar un índice de tabla completa en lugar de un índice filtrado.</span><span class="sxs-lookup"><span data-stu-id="d7707-513">In this case, you should use a full-table index instead of a filtered index.</span></span>  
  
 <span data-ttu-id="d7707-514">Los índices filtrados se definen en una tabla y solamente admiten operadores de comparación simples.</span><span class="sxs-lookup"><span data-stu-id="d7707-514">Filtered indexes are defined on one table and only support simple comparison operators.</span></span> <span data-ttu-id="d7707-515">Cuando necesite una expresión de filtro que haga referencia a varias tablas o que tenga lógica compleja, deberá crear una vista.</span><span class="sxs-lookup"><span data-stu-id="d7707-515">If you need a filter expression that references multiple tables or has complex logic, you should create a view.</span></span>  
  
### <a name="design-considerations"></a><span data-ttu-id="d7707-516">Consideraciones de diseño</span><span class="sxs-lookup"><span data-stu-id="d7707-516">Design Considerations</span></span>  

 <span data-ttu-id="d7707-517">Para diseñar índices filtrados efectivos, es importante entender qué consultas utiliza la aplicación y cómo se relacionan con los subconjuntos de datos.</span><span class="sxs-lookup"><span data-stu-id="d7707-517">In order to design effective filtered indexes, it is important to understand what queries your application uses and how they relate to subsets of your data.</span></span> <span data-ttu-id="d7707-518">Algunos ejemplos de datos que tienen subconjuntos bien definidos son las columnas con una mayoría de valores NULL, las columnas con categorías de valores heterogéneas y las columnas con intervalos de valores diferenciados.</span><span class="sxs-lookup"><span data-stu-id="d7707-518">Some examples of data that have well-defined subsets are columns with mostly NULL values, columns with heterogeneous categories of values and columns with distinct ranges of values.</span></span> <span data-ttu-id="d7707-519">Las siguientes consideraciones del diseño proporcionan una variedad de escenarios en los que un índice filtrado puede ofrecer ventajas sobre los índices de tabla completa.</span><span class="sxs-lookup"><span data-stu-id="d7707-519">The following design considerations give a variety of scenarios for when a filtered index can provide advantages over full-table indexes.</span></span>  
  
#### <a name="filtered-indexes-for-subsets-of-data"></a><span data-ttu-id="d7707-520">Índices filtrados para subconjuntos de datos</span><span class="sxs-lookup"><span data-stu-id="d7707-520">Filtered Indexes for Subsets of Data</span></span>  

 <span data-ttu-id="d7707-521">Cuando una columna solamente tiene un número pequeño de valores pertinentes para las consultas, puede crear un índice filtrado en el subconjunto de valores.</span><span class="sxs-lookup"><span data-stu-id="d7707-521">When a column only has a small number of relevant values for queries, you can create a filtered index on the subset of values.</span></span> <span data-ttu-id="d7707-522">Por ejemplo, cuando los valores en una columna son principalmente NULL y la consulta solamente selecciona entre valores distintos de NULL, puede crear un índice filtrado para las filas de datos distintos de NULL.</span><span class="sxs-lookup"><span data-stu-id="d7707-522">For example, when the values in a column are mostly NULL and the query selects only from the non-NULL values, you can create a filtered index for the non-NULL data rows.</span></span> <span data-ttu-id="d7707-523">El índice resultante será menor y tendrá costos de mantenimiento más reducidos que los de un índice no clúster de tabla completa definido en las mismas columnas de clave.</span><span class="sxs-lookup"><span data-stu-id="d7707-523">The resulting index will be smaller and cost less to maintain than a full-table nonclustered index defined on the same key columns.</span></span>  
  
 <span data-ttu-id="d7707-524">Por ejemplo, la base de datos `AdventureWorks2012` tiene una tabla `Production.BillOfMaterials` con 2679 filas.</span><span class="sxs-lookup"><span data-stu-id="d7707-524">For example, the `AdventureWorks2012` database has a `Production.BillOfMaterials` table with 2679 rows.</span></span> <span data-ttu-id="d7707-525">La columna `EndDate` solo tiene 199 filas que contienen un valor distinto de NULL y las otras 2.480 filas contienen valores NULL.</span><span class="sxs-lookup"><span data-stu-id="d7707-525">The `EndDate` column has only 199 rows that contain a non-NULL value and the other 2480 rows contain NULL.</span></span> <span data-ttu-id="d7707-526">El siguiente índice filtrado atenderá consultas que devuelven las columnas definidas en el índice y que seleccionan únicamente filas con un valor distinto de NULL para `EndDate`.</span><span class="sxs-lookup"><span data-stu-id="d7707-526">The following filtered index would cover queries that return the columns defined in the index and that select only rows with a non-NULL value for `EndDate`.</span></span>  
  
```sql
CREATE NONCLUSTERED INDEX FIBillOfMaterialsWithEndDate  
    ON Production.BillOfMaterials (ComponentID, StartDate)  
    WHERE EndDate IS NOT NULL ;  
GO  
```  
  
 <span data-ttu-id="d7707-527">El índice filtrado `FIBillOfMaterialsWithEndDate` es válido para la consulta siguiente.</span><span class="sxs-lookup"><span data-stu-id="d7707-527">The filtered index `FIBillOfMaterialsWithEndDate` is valid for the following query.</span></span> <span data-ttu-id="d7707-528">Puede mostrar el plan de ejecución de consultas para determinar si el optimizador de consultas ha utilizado el índice filtrado.</span><span class="sxs-lookup"><span data-stu-id="d7707-528">You can display the query execution plan to determine if the query optimizer used the filtered index.</span></span>  
  
```sql
SELECT ProductAssemblyID, ComponentID, StartDate   
FROM Production.BillOfMaterials  
WHERE EndDate IS NOT NULL   
    AND ComponentID = 5   
    AND StartDate > '20080101' ;  
```  
  
 <span data-ttu-id="d7707-529">Para obtener más información sobre cómo crear índices filtrados y cómo definir la expresión de predicado del índice filtrado, vea [Create Filtered Indexes](../relational-databases/indexes/create-filtered-indexes.md).</span><span class="sxs-lookup"><span data-stu-id="d7707-529">For more information about how to create filtered indexes and how to define the filtered index predicate expression, see [Create Filtered Indexes](../relational-databases/indexes/create-filtered-indexes.md).</span></span>  
  
#### <a name="filtered-indexes-for-heterogeneous-data"></a><span data-ttu-id="d7707-530">Índices filtrados para datos heterogéneos</span><span class="sxs-lookup"><span data-stu-id="d7707-530">Filtered Indexes for Heterogeneous Data</span></span>  

 <span data-ttu-id="d7707-531">Cuando una tabla tiene filas de datos heterogéneos, se puede crear un índice filtrado para una o varias categorías de datos.</span><span class="sxs-lookup"><span data-stu-id="d7707-531">When a table has heterogeneous data rows, you can create a filtered index for one or more categories of data.</span></span>  
  
 <span data-ttu-id="d7707-532">Por ejemplo, cada uno de los productos de la tabla `Production.Product` está asignado a un `ProductSubcategoryID`que, a su vez, está asociado a las categorías de producto Bikes, Components, Clothing o Accessories.</span><span class="sxs-lookup"><span data-stu-id="d7707-532">For example, the products listed in the `Production.Product` table are each assigned to a `ProductSubcategoryID`, which are in turn associated with the product categories Bikes, Components, Clothing, or Accessories.</span></span> <span data-ttu-id="d7707-533">Estas categorías son heterogéneas porque sus valores de columna en la tabla `Production.Product` no están suficientemente correlacionados.</span><span class="sxs-lookup"><span data-stu-id="d7707-533">These categories are heterogeneous because their column values in the `Production.Product` table are not closely correlated.</span></span> <span data-ttu-id="d7707-534">Por ejemplo, las columnas `Color`, `ReorderPoint`, `ListPrice`, `Weight`, `Class`y `Style` tienen características únicas para cada categoría de producto.</span><span class="sxs-lookup"><span data-stu-id="d7707-534">For example, the columns `Color`, `ReorderPoint`, `ListPrice`, `Weight`, `Class`, and `Style` have unique characteristics for each product category.</span></span> <span data-ttu-id="d7707-535">Suponga que se realizan consultas frecuentes de accesorios cuyas subcategorías están comprendidas entre 27 y 36 inclusive.</span><span class="sxs-lookup"><span data-stu-id="d7707-535">Suppose that there are frequent queries for accessories which have subcategories between 27 and 36 inclusive.</span></span> <span data-ttu-id="d7707-536">Puede mejorar el rendimiento de las consultas de accesorios si crea un índice filtrado en las subcategorías de accesorios como se muestra en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="d7707-536">You can improve the performance of queries for accessories by creating a filtered index on the accessories subcategories as shown in the following example.</span></span>  
  
```sql
CREATE NONCLUSTERED INDEX FIProductAccessories  
    ON Production.Product (ProductSubcategoryID, ListPrice)   
        Include (Name)  
WHERE ProductSubcategoryID >= 27 AND ProductSubcategoryID <= 36;
```  
  
 <span data-ttu-id="d7707-537">El índice filtrado `FIProductAccessories` abarca la consulta siguiente porque los resultados de las consultas</span><span class="sxs-lookup"><span data-stu-id="d7707-537">The filtered index `FIProductAccessories` covers the following query because the query</span></span>  
  
 <span data-ttu-id="d7707-538">se incluyen en el índice y el plan de consulta no incluye búsquedas en una tabla base.</span><span class="sxs-lookup"><span data-stu-id="d7707-538">results are contained in the index and the query plan does not include a base table lookup.</span></span> <span data-ttu-id="d7707-539">Por ejemplo, la expresión de predicado de la consulta `ProductSubcategoryID = 33` es un subconjunto del predicado del índice filtrado `ProductSubcategoryID >= 27` y `ProductSubcategoryID <= 36`, las columnas `ProductSubcategoryID` y `ListPrice` del predicado de la consulta son ambas columnas de clave del índice, y el nombre se almacena en el nivel hoja del índice como una columna incluida.</span><span class="sxs-lookup"><span data-stu-id="d7707-539">For example, the query predicate expression `ProductSubcategoryID = 33` is a subset of the filtered index predicate `ProductSubcategoryID >= 27` and `ProductSubcategoryID <= 36`, the `ProductSubcategoryID` and `ListPrice` columns in the query predicate are both key columns in the index, and name is stored in the leaf level of the index as an included column.</span></span>  
  
```sql
SELECT Name, ProductSubcategoryID, ListPrice  
FROM Production.Product  
WHERE ProductSubcategoryID = 33 AND ListPrice > 25.00 ;  
```  
  
#### <a name="key-columns"></a><span data-ttu-id="d7707-540">Columnas de clave</span><span class="sxs-lookup"><span data-stu-id="d7707-540">Key Columns</span></span>  

 <span data-ttu-id="d7707-541">Se recomienda insertar un número pequeño de columnas incluidas o de clave en la definición de un índice filtrado e incorporar solamente las columnas necesarias para que el optimizador de consultas elija el índice filtrado para el plan de ejecución de consultas.</span><span class="sxs-lookup"><span data-stu-id="d7707-541">It is a best practice to include a small number of key or included columns in a filtered index definition, and to incorporate only the columns that are necessary for the query optimizer to choose the filtered index for the query execution plan.</span></span> <span data-ttu-id="d7707-542">El optimizador de consultas puede elegir un índice filtrado para la consulta, independientemente de que cubra la consulta o no.</span><span class="sxs-lookup"><span data-stu-id="d7707-542">The query optimizer can choose a filtered index for the query regardless of whether it does or does not cover the query.</span></span> <span data-ttu-id="d7707-543">Sin embargo, es más probable que el optimizador de consultas elija un índice filtrado si cubre la consulta.</span><span class="sxs-lookup"><span data-stu-id="d7707-543">However, the query optimizer is more likely to choose a filtered index if it covers the query.</span></span>  
  
 <span data-ttu-id="d7707-544">En algunos casos, un índice filtrado cubre la consulta sin incluir las columnas en la expresión del índice filtrado como columnas incluidas o de clave en la definición del índice filtrado.</span><span class="sxs-lookup"><span data-stu-id="d7707-544">In some cases, a filtered index covers the query without including the columns in the filtered index expression as key or included columns in the filtered index definition.</span></span> <span data-ttu-id="d7707-545">Las instrucciones siguientes explican los casos en que una columna de la expresión del índice filtrado debe ser una columna incluida o de clave en la definición del índice filtrado.</span><span class="sxs-lookup"><span data-stu-id="d7707-545">The following guidelines explain when a column in the filtered index expression should be a key or included column in the filtered index definition.</span></span> <span data-ttu-id="d7707-546">Los ejemplos hacen referencia al índice filtrado `FIBillOfMaterialsWithEndDate` que se creó previamente.</span><span class="sxs-lookup"><span data-stu-id="d7707-546">The examples refer to the filtered index, `FIBillOfMaterialsWithEndDate` that was created previously.</span></span>  
  
 <span data-ttu-id="d7707-547">Una columna de la expresión del índice filtrado no tiene por qué ser una columna incluida o de clave en la definición del índice filtrado cuando la expresión del índice filtrado es equivalente al predicado de la consulta y la consulta no devuelve la columna de la expresión del índice filtrado con los resultados de la consulta.</span><span class="sxs-lookup"><span data-stu-id="d7707-547">A column in the filtered index expression does not need to be a key or included column in the filtered index definition if the filtered index expression is equivalent to the query predicate and the query does not return the column in the filtered index expression with the query results.</span></span> <span data-ttu-id="d7707-548">Por ejemplo, `FIBillOfMaterialsWithEndDate` cubre la consulta siguiente porque el predicado de consulta es equivalente a la expresión del filtro, y `EndDate` no se devuelve con los resultados de la consulta.</span><span class="sxs-lookup"><span data-stu-id="d7707-548">For example, `FIBillOfMaterialsWithEndDate` covers the following query because the query predicate is equivalent to the filter expression, and `EndDate` is not returned with the query results.</span></span> <span data-ttu-id="d7707-549">`FIBillOfMaterialsWithEndDate` no necesita `EndDate` como una columna incluida o de clave en la definición del índice filtrado.</span><span class="sxs-lookup"><span data-stu-id="d7707-549">`FIBillOfMaterialsWithEndDate` does not need `EndDate` as a key or included column in the filtered index definition.</span></span>  
  
```sql
SELECT ComponentID, StartDate FROM Production.BillOfMaterials  
WHERE EndDate IS NOT NULL;   
```  
  
 <span data-ttu-id="d7707-550">Una columna de la expresión del índice filtrado debe ser una columna incluida o de clave de la definición del índice filtrado cuando el predicado de la consulta usa la columna en una comparación no equivalente a la expresión del índice filtrado.</span><span class="sxs-lookup"><span data-stu-id="d7707-550">A column in the filtered index expression should be a key or included column in the filtered index definition if the query predicate uses the column in a comparison that is not equivalent to the filtered index expression.</span></span> <span data-ttu-id="d7707-551">Por ejemplo, `FIBillOfMaterialsWithEndDate` es válido para la consulta siguiente porque selecciona un subconjunto de filas del índice filtrado.</span><span class="sxs-lookup"><span data-stu-id="d7707-551">For example, `FIBillOfMaterialsWithEndDate` is valid for the following query because it selects a subset of rows from the filtered index.</span></span> <span data-ttu-id="d7707-552">Sin embargo, no cubre la consulta siguiente porque `EndDate` se utiliza en la comparación `EndDate > '20040101'`, que no es equivalente a la expresión del índice filtrado.</span><span class="sxs-lookup"><span data-stu-id="d7707-552">However, it does not cover the following query because `EndDate` is used in the comparison `EndDate > '20040101'`, which is not equivalent to the filtered index expression.</span></span> <span data-ttu-id="d7707-553">El procesador de consultas no puede ejecutar esta consulta si no busca los valores de `EndDate`.</span><span class="sxs-lookup"><span data-stu-id="d7707-553">The query processor cannot execute this query without looking up the values of `EndDate`.</span></span> <span data-ttu-id="d7707-554">Por tanto, `EndDate` debe ser una columna incluida o de clave de la definición del índice filtrado.</span><span class="sxs-lookup"><span data-stu-id="d7707-554">Therefore, `EndDate` should be a key or included column in the filtered index definition.</span></span>  
  
```sql
SELECT ComponentID, StartDate FROM Production.BillOfMaterials  
WHERE EndDate > '20040101';   
```  
  
 <span data-ttu-id="d7707-555">Una columna de la expresión del índice filtrado debe ser una columna incluida o de clave en la definición del índice filtrado si la columna está en el conjunto de resultados de la consulta.</span><span class="sxs-lookup"><span data-stu-id="d7707-555">A column in the filtered index expression should be a key or included column in the filtered index definition if the column is in the query result set.</span></span> <span data-ttu-id="d7707-556">Por ejemplo, `FIBillOfMaterialsWithEndDate` no atiende la consulta siguiente porque devuelve la columna `EndDate` en los resultados de la consulta.</span><span class="sxs-lookup"><span data-stu-id="d7707-556">For example, `FIBillOfMaterialsWithEndDate` does not cover the following query because it returns the `EndDate` column in the query results.</span></span> <span data-ttu-id="d7707-557">Por tanto, `EndDate` debe ser una columna incluida o de clave de la definición del índice filtrado.</span><span class="sxs-lookup"><span data-stu-id="d7707-557">Therefore, `EndDate` should be a key or included column in the filtered index definition.</span></span>  
  
```sql
SELECT ComponentID, StartDate, EndDate FROM Production.BillOfMaterials  
WHERE EndDate IS NOT NULL;  
```  
  
 <span data-ttu-id="d7707-558">La clave de índice clúster de la tabla no tiene por qué ser una columna incluida o de clave de la definición del índice filtrado.</span><span class="sxs-lookup"><span data-stu-id="d7707-558">The clustered index key of the table does not need to be a key or included column in the filtered index definition.</span></span> <span data-ttu-id="d7707-559">La clave de índice cluster se incluye de forma automática en todos los índices no clúster, incluidos los índices filtrados.</span><span class="sxs-lookup"><span data-stu-id="d7707-559">The clustered index key is automatically included in all nonclustered indexes, including filtered indexes.</span></span>  
  
#### <a name="data-conversion-operators-in-the-filter-predicate"></a><span data-ttu-id="d7707-560">Operadores de conversión de datos en el predicado de filtro</span><span class="sxs-lookup"><span data-stu-id="d7707-560">Data Conversion Operators in the Filter Predicate</span></span>  

 <span data-ttu-id="d7707-561">Si el operador de comparación especificado en la expresión del índice filtrado del índice filtrado produce una conversión de datos implícita o explícita, se producirá un error cuando la conversión se realice en el lado izquierdo de un operador de comparación.</span><span class="sxs-lookup"><span data-stu-id="d7707-561">If the comparison operator specified in the filtered index expression of the filtered index results in an implicit or explicit data conversion, an error will occur if the conversion occurs on the left side of a comparison operator.</span></span> <span data-ttu-id="d7707-562">Una posible solución es escribir la expresión del índice filtrado con el operador de conversión de datos (CAST o CONVERT) en el lado derecho del operador de comparación.</span><span class="sxs-lookup"><span data-stu-id="d7707-562">A solution is to write the filtered index expression with the data conversion operator (CAST or CONVERT) on the right side of the comparison operator.</span></span>  
  
 <span data-ttu-id="d7707-563">En el ejemplo siguiente se crea una tabla con varios tipos de datos.</span><span class="sxs-lookup"><span data-stu-id="d7707-563">The following example creates a table with a variety of data types.</span></span>  
  
```sql
USE AdventureWorks2012;  
GO  
CREATE TABLE dbo.TestTable (a int, b varbinary(4));  
```  
  
 <span data-ttu-id="d7707-564">En la siguiente definición del índice filtrado, la columna `b` se convierte implícitamente en un tipo de datos enteros para que se pueda comparar con la constante 1.</span><span class="sxs-lookup"><span data-stu-id="d7707-564">In the following filtered index definition, column `b` is implicitly converted to an integer data type for the purpose of comparing it to the constant 1.</span></span> <span data-ttu-id="d7707-565">Esto genera el mensaje de error 10611 porque la conversión se produce en el lado izquierdo del operador del predicado filtrado.</span><span class="sxs-lookup"><span data-stu-id="d7707-565">This generates error message 10611 because the conversion occurs on the left hand side of the operator in the filtered predicate.</span></span>  
  
```sql
CREATE NONCLUSTERED INDEX TestTabIndex ON dbo.TestTable(a,b)  
WHERE b = 1;  
```  
  
 <span data-ttu-id="d7707-566">La solución consiste en convertir la constante del lado derecho de forma que sea del mismo tipo que la columna `b`, tal como se muestra en el ejemplo siguiente:</span><span class="sxs-lookup"><span data-stu-id="d7707-566">The solution is to convert the constant on the right hand side to be of the same type as column `b`, as seen in the following example:</span></span>  
  
```sql
CREATE INDEX TestTabIndex ON dbo.TestTable(a,b)  
WHERE b = CONVERT(Varbinary(4), 1);  
```  
  
 <span data-ttu-id="d7707-567">Cuando se mueve la conversión de datos del lado izquierdo al lado derecho de un operador de comparación, es posible que cambie el significado de la conversión.</span><span class="sxs-lookup"><span data-stu-id="d7707-567">Moving the data conversion from the left side to the right side of a comparison operator might change the meaning of the conversion.</span></span> <span data-ttu-id="d7707-568">En el ejemplo anterior, cuando se agregó el operador CONVERT en el lado derecho, la comparación cambió de una comparación de enteros a una comparación `varbinary`.</span><span class="sxs-lookup"><span data-stu-id="d7707-568">In the above example, when the CONVERT operator was added to the right side, the comparison changed from an integer comparison to a `varbinary` comparison.</span></span>  
  
 <span data-ttu-id="d7707-569">![Icono de flecha usado con el vínculo volver al principio](media/uparrow16x16.gif "Icono de flecha usado con el vínculo Volver al principio") [de esta guía](#Top)</span><span class="sxs-lookup"><span data-stu-id="d7707-569">![Arrow icon used with Back to Top link](media/uparrow16x16.gif "Arrow icon used with Back to Top link") [In This Guide](#Top)</span></span>  
  
##  <a name="additional-reading"></a><a name="Additional_Reading"></a> <span data-ttu-id="d7707-570">Lecturas adicionales</span><span class="sxs-lookup"><span data-stu-id="d7707-570">Additional Reading</span></span>  

 <span data-ttu-id="d7707-571">[Mejorar el rendimiento con vistas indizadas de SQL Server 2008](https://msdn.microsoft.com/library/dd171921(v=sql.100).aspx)</span><span class="sxs-lookup"><span data-stu-id="d7707-571">[Improving Performance with SQL Server 2008 Indexed Views](https://msdn.microsoft.com/library/dd171921(v=sql.100).aspx)</span></span>  
  
 [<span data-ttu-id="d7707-572">Tablas e índices con particiones</span><span class="sxs-lookup"><span data-stu-id="d7707-572">Partitioned Tables and Indexes</span></span>](../relational-databases/partitions/partitioned-tables-and-indexes.md)  
  
  
