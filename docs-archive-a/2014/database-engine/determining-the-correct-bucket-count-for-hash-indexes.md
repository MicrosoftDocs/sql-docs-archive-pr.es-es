---
title: Determinar el número correcto de depósitos para los índices de hash | Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: in-memory-oltp
ms.topic: conceptual
ms.assetid: 6d1ac280-87db-4bd8-ad43-54353647d8b5
author: stevestein
ms.author: sstein
ms.openlocfilehash: e0579a98e3302b6944f68ca449d3e7cda0ecc01d
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 08/04/2020
ms.locfileid: "87670548"
---
# <a name="determining-the-correct-bucket-count-for-hash-indexes"></a><span data-ttu-id="bf0cd-102">Determinar el número correcto de depósitos para los índices hash</span><span class="sxs-lookup"><span data-stu-id="bf0cd-102">Determining the Correct Bucket Count for Hash Indexes</span></span>
  <span data-ttu-id="bf0cd-103">Debe especificar un valor para el parámetro `BUCKET_COUNT` al crear la tabla optimizada para memoria.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-103">You must specify a value for the `BUCKET_COUNT` parameter when you create the memory-optimized table.</span></span> <span data-ttu-id="bf0cd-104">En este tema se hacen recomendaciones para determinar el valor adecuado para el parámetro `BUCKET_COUNT`.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-104">This topic makes recommendations for determining the appropriate value for the `BUCKET_COUNT` parameter.</span></span> <span data-ttu-id="bf0cd-105">Si no puede determinar el número de cubos correcto, utilice un índice no clúster en su lugar.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-105">If you cannot determine the correct bucket count, use a nonclustered index instead.</span></span>  <span data-ttu-id="bf0cd-106">Un valor incorrecto de `BUCKET_COUNT`, especialmente si es demasiado bajo, puede afectar significativamente el rendimiento de la carga de trabajo, así como afectar el tiempo de recuperación de la base de datos.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-106">An incorrect `BUCKET_COUNT` value, especially one that is too low, can significantly impact workload performance, as well as recovery time of the database.</span></span> <span data-ttu-id="bf0cd-107">Es mejor sobrestimar el número de cubos.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-107">It is better to overestimate the bucket count.</span></span>  
  
 <span data-ttu-id="bf0cd-108">Las claves de índice duplicadas pueden reducir el rendimiento con un índice hash porque a las claves se les aplica el algoritmo hash en el mismo cubo, por lo que la cadena del cubo aumenta.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-108">Duplicate index keys can decrease performance with a hash index because the keys are hashed to the same bucket, causing that bucket's chain to increase.</span></span>  
  
 <span data-ttu-id="bf0cd-109">Para obtener más información sobre índices de hash no clúster, vea [Hash Indexes](hash-indexes.md) y [Guidelines for Using Indexes on Memory-Optimized Tables](../relational-databases/in-memory-oltp/memory-optimized-tables.md).</span><span class="sxs-lookup"><span data-stu-id="bf0cd-109">For more information about nonclustered hash indexes, see [Hash Indexes](hash-indexes.md) and [Guidelines for Using Indexes on Memory-Optimized Tables](../relational-databases/in-memory-oltp/memory-optimized-tables.md).</span></span>  
  
 <span data-ttu-id="bf0cd-110">Se asigna una tabla hash para cada índice de hash de una tabla optimizada para memoria.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-110">One hash table is allocated for each hash index on a memory-optimized table.</span></span> <span data-ttu-id="bf0cd-111">El tamaño de la tabla hash asignada para un índice se especifica mediante el `BUCKET_COUNT` parámetro en [CREATE TABLE &#40;&#41;de TRANSACT-SQL](/sql/t-sql/statements/create-table-transact-sql) o el [tipo Create &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-type-transact-sql).</span><span class="sxs-lookup"><span data-stu-id="bf0cd-111">The size of the hash table allocated for an index is specified by the `BUCKET_COUNT` parameter in [CREATE TABLE &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-table-transact-sql) or [CREATE TYPE &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-type-transact-sql).</span></span> <span data-ttu-id="bf0cd-112">El número de cubos se redondeará internamente hasta la siguiente potencia de dos.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-112">The bucket count will internally be rounded up to the next power of two.</span></span> <span data-ttu-id="bf0cd-113">Por ejemplo, especificar un número de cubos de 300.000 producirá un número real de cubos de 524.288.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-113">For example, specifying a bucket count of 300,000 will result in an actual bucket count of 524,288.</span></span>  
  
 <span data-ttu-id="bf0cd-114">Para ver vínculos a un artículo y vídeo en el número de cubos, consulte [Cómo determinar el número de cubos adecuado para índices de hash (OLTP en memoria)](https://www.mssqltips.com/sqlservertip/3104/determine-bucketcount-for-hash-indexes-for-sql-server-memory-optimized-tables/).</span><span class="sxs-lookup"><span data-stu-id="bf0cd-114">For links to an article and video on bucket count, see [How to determine the right bucket count for hash indexes (In-Memory OLTP)](https://www.mssqltips.com/sqlservertip/3104/determine-bucketcount-for-hash-indexes-for-sql-server-memory-optimized-tables/).</span></span>  
  
## <a name="recommendations"></a><span data-ttu-id="bf0cd-115">Recomendaciones</span><span class="sxs-lookup"><span data-stu-id="bf0cd-115">Recommendations</span></span>  
 <span data-ttu-id="bf0cd-116">En la mayoría de los casos el número de cubos debe estar entre 1 y 2 veces el número de valores distintos de la clave de índice.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-116">In most cases the bucket count should be between 1 and 2 times the number of distinct values in the index key.</span></span> <span data-ttu-id="bf0cd-117">Si la clave de índice contiene muchos valores duplicados, como promedio hay más de 10 filas por cada valor de clave de índice, utilice un índice no clúster en su lugar.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-117">If the index key contains a lot of duplicate values, on average there are more than 10 rows for each index key value, use a nonclustered index instead</span></span>  
  
 <span data-ttu-id="bf0cd-118">No podrá siempre predecir cuántos valores puede tener o tendrá una clave de índice determinada.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-118">You may not always be able to predict how many values a particular index key may have or will have.</span></span> <span data-ttu-id="bf0cd-119">El rendimiento debe ser aceptable si el valor de `BUCKET_COUNT` está en el intervalo de 5 veces el número real de valores de clave.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-119">Performance should be acceptable if the `BUCKET_COUNT` value is within 5 times of the actual number of key values.</span></span>  
  
 <span data-ttu-id="bf0cd-120">Para determinar el número de claves de índice único en los datos existentes, utilice las consultas similares a los siguientes ejemplos:</span><span class="sxs-lookup"><span data-stu-id="bf0cd-120">To determine the number of unique index keys in existing data, use queries similar to the following examples:</span></span>  
  
### <a name="primary-key-and-unique-indexes"></a><span data-ttu-id="bf0cd-121">Clave principal e índices únicos</span><span class="sxs-lookup"><span data-stu-id="bf0cd-121">Primary Key and Unique Indexes</span></span>  
 <span data-ttu-id="bf0cd-122">Dado que el índice de clave principal es único, el número de valores distintos en la clave corresponde al número de filas de la tabla.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-122">Because the primary key index is unique, the number of distinct values in the key corresponds to the number of rows in the table.</span></span> <span data-ttu-id="bf0cd-123">Para una clave principal de ejemplo en (SalesOrderID, SalesOrderDetailID) de la tabla Sales.SalesOrderDetail de la base de datos AdventureWorks, ejecute la consulta siguiente para calcular el número de valores de clave principal distintos, que corresponde al número de filas de la tabla:</span><span class="sxs-lookup"><span data-stu-id="bf0cd-123">For an example primary key on (SalesOrderID, SalesOrderDetailID) in the table Sales.SalesOrderDetail in the AdventureWorks database, issue the following query to calculate the number of distinct primary key values, which corresponds to the number of rows in the table:</span></span>  
  
```sql  
SELECT COUNT(*) AS [row count]   
FROM Sales.SalesOrderDetail  
```  
  
 <span data-ttu-id="bf0cd-124">Esta consulta muestra un número de filas de 121.317.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-124">This query shows a row count of 121,317.</span></span> <span data-ttu-id="bf0cd-125">Use un número de cubos de 240.000 si el recuento de filas no va a cambiar significativamente.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-125">Use a bucket count of 240,000 if the row count will not change significantly.</span></span> <span data-ttu-id="bf0cd-126">Use un número de cubos de 480.000 si se espera que el número de pedidos de la tabla se cuadruplique.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-126">Use a bucket count of 480,000 if the number of sales orders in the table is expected to quadruple.</span></span>  
  
### <a name="non-unique-indexes"></a><span data-ttu-id="bf0cd-127">Índices no únicos</span><span class="sxs-lookup"><span data-stu-id="bf0cd-127">Non-Unique Indexes</span></span>  
 <span data-ttu-id="bf0cd-128">Para otros índices, por ejemplo un índice de varias columnas en (SpecialOfferID, ProductID), ejecute la consulta siguiente para determinar el número de valores de clave de índice único:</span><span class="sxs-lookup"><span data-stu-id="bf0cd-128">For other indexes, for example a multi-column index on (SpecialOfferID, ProductID), issue the following query to determine the number of unique index key values:</span></span>  
  
```sql  
SELECT COUNT(*) AS [SpecialOfferID_ProductID index key count]  
FROM   
   (SELECT DISTINCT SpecialOfferID, ProductID   
    FROM Sales.SalesOrderDetail) t  
```  
  
 <span data-ttu-id="bf0cd-129">Esta consulta devuelve un recuento de clave de índice para (SpecialOfferID, ProductID) de 484, lo que indica que se debe usar un índice no clúster en lugar de un índice de hash no clúster.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-129">This query returns an index key count for (SpecialOfferID, ProductID) of 484, indicating a that a nonclustered index should be used instead of a nonclustered hash index.</span></span>  
  
### <a name="determining-the-number-of-duplicates"></a><span data-ttu-id="bf0cd-130">Determinar el número de duplicados</span><span class="sxs-lookup"><span data-stu-id="bf0cd-130">Determining the Number of Duplicates</span></span>  
 <span data-ttu-id="bf0cd-131">Para determinar el número promedio de valores duplicados para un valor de clave de índice, divida el número total de filas por el número de claves de índice único.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-131">To determine the average number of duplicate values for an index key value, divide the total number of rows by the number of unique index keys.</span></span>  
  
 <span data-ttu-id="bf0cd-132">Para el índice de ejemplo en (SpecialOfferID, ProductID), esto da como resultado 121317 / 484 = 251.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-132">For the example index on (SpecialOfferID, ProductID), this leads to 121317 / 484 = 251.</span></span> <span data-ttu-id="bf0cd-133">Esto significa que los valores de clave de índice tienen una media de 251 y por consiguiente debe ser un índice no clúster.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-133">This means index key values have an average of 251, and thus this should be a nonclustered index.</span></span>  
  
## <a name="troubleshooting-the-bucket-count"></a><span data-ttu-id="bf0cd-134">Solucionar problemas del número de depósitos</span><span class="sxs-lookup"><span data-stu-id="bf0cd-134">Troubleshooting the Bucket Count</span></span>  
 <span data-ttu-id="bf0cd-135">Para solucionar problemas de número de cubos en tablas optimizadas para memoria, use [Sys. dm_db_xtp_hash_index_stats &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-xtp-hash-index-stats-transact-sql) para obtener estadísticas sobre los cubos vacíos y la longitud de las cadenas de filas.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-135">To troubleshoot bucket count issues in memory-optimized tables, use [sys.dm_db_xtp_hash_index_stats &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-xtp-hash-index-stats-transact-sql) to obtain statistics about the empty buckets and the length of row chains.</span></span> <span data-ttu-id="bf0cd-136">La siguiente consulta se puede utilizar para obtener estadísticas sobre todos los índices de hash de la base de datos actual.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-136">The following query can be used to obtain statistics about all the hash indexes in the current database.</span></span> <span data-ttu-id="bf0cd-137">La consulta puede tardar varios minutos en ejecutarse si hay tablas de gran tamaño en la base de datos.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-137">The query can take several minutes to run if there are large tables in the database.</span></span>  
  
```sql  
SELECT   
   object_name(hs.object_id) AS 'object name',   
   i.name as 'index name',   
   hs.total_bucket_count,  
   hs.empty_bucket_count,  
   floor((cast(empty_bucket_count as float)/total_bucket_count) * 100) AS 'empty_bucket_percent',  
   hs.avg_chain_length,   
   hs.max_chain_length  
FROM sys.dm_db_xtp_hash_index_stats AS hs   
   JOIN sys.indexes AS i   
   ON hs.object_id=i.object_id AND hs.index_id=i.index_id  
```  
  
 <span data-ttu-id="bf0cd-138">Los dos indicadores clave de estado de índice de hash son:</span><span class="sxs-lookup"><span data-stu-id="bf0cd-138">The two key indicators of hash index health are:</span></span>  
  
 <span data-ttu-id="bf0cd-139">*empty_bucket_percent*</span><span class="sxs-lookup"><span data-stu-id="bf0cd-139">*empty_bucket_percent*</span></span>  
 <span data-ttu-id="bf0cd-140">*empty_bucket_percent* indica el número de cubos vacíos del índice de hash.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-140">*empty_bucket_percent* indicates the number of empty buckets in the hash index.</span></span>  
  
 <span data-ttu-id="bf0cd-141">Si *empty_bucket_percent* es menos que el 10 por ciento, probablemente el número de cubos es demasiado bajo.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-141">If *empty_bucket_percent* is less than 10 percent, the bucket count is likely to be too low.</span></span> <span data-ttu-id="bf0cd-142">Idealmente, *empty_bucket_percent* debe ser el 33 por ciento o mayor.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-142">Ideally, the *empty_bucket_percent* should be 33 percent or greater.</span></span> <span data-ttu-id="bf0cd-143">Si el número de cubos coincide con el número de valores de clave de índice, cerca de 1/3 de los cubos está vacío, debido a la distribución de hash.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-143">If the bucket count matches the number of index key values, about 1/3 of the buckets is empty, due to hash distribution.</span></span>  
  
 <span data-ttu-id="bf0cd-144">*avg_chain_length*</span><span class="sxs-lookup"><span data-stu-id="bf0cd-144">*avg_chain_length*</span></span>  
 <span data-ttu-id="bf0cd-145">*avg_chain_length* indica el promedio de longitud de las cadenas de filas de los cubos de hash.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-145">*avg_chain_length* indicates the average length of the row chains in the hash buckets.</span></span>  
  
 <span data-ttu-id="bf0cd-146">Si *avg_chain_length* es mayor que 10 y *empty_bucket_percent* es mayor del 10 por ciento, probablemente hay muchos valores de clave de índice duplicados y un índice no clúster resultaría más adecuado.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-146">If *avg_chain_length* is greater than 10 and *empty_bucket_percent* is greater than 10 percent, there likely are many duplicate index key values and a nonclustered index would be more appropriate.</span></span> <span data-ttu-id="bf0cd-147">Un promedio de longitud de cadena de 1 es ideal.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-147">An average chain length of 1 is ideal.</span></span>  
  
 <span data-ttu-id="bf0cd-148">Existen dos factores que afectan la longitud de cadena:</span><span class="sxs-lookup"><span data-stu-id="bf0cd-148">There are two factors that impact the chain length:</span></span>  
  
1.  <span data-ttu-id="bf0cd-149">Duplicados: todas las filas duplicadas forman parte de la misma cadena del índice hash.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-149">Duplicates; all duplicate rows are part of the same chain in the hash index.</span></span>  
  
2.  <span data-ttu-id="bf0cd-150">Varios valores de clave asignados al mismo cubo.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-150">Multiple key values map to the same bucket.</span></span> <span data-ttu-id="bf0cd-151">Cuanto menor sea el número de cubos, más cubos tendrán varios valores asignados.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-151">The lower the bucket count, the more buckets that will have multiple values mapped to them.</span></span>  
  
 <span data-ttu-id="bf0cd-152">Por ejemplo, considere la tabla y el script siguientes para insertar filas de ejemplo de la tabla:</span><span class="sxs-lookup"><span data-stu-id="bf0cd-152">As an example, consider the following table and script to insert sample rows in the table:</span></span>  
  
```sql  
CREATE TABLE [Sales].[SalesOrderHeader_test]  
(  
   [SalesOrderID] [uniqueidentifier] NOT NULL DEFAULT (newid()),  
   [OrderSequence] int NOT NULL,  
   [OrderDate] [datetime2](7) NOT NULL,  
   [Status] [tinyint] NOT NULL,  
  
PRIMARY KEY NONCLUSTERED HASH ([SalesOrderID]) WITH ( BUCKET_COUNT = 262144 ),  
INDEX IX_OrderSequence HASH (OrderSequence) WITH ( BUCKET_COUNT = 20000),  
INDEX IX_Status HASH ([Status]) WITH ( BUCKET_COUNT = 8),  
INDEX IX_OrderDate NONCLUSTERED ([OrderDate] ASC),  
)WITH ( MEMORY_OPTIMIZED = ON , DURABILITY = SCHEMA_AND_DATA )  
GO  
  
DECLARE @i int = 0  
BEGIN TRAN  
WHILE @i < 262144  
BEGIN  
   INSERT Sales.SalesOrderHeader_test (OrderSequence, OrderDate, [Status]) VALUES (@i, sysdatetime(), @i % 8)  
   SET @i += 1  
END  
COMMIT  
GO  
```  
  
 <span data-ttu-id="bf0cd-153">El script inserta 262.144 filas en la tabla.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-153">The script inserts 262,144 rows in the table.</span></span> <span data-ttu-id="bf0cd-154">Inserta valores únicos en el índice de clave principal y en IX_OrderSequence.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-154">It inserts unique values in the primary key index and in IX_OrderSequence.</span></span> <span data-ttu-id="bf0cd-155">Inserta muchos valores duplicados en el índice IX_Status: el script genera solo 8 valores distintos.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-155">It inserts a lot of duplicate values in the index IX_Status: the script only generates 8 distinct values.</span></span>  
  
 <span data-ttu-id="bf0cd-156">El resultado de la consulta de la solución de problemas de BUCKET_COUNT es el siguiente:</span><span class="sxs-lookup"><span data-stu-id="bf0cd-156">The output of the BUCKET_COUNT troubleshooting query is as follows:</span></span>  
  
|<span data-ttu-id="bf0cd-157">nombre de índice</span><span class="sxs-lookup"><span data-stu-id="bf0cd-157">index name</span></span>|<span data-ttu-id="bf0cd-158">total_bucket_count</span><span class="sxs-lookup"><span data-stu-id="bf0cd-158">total_bucket_count</span></span>|<span data-ttu-id="bf0cd-159">empty_bucket_count</span><span class="sxs-lookup"><span data-stu-id="bf0cd-159">empty_bucket_count</span></span>|<span data-ttu-id="bf0cd-160">empty_bucket_percent</span><span class="sxs-lookup"><span data-stu-id="bf0cd-160">empty_bucket_percent</span></span>|<span data-ttu-id="bf0cd-161">avg_chain_length</span><span class="sxs-lookup"><span data-stu-id="bf0cd-161">avg_chain_length</span></span>|<span data-ttu-id="bf0cd-162">max_chain_length</span><span class="sxs-lookup"><span data-stu-id="bf0cd-162">max_chain_length</span></span>|  
|----------------|--------------------------|--------------------------|----------------------------|------------------------|------------------------|  
|<span data-ttu-id="bf0cd-163">IX_Status</span><span class="sxs-lookup"><span data-stu-id="bf0cd-163">IX_Status</span></span>|<span data-ttu-id="bf0cd-164">8</span><span class="sxs-lookup"><span data-stu-id="bf0cd-164">8</span></span>|<span data-ttu-id="bf0cd-165">4</span><span class="sxs-lookup"><span data-stu-id="bf0cd-165">4</span></span>|<span data-ttu-id="bf0cd-166">50</span><span class="sxs-lookup"><span data-stu-id="bf0cd-166">50</span></span>|<span data-ttu-id="bf0cd-167">65536</span><span class="sxs-lookup"><span data-stu-id="bf0cd-167">65536</span></span>|<span data-ttu-id="bf0cd-168">65536</span><span class="sxs-lookup"><span data-stu-id="bf0cd-168">65536</span></span>|  
|<span data-ttu-id="bf0cd-169">IX_OrderSequence</span><span class="sxs-lookup"><span data-stu-id="bf0cd-169">IX_OrderSequence</span></span>|<span data-ttu-id="bf0cd-170">32 768</span><span class="sxs-lookup"><span data-stu-id="bf0cd-170">32768</span></span>|<span data-ttu-id="bf0cd-171">13</span><span class="sxs-lookup"><span data-stu-id="bf0cd-171">13</span></span>|<span data-ttu-id="bf0cd-172">0</span><span class="sxs-lookup"><span data-stu-id="bf0cd-172">0</span></span>|<span data-ttu-id="bf0cd-173">8</span><span class="sxs-lookup"><span data-stu-id="bf0cd-173">8</span></span>|<span data-ttu-id="bf0cd-174">26</span><span class="sxs-lookup"><span data-stu-id="bf0cd-174">26</span></span>|  
|<span data-ttu-id="bf0cd-175">PK_SalesOrd_B14003C3F8FB3364</span><span class="sxs-lookup"><span data-stu-id="bf0cd-175">PK_SalesOrd_B14003C3F8FB3364</span></span>|<span data-ttu-id="bf0cd-176">262 144</span><span class="sxs-lookup"><span data-stu-id="bf0cd-176">262144</span></span>|<span data-ttu-id="bf0cd-177">96319</span><span class="sxs-lookup"><span data-stu-id="bf0cd-177">96319</span></span>|<span data-ttu-id="bf0cd-178">36</span><span class="sxs-lookup"><span data-stu-id="bf0cd-178">36</span></span>|<span data-ttu-id="bf0cd-179">1</span><span class="sxs-lookup"><span data-stu-id="bf0cd-179">1</span></span>|<span data-ttu-id="bf0cd-180">8</span><span class="sxs-lookup"><span data-stu-id="bf0cd-180">8</span></span>|  
  
 <span data-ttu-id="bf0cd-181">Considere los tres índices de hash en esta tabla:</span><span class="sxs-lookup"><span data-stu-id="bf0cd-181">Consider the three hash indexes on this table:</span></span>  
  
-   <span data-ttu-id="bf0cd-182">IX_Status: el 50 por ciento de los cubos están vacíos, que es bueno.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-182">IX_Status: 50 percent of the buckets are empty, which is good.</span></span> <span data-ttu-id="bf0cd-183">Sin embargo, el promedio de longitud de cadena es muy elevado (65.536).</span><span class="sxs-lookup"><span data-stu-id="bf0cd-183">However, the average chain length is very high (65,536).</span></span> <span data-ttu-id="bf0cd-184">Esto indica un gran número de valores duplicados.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-184">This indicates a large number of duplicate values.</span></span> <span data-ttu-id="bf0cd-185">Por consiguiente, el uso de un índice de hash no clúster no es adecuado en este caso.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-185">Therefore, using a nonclustered hash index is not appropriate in this case.</span></span> <span data-ttu-id="bf0cd-186">Se debe usar un índice no clúster en su lugar.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-186">A nonclustered index should be used instead.</span></span>  
  
-   <span data-ttu-id="bf0cd-187">IX_OrderSequence: el 0 por ciento de los cubos están vacíos, que es demasiado bajo.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-187">IX_OrderSequence: 0 percent of the buckets are empty, which is too low.</span></span> <span data-ttu-id="bf0cd-188">Además, el promedio de longitud de cadena es 8.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-188">In addition, the average chain length is 8.</span></span> <span data-ttu-id="bf0cd-189">Como los valores de este índice son únicos, esto significa que por término medio están asignados 8 valores a cada cubo.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-189">As the values in this index are unique, this means on average 8 values are mapped to each bucket.</span></span> <span data-ttu-id="bf0cd-190">El número de cubos se debe aumentar.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-190">The bucket count should be increased.</span></span> <span data-ttu-id="bf0cd-191">Como la clave de índice tiene 262.144 valores únicos, el número de cubos debe ser al menos 262.144.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-191">As the index key has 262,144 unique values, the bucket count should be at least 262,144.</span></span> <span data-ttu-id="bf0cd-192">Si se espera un aumento futuro, el número debe ser superior.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-192">If future growth is expected, the number should be higher.</span></span>  
  
-   <span data-ttu-id="bf0cd-193">Índice de clave principal (PK__SalesOrder...): el 36 por ciento de los cubos están vacíos, que es bueno.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-193">Primary key index (PK__SalesOrder...): 36 percent of the buckets are empty, which is good.</span></span> <span data-ttu-id="bf0cd-194">Además el promedio de longitud de cadena es 1, que también es bueno.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-194">In addition the average chain length is 1, which is also good.</span></span> <span data-ttu-id="bf0cd-195">No es necesario ningún cambio.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-195">No change needed.</span></span>  
  
 <span data-ttu-id="bf0cd-196">Para obtener más información sobre problemas de solución de problemas con los índices de hash optimizados para memoria, vea [Troubleshooting Common Performance Problems with Memory-Optimized Hash Indexes](../../2014/database-engine/troubleshooting-common-performance-problems-with-memory-optimized-hash-indexes.md).</span><span class="sxs-lookup"><span data-stu-id="bf0cd-196">For more information on troubleshooting issues with your memory-optimized hash indexes, see [Troubleshooting Common Performance Problems with Memory-Optimized Hash Indexes](../../2014/database-engine/troubleshooting-common-performance-problems-with-memory-optimized-hash-indexes.md).</span></span>  
  
## <a name="detailed-considerations-for-further-optimization"></a><span data-ttu-id="bf0cd-197">Consideraciones detalladas de optimización adicional</span><span class="sxs-lookup"><span data-stu-id="bf0cd-197">Detailed Considerations for Further Optimization</span></span>  
 <span data-ttu-id="bf0cd-198">Esta sección describe las consideraciones adicionales para optimizar el número de cubos.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-198">This section outlines further considerations for optimizing the bucket count.</span></span>  
  
 <span data-ttu-id="bf0cd-199">Para obtener el mejor rendimiento de los índices de hash, equilibre la cantidad de memoria asignada a la tabla hash y el número de valores distintos en la clave de índice.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-199">To achieve the best performance for hash indexes, balance the amount of memory allocated to the hash table and the number of distinct values in the index key.</span></span> <span data-ttu-id="bf0cd-200">Hay también un equilibrio entre el rendimiento de las búsquedas de puntos y los recorridos de tablas:</span><span class="sxs-lookup"><span data-stu-id="bf0cd-200">There is also a balance between the performance of point lookups and table scans:</span></span>  
  
-   <span data-ttu-id="bf0cd-201">Cuanto mayor sea el valor de número de cubos, más cubos vacíos habrá en el índice.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-201">The higher the bucket count value, the more empty buckets there will be in the index.</span></span> <span data-ttu-id="bf0cd-202">Esto tiene un impacto en la utilización de memoria (8 bytes por cada cubo) y en el rendimiento de los recorridos de tablas, ya que cada cubo se examina como parte de un recorrido de tabla.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-202">This has an impact on memory usage (8 bytes per bucket) and the performance of table scans, as each bucket is scanned as part of a table scan.</span></span>  
  
-   <span data-ttu-id="bf0cd-203">Cuanto menor es el número de cubos, más valores se asignan a un único cubo.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-203">The lower the bucket count, the more values are assigned to a single bucket.</span></span> <span data-ttu-id="bf0cd-204">Esto reduce el rendimiento de las inserciones y las búsquedas de puntos, porque [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] puede necesitar recorrer varios valores en un único cubo para encontrar el valor especificado por el predicado de búsqueda.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-204">This decreases performance for point lookups and inserts, because [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] may need to traverse several values in a single bucket to find the value specified by the search predicate.</span></span>  
  
 <span data-ttu-id="bf0cd-205">Si el número de cubos es significativamente menor que el número de claves de índice único, se asignarán muchos valores a cada cubo.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-205">If the bucket count is significantly lower than the number of unique index keys, many values will map to each bucket.</span></span> <span data-ttu-id="bf0cd-206">Esto disminuye el rendimiento de la mayoría de las operaciones DML, especialmente para las búsquedas de punto (búsquedas de claves de índice individuales) y para las operaciones de inserción.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-206">This degrades performance of most DML operations, particularly point lookups (lookups of individual index keys) and insert operations.</span></span> <span data-ttu-id="bf0cd-207">Por ejemplo, es posible que observe poco rendimiento de las consultas SELECT y de las operaciones UPDATE y DELETE con predicados de igualdad que se corresponden con las columnas de clave de índice en la cláusula WHERE.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-207">For example, you may see poor performance of SELECT queries and, UPDATE and DELETE operations with equality predicates matching the index key columns in the WHERE clause.</span></span> <span data-ttu-id="bf0cd-208">Un número inferior de depósitos afectará también el tiempo de recuperación de la base de datos, dado que se vuelven a crear los índices durante el inicio de la base de datos.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-208">A low bucket count will also affect the recovery time of the database, as the indexes are recreated on database startup.</span></span>  
  
### <a name="duplicate-index-key-values"></a><span data-ttu-id="bf0cd-209">Valores de clave de índice duplicados</span><span class="sxs-lookup"><span data-stu-id="bf0cd-209">Duplicate Index Key Values</span></span>  
 <span data-ttu-id="bf0cd-210">Los valores duplicados pueden aumentar el impacto en el rendimiento de las colisiones de valores hash.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-210">Duplicate values can increase the performance impact of hash collisions.</span></span> <span data-ttu-id="bf0cd-211">No suele ser un problema si cada clave de índice tiene un número bajo de duplicados.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-211">This is usually not a problem if each index key has a low number of duplicates.</span></span> <span data-ttu-id="bf0cd-212">Pero puede ser un problema si la discrepancia entre el número de claves de índice único y el número de filas de las tablas se vuelve muy grande.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-212">But this can be a problem if the discrepancy between the number of unique index keys and the number of rows in the tables becomes very large.</span></span>  
  
 <span data-ttu-id="bf0cd-213">Todas las filas con la misma clave de índice entrarán en la misma cadena de duplicados.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-213">All rows with the same index key will go into the same duplicate chain.</span></span> <span data-ttu-id="bf0cd-214">Si hay varias claves de índice en el mismo cubo debido a una colisión de hash, las exploraciones de índice tienen que examinar siempre la cadena completa de duplicados para el primer valor con el fin de poder ubicar la primera fila correspondiente al segundo valor.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-214">If multiple index keys are in the same bucket due to a hash collision, index scanners always need to scan the full duplicate chain for the first value before they can locate the first row corresponding to the second value.</span></span> <span data-ttu-id="bf0cd-215">Las claves duplicadas también dificultan que la recolección de elementos no utilizados encuentre la fila.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-215">Duplicate keys also make it more difficult for garbage collection to locate the row.</span></span> <span data-ttu-id="bf0cd-216">Por ejemplo, si hay 1.000 duplicados para cualquier clave y se elimina una de las filas, el recolector de elementos no utilizados debe examinar la cadena de 1.000 duplicados para desvincular la fila del índice.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-216">For example, if there are 1,000 duplicates for any key and one of the rows is deleted, the garbage collector needs to scan the chain of 1,000 duplicates to unlink the row from the index.</span></span> <span data-ttu-id="bf0cd-217">Esto es cierto incluso aunque la consulta que encontró la eliminación utilizara un índice más eficaz (un índice de clave principal) para encontrar la fila, ya que el recolector de elementos no utilizados debe desvincular desde cada índice.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-217">This is true even if the query that found the delete used a more efficient index (a primary key index) to locate the row, because the garbage collector needs to unlink from every index</span></span>  
  
 <span data-ttu-id="bf0cd-218">Para los índices hash, hay dos formas de reducir el trabajo debido a valores de clave de índice duplicados:</span><span class="sxs-lookup"><span data-stu-id="bf0cd-218">For hash indexes, there are two ways to reduce the work caused by duplicate index key values:</span></span>  
  
-   <span data-ttu-id="bf0cd-219">Use un índice no clúster en su lugar.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-219">Use a nonclustered index instead.</span></span> <span data-ttu-id="bf0cd-220">Puede reducir los duplicados si agrega columnas a la clave de índice sin necesidad de hacer cambios en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-220">You can decrease the duplicates by adding columns to the index key without requiring any changes to the application.</span></span>  
  
-   <span data-ttu-id="bf0cd-221">Especifique un número muy alto de cubos para el índice.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-221">Specify a very high bucket count for the index.</span></span> <span data-ttu-id="bf0cd-222">Por ejemplo, 20 a 100 veces el número de claves de índice único.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-222">For example, 20-to-100 times the number of unique index keys.</span></span> <span data-ttu-id="bf0cd-223">Esto reducirá las colisiones de hash.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-223">This will reduce hash collisions.</span></span>  
  
### <a name="small-tables"></a><span data-ttu-id="bf0cd-224">Tablas pequeñas</span><span class="sxs-lookup"><span data-stu-id="bf0cd-224">Small Tables</span></span>  
 <span data-ttu-id="bf0cd-225">Para tablas más pequeñas, el uso de memoria no suele ser un problema, puesto que el tamaño del índice será pequeño en comparación con el tamaño total de la base de datos.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-225">For smaller tables, memory utilization is usually not a concern, as the size of the index will be small compared to the overall size of the database.</span></span>  
  
 <span data-ttu-id="bf0cd-226">Ahora debe tomar una decisión basada en el tipo de rendimiento que desea:</span><span class="sxs-lookup"><span data-stu-id="bf0cd-226">You must now make a choice based on the kind of performance you want:</span></span>  
  
-   <span data-ttu-id="bf0cd-227">Si las operaciones de rendimiento crítico en el índice son fundamentalmente búsquedas de puntos u operaciones de inserción, sería adecuado un número mayor de cubos para reducir la probabilidad de colisiones de valores hash.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-227">If the performance-critical operations on the index are predominantly point lookups and/or insert operations, a higher bucket count would be appropriate to reduce the likelihood of hash collisions.</span></span> <span data-ttu-id="bf0cd-228">Tres veces el número de filas o incluso más sería la mejor opción.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-228">Three times the number of rows or even more would be the best option.</span></span>  
  
-   <span data-ttu-id="bf0cd-229">Si las exploraciones completas de índice son las predominantes de rendimiento crítico, use un número de cubos cercano al número real de valores de clave de índice.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-229">If full index scans are the predominant performance-critical operations, use a bucket count that is close to the actual number of index key values.</span></span>  
  
### <a name="big-tables"></a><span data-ttu-id="bf0cd-230">Tablas grandes</span><span class="sxs-lookup"><span data-stu-id="bf0cd-230">Big Tables</span></span>  
 <span data-ttu-id="bf0cd-231">Para las tablas grandes, el uso de memoria podría llegar a ser un problema.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-231">For large tables, memory utilization could become a concern.</span></span> <span data-ttu-id="bf0cd-232">Por ejemplo, con una tabla de filas 250 millones con 4 índices de hash, cada uno con un número de depósitos de 1 mil millones, la sobrecarga de las tablas hash es 4 índices \* 1 mil millones depósitos \* 8 bytes = 32 gigabytes de uso de memoria.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-232">For example, with a 250 million row table that has 4 hash indexes, each with a bucket count of one billion, the overhead for the hash tables is 4 indexes \* 1 billion buckets \* 8 bytes = 32 gigabytes of memory utilization.</span></span> <span data-ttu-id="bf0cd-233">Al elegir un número de cubos de 250 millones para cada uno de los índices, la sobrecarga total de las tablas hash será de 8 gigabytes.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-233">When choosing a bucket count of 250 million for each of the indexes, the total overhead for the hash tables will be 8 gigabytes.</span></span> <span data-ttu-id="bf0cd-234">Tenga en cuenta que esto se suma a los 8 bytes de uso de memoria que cada índice agrega a cada fila individual, que es 8 gigabytes en este escenario (4 índices \* 8 bytes \* 250 millones filas).</span><span class="sxs-lookup"><span data-stu-id="bf0cd-234">Note that this is in addition to the 8 bytes of memory usage each index adds to each individual row, which is 8 gigabytes in this scenario (4 indexes \* 8 bytes \* 250 million rows).</span></span>  
  
 <span data-ttu-id="bf0cd-235">Las exploraciones de tabla completas no están generalmente en la ruta de acceso de rendimiento crítico para las cargas de trabajo de OLTP.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-235">Full table scans are not usually in the performance-critical path for OLTP workloads.</span></span> <span data-ttu-id="bf0cd-236">Por consiguiente, la elección está entre el uso de memoria frente al rendimiento de operaciones de búsqueda de puntos e inserción:</span><span class="sxs-lookup"><span data-stu-id="bf0cd-236">Therefore, the choice is between memory utilization versus performance of point lookup and insert operations:</span></span>  
  
-   <span data-ttu-id="bf0cd-237">Si la utilización de memoria es un problema, elija un número de cubos cercano al número de valores de clave de índice.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-237">If memory utilization is a concern, choose a bucket count close to the number of index key values.</span></span> <span data-ttu-id="bf0cd-238">El número de cubos no debería ser significativamente menor que el número de valores de clave de índice, puesto que esto afecta a la mayoría de las operaciones de DML así como al tiempo que lleva recuperar la base de datos después de reiniciar el servidor.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-238">The bucket count should not be significantly lower than the number of index key values, as this impacts most DML operations as well the time it takes to recover the database after server restart.</span></span>  
  
-   <span data-ttu-id="bf0cd-239">Al optimizar el rendimiento de las búsquedas de puntos, un número mayor de cubos de dos o incluso tres veces el número de valores de índice único sería adecuado.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-239">When optimizing the performance for point lookups, a higher bucket count of two or even three times the number of unique index values would be appropriate.</span></span> <span data-ttu-id="bf0cd-240">Un número mayor de cubos significaría una mayor uso de memoria y un incremento del tiempo necesario para una exploración completa del índice.</span><span class="sxs-lookup"><span data-stu-id="bf0cd-240">A higher bucket count would mean an increased memory utilization and an increase in the time required for a full index scan.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="bf0cd-241">Consulte también</span><span class="sxs-lookup"><span data-stu-id="bf0cd-241">See Also</span></span>  
 [<span data-ttu-id="bf0cd-242">Índices de las tablas con optimización para memoria</span><span class="sxs-lookup"><span data-stu-id="bf0cd-242">Indexes on Memory-Optimized Tables</span></span>](../../2014/database-engine/indexes-on-memory-optimized-tables.md)  
  
  
