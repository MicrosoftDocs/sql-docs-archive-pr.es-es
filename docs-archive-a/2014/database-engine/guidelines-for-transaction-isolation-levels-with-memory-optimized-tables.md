---
title: Directrices para los niveles de aislamiento de transacción con tablas con optimización para memoria | Microsoft Docs
ms.custom: ''
ms.date: 03/06/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: in-memory-oltp
ms.topic: conceptual
ms.assetid: e365e9ca-c34b-44ae-840c-10e599fa614f
author: stevestein
ms.author: sstein
ms.openlocfilehash: 834c5950a8f8b0ddf8854d06c6fb1073a264fc22
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 08/04/2020
ms.locfileid: "87746417"
---
# <a name="guidelines-for-transaction-isolation-levels-with-memory-optimized-tables"></a><span data-ttu-id="257d9-102">Instrucciones para los niveles de aislamiento de transacciones con tablas con optimización para memoria</span><span class="sxs-lookup"><span data-stu-id="257d9-102">Guidelines for Transaction Isolation Levels with Memory-Optimized Tables</span></span>
  <span data-ttu-id="257d9-103">En muchos casos, debe especificar el nivel de aislamiento de transacción.</span><span class="sxs-lookup"><span data-stu-id="257d9-103">In many scenarios, you must specify the transaction isolation level.</span></span> <span data-ttu-id="257d9-104">El aislamiento de transacción para las tablas optimizadas para memoria difiere de las tablas basadas en disco.</span><span class="sxs-lookup"><span data-stu-id="257d9-104">Transaction isolation for memory-optimized tables differs from disk-based tables.</span></span>  
  
 <span data-ttu-id="257d9-105">Requisitos para especificar el nivel de aislamiento de transacción:</span><span class="sxs-lookup"><span data-stu-id="257d9-105">Requirements for specifying transaction isolation level:</span></span>  
  
-   <span data-ttu-id="257d9-106">TRANSACTION ISOLATION LEVEL es una opción necesaria para el bloque ATOMIC que comprende el contenido de un procedimiento almacenado compilado de forma nativa.</span><span class="sxs-lookup"><span data-stu-id="257d9-106">TRANSACTION ISOLATION LEVEL is a required option for the ATOMIC block comprising the content of a natively compiled stored procedure.</span></span>  
  
-   <span data-ttu-id="257d9-107">Debido a las restricciones de uso del nivel de aislamiento en las transacciones entre contenedores, el uso de tablas optimizadas para memoria en [!INCLUDE[tsql](../includes/tsql-md.md)] interpretado debe ir acompañado con frecuencia de una sugerencia de tabla que especifique el nivel de aislamiento usado para el acceso a la tabla.</span><span class="sxs-lookup"><span data-stu-id="257d9-107">Because of restrictions on isolation level use in cross-container transactions, uses of memory-optimized tables in interpreted [!INCLUDE[tsql](../includes/tsql-md.md)] must often be accompanied by a table hint specifying the isolation level used to access the table.</span></span> <span data-ttu-id="257d9-108">Para obtener más información sobre las sugerencias de nivel de aislamiento y las transacciones entre contenedores, vea [niveles de aislamiento de transacción](../../2014/database-engine/transaction-isolation-levels.md).</span><span class="sxs-lookup"><span data-stu-id="257d9-108">For more information about isolation level hints and cross-container transactions, see [Transaction Isolation Levels](../../2014/database-engine/transaction-isolation-levels.md).</span></span>  
  
-   <span data-ttu-id="257d9-109">El nivel de aislamiento de transacción deseado debe declararse explícitamente.</span><span class="sxs-lookup"><span data-stu-id="257d9-109">The desired transaction isolation level must be explicitly declared.</span></span> <span data-ttu-id="257d9-110">No es posible utilizar sugerencias de bloqueo (como XLOCK) para garantizar el aislamiento de algunas filas o tablas de la transacción.</span><span class="sxs-lookup"><span data-stu-id="257d9-110">It is not possible to use locking hints (such as XLOCK) to guarantee the isolation of certain rows or tables in the transaction.</span></span>  
  
-   <span data-ttu-id="257d9-111">La aplicación que tiene acceso a la base de datos debe implementar lógica de reintentos para tratar los errores resultantes de conflictos de invalidación de transacciones, errores de validación y errores de dependencia de confirmación.</span><span class="sxs-lookup"><span data-stu-id="257d9-111">The application accessing the database should implement retry logic to deal with errors resulting from transaction-dooming conflicts, validation failures, and commit-dependency failures.</span></span> <span data-ttu-id="257d9-112">Tenga en cuenta que pueden producirse errores de dependencia de confirmación incluso con transacciones de solo lectura.</span><span class="sxs-lookup"><span data-stu-id="257d9-112">Note that commit dependency failures can occur even with read-only transactions.</span></span>  
  
-   <span data-ttu-id="257d9-113">Deben evitarse transacciones de ejecución prolongada con tablas optimizadas para memoria.</span><span class="sxs-lookup"><span data-stu-id="257d9-113">Long-running transactions should be avoided with memory-optimized tables.</span></span> <span data-ttu-id="257d9-114">Estas transacciones aumentan la probabilidad de conflictos y la terminación de las siguientes transacciones.</span><span class="sxs-lookup"><span data-stu-id="257d9-114">Such transactions increase the likelihood of conflicts and subsequent transaction terminations.</span></span> <span data-ttu-id="257d9-115">Una transacción de larga duración también pospone la recolección de elementos no utilizados.</span><span class="sxs-lookup"><span data-stu-id="257d9-115">A long-running transaction also defers garbage collection.</span></span> <span data-ttu-id="257d9-116">Cuanto más tiempo dure la ejecución de una transacción, más tiempo conserva OLTP en memoria las versiones de filas recién eliminadas, lo que puede reducir el rendimiento de la búsqueda de transacciones nuevas.</span><span class="sxs-lookup"><span data-stu-id="257d9-116">The longer a transaction runs, the longer In-Memory OLTP keeps recently deleted row versions, which can decrease lookup performance for new transactions.</span></span>  
  
 <span data-ttu-id="257d9-117">Las tablas basadas en disco se suelen basar en el bloqueo y en el bloqueo del aislamiento de las transacciones.</span><span class="sxs-lookup"><span data-stu-id="257d9-117">Disk-based tables typically rely on locking and blocking for transaction isolation.</span></span> <span data-ttu-id="257d9-118">Las tablas con optimización para memoria dependen del control de varias versiones y de la detección de conflictos para garantizar el aislamiento.</span><span class="sxs-lookup"><span data-stu-id="257d9-118">Memory-optimized tables rely on multi-versioning and conflict detection to guarantee isolation.</span></span> <span data-ttu-id="257d9-119">Para obtener más información, vea la sección sobre detección de conflictos, validación y comprobaciones de dependencias de confirmación en [transacciones en tablas optimizadas para memoria](../relational-databases/in-memory-oltp/memory-optimized-tables.md).</span><span class="sxs-lookup"><span data-stu-id="257d9-119">For details, see the section on Conflict Detection, Validation, and Commit Dependency Checks in [Transactions in Memory-Optimized Tables](../relational-databases/in-memory-oltp/memory-optimized-tables.md).</span></span>  
  
 <span data-ttu-id="257d9-120">Las tablas basadas en disco permiten el control de varias versiones con los niveles de aislamiento SNAPSHOT y READ_COMMITTED_SNAPSHOT.</span><span class="sxs-lookup"><span data-stu-id="257d9-120">Disk-based tables do allow multi-versioning with the isolation levels SNAPSHOT and READ_COMMITTED_SNAPSHOT.</span></span> <span data-ttu-id="257d9-121">En el caso de tablas optimizadas para memoria, todos los niveles de aislamiento se basan en el control de varias versiones, incluidos REPEATABLE READ y SERIALIZABLE.</span><span class="sxs-lookup"><span data-stu-id="257d9-121">For memory-optimized tables all isolation levels are multi-version based, including REPEATABLE READ and SERIALIZABLE.</span></span>  
  
## <a name="types-of-transactions"></a><span data-ttu-id="257d9-122">Tipos de transacciones</span><span class="sxs-lookup"><span data-stu-id="257d9-122">Types of Transactions</span></span>  
 <span data-ttu-id="257d9-123">Todas las consultas de [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] se ejecutan en el contexto de una transacción.</span><span class="sxs-lookup"><span data-stu-id="257d9-123">Every query in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] runs in the context of a transaction.</span></span>  
  
 <span data-ttu-id="257d9-124">Hay tres tipos de transacciones en [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]:</span><span class="sxs-lookup"><span data-stu-id="257d9-124">There are three types of transactions in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]:</span></span>  
  
-   <span data-ttu-id="257d9-125">Transacciones de confirmación automática.</span><span class="sxs-lookup"><span data-stu-id="257d9-125">Autocommit transactions.</span></span> <span data-ttu-id="257d9-126">Si no hay ningún contexto de transacción activa y las transacciones implícitas no están establecidas en ON en la sesión, cada consulta tiene su propio contexto de transacción.</span><span class="sxs-lookup"><span data-stu-id="257d9-126">If there is no active transaction context and implicit transactions are not set to ON in the session, each query has its own transaction context.</span></span> <span data-ttu-id="257d9-127">La transacción se inicia cuando comienza la ejecución de la instrucción y se completa cuando finaliza la instrucción.</span><span class="sxs-lookup"><span data-stu-id="257d9-127">The transaction starts when the statement starts execution, and completes when the statement finishes.</span></span>  
  
-   <span data-ttu-id="257d9-128">Transacciones explícitas.</span><span class="sxs-lookup"><span data-stu-id="257d9-128">Explicit transactions.</span></span> <span data-ttu-id="257d9-129">El usuario inicia la transacción mediante una instrucción BEGIN TRAN o BEGIN ATOMIC explícita.</span><span class="sxs-lookup"><span data-stu-id="257d9-129">The user starts the transaction through an explicit BEGIN TRAN or BEGIN ATOMIC.</span></span> <span data-ttu-id="257d9-130">La transacción se completa siguiendo la instrucción COMMITT y ROLLBACK o END correspondiente (en el caso de un bloque atomic).</span><span class="sxs-lookup"><span data-stu-id="257d9-130">The transaction is completed following the corresponding COMMIT and ROLLBACK or END (in the case of an atomic block).</span></span>  
  
-   <span data-ttu-id="257d9-131">transacciones implícitas.</span><span class="sxs-lookup"><span data-stu-id="257d9-131">Implicit transactions.</span></span> <span data-ttu-id="257d9-132">Cuando la opción IMPLICIT_TRANSACTIONS se establece en ON, una transacción se inicia implícitamente siempre que el usuario ejecuta una instrucción y no hay un contexto de transacción activa.</span><span class="sxs-lookup"><span data-stu-id="257d9-132">When the option IMPLICIT_TRANSACTIONS is set to ON, a transaction is started implicitly whenever the user executes a statement and there is no active transaction context.</span></span> <span data-ttu-id="257d9-133">La transacción se completa mediante instrucciones COMMIT y ROLLBACK explícitas.</span><span class="sxs-lookup"><span data-stu-id="257d9-133">The transaction is completed through an explicit COMMIT and ROLLBACK.</span></span>  
  
## <a name="baseline-read-committed-isolation"></a><span data-ttu-id="257d9-134">Aislamiento READ COMMITTED de línea base</span><span class="sxs-lookup"><span data-stu-id="257d9-134">Baseline READ COMMITTED Isolation</span></span>  
 <span data-ttu-id="257d9-135">READ COMMITTED es el nivel de aislamiento predeterminado en [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span><span class="sxs-lookup"><span data-stu-id="257d9-135">READ COMMITTED is the default isolation level in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span></span>  
  
 <span data-ttu-id="257d9-136">El nivel de aislamiento READ COMMITTED garantiza que las transacciones no ven datos no confirmados de los cambios ajenos a la transacción actual.</span><span class="sxs-lookup"><span data-stu-id="257d9-136">The isolation level READ COMMITTED guarantees that transactions do not see any uncommitted data from changes outside the current transaction.</span></span> <span data-ttu-id="257d9-137">Es decir, la transacción solo lee los datos que se han confirmado en la base de datos o que la transacción actual ha modificado.</span><span class="sxs-lookup"><span data-stu-id="257d9-137">In other words, the transaction only reads data which has either been committed to the database, or has been changed by the current transaction.</span></span>  
  
 <span data-ttu-id="257d9-138">Todos los niveles de aislamiento admitidos para las tablas optimizadas para memoria proporcionan la garantía de lectura confirmada.</span><span class="sxs-lookup"><span data-stu-id="257d9-138">All isolation levels supported for memory-optimized tables provide the read committed guarantee.</span></span> <span data-ttu-id="257d9-139">Por tanto, si la transacción no requiere garantías más sólidas, puede utilizar cualquiera de los niveles de aislamiento admitidos para las tablas optimizadas para memoria.</span><span class="sxs-lookup"><span data-stu-id="257d9-139">Therefore, if the transaction does not require stronger guarantees, you can use any of the isolation levels supported for memory-optimized tables.</span></span> <span data-ttu-id="257d9-140">SNAPSHOT utiliza la menor cantidad de recursos del sistema, en comparación con otros niveles de aislamiento.</span><span class="sxs-lookup"><span data-stu-id="257d9-140">SNAPSHOT uses the fewest system resources, compared to other isolation levels.</span></span>  
  
 <span data-ttu-id="257d9-141">La garantía que proporciona el nivel de aislamiento SNAPSHOT (el menor nivel de aislamiento que se admite en las tablas optimizadas para memoria) incluye las garantías de READ COMMITTED.</span><span class="sxs-lookup"><span data-stu-id="257d9-141">The guarantee provided by the SNAPSHOT isolation level (the lowest level of isolation supported for memory-optimized tables) includes the guarantees of READ COMMITTED.</span></span> <span data-ttu-id="257d9-142">Cada instrucción de la transacción lee la misma versión coherente de la base de datos.</span><span class="sxs-lookup"><span data-stu-id="257d9-142">Every statement in the transaction reads the same, consistent version of the database.</span></span> <span data-ttu-id="257d9-143">No solo todas las filas leídas por la transacción se confirman en la base de datos, sino que todas las operaciones de lectura ven el conjunto de cambios realizados por el mismo conjunto de transacciones.</span><span class="sxs-lookup"><span data-stu-id="257d9-143">Not only are all the rows read by the transaction committed to the database, also all the read operations see the set of changes made by the same set of transactions.</span></span>  
  
 <span data-ttu-id="257d9-144">**Directriz**: si solo se requiere la garantía de aislamiento de lectura confirmada, use el aislamiento de instantánea con procedimientos almacenados compilados de forma nativa y el acceso a tablas optimizadas para memoria mediante interpretado [!INCLUDE[tsql](../includes/tsql-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="257d9-144">**Guideline**: If only the READ COMMITTED isolation guarantee is required, use SNAPSHOT isolation with natively compiled stored procedures and for accessing memory-optimized tables through interpreted [!INCLUDE[tsql](../includes/tsql-md.md)].</span></span>  
  
 <span data-ttu-id="257d9-145">En las transacciones de confirmación automática, el nivel de aislamiento READ COMMITTED se asigna implícitamente en SNAPSHOT para las tablas optimizadas para memoria.</span><span class="sxs-lookup"><span data-stu-id="257d9-145">For autocommit transactions, the isolation level READ COMMITTED is implicitly mapped to SNAPSHOT for memory-optimized tables.</span></span> <span data-ttu-id="257d9-146">Por tanto, si la configuración de sesión TRANSACTION ISOLATION LEVEL se establece en READ COMMITTED, no es necesario especificar el nivel de aislamiento mediante una sugerencia de tabla al tener acceso a tablas optimizadas para memoria.</span><span class="sxs-lookup"><span data-stu-id="257d9-146">Therefore, if the TRANSACTION ISOLATION LEVEL session setting is set to READ COMMITTED, it is not necessary to specify the isolation level through a table hint when accessing memory-optimized tables.</span></span>  
  
 <span data-ttu-id="257d9-147">En el siguiente ejemplo de transacción de confirmación automática se muestra una combinación entre una tabla Customers optimizada para memoria y una tabla normal [Order History], como parte de un lote ad hoc:</span><span class="sxs-lookup"><span data-stu-id="257d9-147">The following autocommit transaction example shows a join between a memory-optimized table Customers and a regular table [Order History], as part of an ad hoc batch:</span></span>  
  
```sql  
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;  
GO  
SELECT *   
FROM dbo.Customers AS c   
LEFT JOIN dbo.[Order History] AS oh   
    ON c.customer_id = oh.customer_id;  
```  
  
 <span data-ttu-id="257d9-148">El siguiente ejemplo de transacciones implícitas o explícitas muestra la misma combinación, pero esta vez en una transacción de usuario explícita.</span><span class="sxs-lookup"><span data-stu-id="257d9-148">The following explicit or implicit transactions example shows the same join, but this time in an explicit user transaction.</span></span> <span data-ttu-id="257d9-149">Se tiene acceso a la tabla optimizada para memoria Customers con aislamiento de instantánea, según indica la sugerencia de tabla WITH (SNAPSHOT), y a la tabla normal [Order History] con aislamiento de lectura confirmada:</span><span class="sxs-lookup"><span data-stu-id="257d9-149">The memory-optimized table Customers is accessed under snapshot isolation, as indicated through the table hint WITH (SNAPSHOT), and the regular table [Order History] is accessed under read committed isolation:</span></span>  
  
```sql  
SET TRANSACTION ISOLATION LEVEL READ COMMITTED  
GO  
BEGIN TRAN  
SELECT * FROM dbo.Customers c with (SNAPSHOT)   
LEFT JOIN dbo.[Order History] oh   
    ON c.customer_id=oh.customer_id  
...  
COMMIT  
```  
  
### <a name="operational-differences"></a><span data-ttu-id="257d9-150">Diferencias operativas</span><span class="sxs-lookup"><span data-stu-id="257d9-150">Operational Differences</span></span>  
 <span data-ttu-id="257d9-151">Además de la garantía de lectura confirmada, también hay dos detalles de implementación de claves que las aplicaciones que usan tablas basadas en disco pueden emplear.</span><span class="sxs-lookup"><span data-stu-id="257d9-151">Besides the read committed guarantee, there are also two key implementation details that applications using disk-based tables may rely on.</span></span> <span data-ttu-id="257d9-152">Tenga en cuenta lo siguiente al convertir una tabla basada en disco a la que se tiene acceso con el aislamiento READ COMMITTED en una tabla optimizada para memoria a la que se tiene acceso con el aislamiento SNAPSHOT:</span><span class="sxs-lookup"><span data-stu-id="257d9-152">Be aware of the following when converting a disk-based table that is accessed using READ COMMITTED isolation to a memory-optimized table that is accessed using SNAPSHOT isolation:</span></span>  
  
-   <span data-ttu-id="257d9-153">La implementación del nivel de aislamiento READ COMMITTED para las tablas basadas en disco (suponiendo que READ_COMMITTED_SNAPSHOT es OFF) utiliza bloqueos para evitar conflictos entre los lectores y los escritores.</span><span class="sxs-lookup"><span data-stu-id="257d9-153">The implementation of the READ COMMITTED isolation level for disk-based tables (assuming READ_COMMITTED_SNAPSHOT is OFF) uses locks to prevent conflicts between readers and writers.</span></span> <span data-ttu-id="257d9-154">Cuando un escritor comienza a actualizar una fila, adopta un bloqueo y no lo libera hasta que la transacción se confirma.</span><span class="sxs-lookup"><span data-stu-id="257d9-154">When a writer starts updating a row, it takes a lock and does not release the lock until the transaction is committed.</span></span> <span data-ttu-id="257d9-155">Las operaciones de lectura están bloqueadas y esperarán hasta que las transacciones de escritura se confirmen.</span><span class="sxs-lookup"><span data-stu-id="257d9-155">Any read operations are blocked and will wait for the write transaction to commit.</span></span>  
  
     <span data-ttu-id="257d9-156">Algunas aplicaciones pueden suponer que los lectores siempre esperan hasta que los escritores confirmen la operación, especialmente si hay algún tipo de sincronización entre las dos transacciones en el nivel de aplicación.</span><span class="sxs-lookup"><span data-stu-id="257d9-156">Some applications may assume readers always wait for writers to commit, particularly if there is any synchronization between the two transactions in the application tier.</span></span>  
  
     <span data-ttu-id="257d9-157">**Directriz:** Las aplicaciones no pueden basarse en el comportamiento de bloqueo.</span><span class="sxs-lookup"><span data-stu-id="257d9-157">**Guideline:** Applications cannot rely on blocking behavior.</span></span> <span data-ttu-id="257d9-158">Si una aplicación necesita sincronización entre transacciones simultáneas, dicha lógica se puede implementar en la capa de aplicación o en el nivel de base de datos, a través de [sp_getapplock &#40;&#41;de Transact-SQL ](/sql/relational-databases/system-stored-procedures/sp-getapplock-transact-sql).</span><span class="sxs-lookup"><span data-stu-id="257d9-158">If an application needs synchronization between concurrent transactions, such logic can be implemented in the application tier or in the database tier, through [sp_getapplock &#40;Transact-SQL&#41;](/sql/relational-databases/system-stored-procedures/sp-getapplock-transact-sql).</span></span>  
  
-   <span data-ttu-id="257d9-159">En las transacciones que utilizan el aislamiento READ COMMITTED, cada instrucción ve la versión más reciente de las filas de la base de datos.</span><span class="sxs-lookup"><span data-stu-id="257d9-159">In transactions that use READ COMMITTED isolation, each statement sees the most recent version of the rows in the database.</span></span> <span data-ttu-id="257d9-160">Por consiguiente, las instrucciones posteriores ven los cambios en el estado de la base de datos.</span><span class="sxs-lookup"><span data-stu-id="257d9-160">Therefore, subsequent statements see changes in the state of the database.</span></span>  
  
     <span data-ttu-id="257d9-161">Sondear una tabla con un bucle WHILE hasta que se encuentra una nueva fila es un ejemplo de un patrón de aplicación que utiliza esta suposición.</span><span class="sxs-lookup"><span data-stu-id="257d9-161">Polling a table using a WHILE loop until a new row has been found is an example of an application pattern that uses this assumption.</span></span> <span data-ttu-id="257d9-162">Con cada iteración del bucle, la consulta verá las últimas actualizaciones de la base de datos.</span><span class="sxs-lookup"><span data-stu-id="257d9-162">With each iteration of the loop, the query will see the latest updates in the database.</span></span>  
  
     <span data-ttu-id="257d9-163">**Directriz:** Si una aplicación necesita sondear una tabla optimizada para memoria para obtener las filas más recientes escritas en la tabla, mueva el bucle de sondeo fuera del ámbito de la transacción.</span><span class="sxs-lookup"><span data-stu-id="257d9-163">**Guideline:** If an application needs to poll a memory-optimized table to obtain the most recent rows written to the table, move the polling loop outside the scope of the transaction.</span></span>  
  
     <span data-ttu-id="257d9-164">A continuación se muestra un patrón de aplicación de ejemplo que utiliza esta suposición.</span><span class="sxs-lookup"><span data-stu-id="257d9-164">The following is an example application pattern that uses this assumption.</span></span> <span data-ttu-id="257d9-165">Sondear una tabla con un bucle WHILE hasta encontrar una nueva fila.</span><span class="sxs-lookup"><span data-stu-id="257d9-165">Polling a table using a WHILE loop until a new row is found.</span></span> <span data-ttu-id="257d9-166">En cada iteración del bucle, la consulta tendrá acceso a las últimas actualizaciones de la base de datos.</span><span class="sxs-lookup"><span data-stu-id="257d9-166">In each loop iteration, the query will access the latest updates in the database.</span></span>  
  
 <span data-ttu-id="257d9-167">El siguiente script de ejemplo sondea la tabla t1 hasta que tiene una fila.</span><span class="sxs-lookup"><span data-stu-id="257d9-167">The following example script polls a table t1 until it has a row.</span></span> <span data-ttu-id="257d9-168">Después quita una sola fila de la tabla para su procesamiento posterior.</span><span class="sxs-lookup"><span data-stu-id="257d9-168">It then removes a single row from the table for further processing.</span></span>  
  
 <span data-ttu-id="257d9-169">Tenga en cuenta que la lógica de sondeo debe estar fuera del ámbito de la transacción, ya que utiliza aislamiento de instantánea para tener acceso a la tabla t1.</span><span class="sxs-lookup"><span data-stu-id="257d9-169">Notice that the polling logic needs to be outside the scope of the transaction, as it is using snapshot isolation to access table t1.</span></span> <span data-ttu-id="257d9-170">Si se usa lógica de sondeo en el ámbito de una transacción, se crearía una transacción de ejecución prolongada, que es una práctica incorrecta.</span><span class="sxs-lookup"><span data-stu-id="257d9-170">Using polling logic inside the scope of a transaction would create a long-running transaction, which is a bad practice.</span></span>  
  
```sql  
-- poll table  
WHILE NOT EXISTS (SELECT 1 FROM dbo.t1)  
BEGIN   
  -- if empty, wait and poll again  
  WAITFOR DELAY '00:00:01'  
END  
  
BEGIN TRANSACTION  
  DECLARE @id int  
  SELECT TOP 1 @id=id FROM dbo.t1 WITH (SNAPSHOT)  
  DELETE FROM dbo.t1 WITH (SNAPSHOT) WHERE id=@id  
  
  -- insert processing based on @id  
COMMIT  
```  
  
## <a name="locking-table-hints"></a><span data-ttu-id="257d9-171">Sugerencias de bloqueo de tabla</span><span class="sxs-lookup"><span data-stu-id="257d9-171">Locking Table Hints</span></span>  
 <span data-ttu-id="257d9-172">Las sugerencias de bloqueo ([sugerencias de tabla &#40;&#41;de Transact-SQL ](/sql/t-sql/queries/hints-transact-sql-table)) como HOLDLOCK y xlock se pueden usar con tablas basadas en disco para [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] tomar más bloqueos de los necesarios para el nivel de aislamiento especificado.</span><span class="sxs-lookup"><span data-stu-id="257d9-172">Locking hints ([Table Hints &#40;Transact-SQL&#41;](/sql/t-sql/queries/hints-transact-sql-table)) such as HOLDLOCK and XLOCK can be used with disk-based tables to have [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] take more locks than are required for the specified isolation level.</span></span>  
  
 <span data-ttu-id="257d9-173">Las tablas con optimización para memoria no usan bloqueos.</span><span class="sxs-lookup"><span data-stu-id="257d9-173">Memory-optimized tables do not use locks.</span></span> <span data-ttu-id="257d9-174">Se pueden usar niveles de aislamiento superiores como REPEATABLE READ y SERIALIZABLE para declarar las garantías deseadas.</span><span class="sxs-lookup"><span data-stu-id="257d9-174">Higher isolation levels such as REPEATABLE READ and SERIALIZABLE can be used to declare the desired guarantees.</span></span>  
  
 <span data-ttu-id="257d9-175">Las sugerencias de bloqueo no se admiten.</span><span class="sxs-lookup"><span data-stu-id="257d9-175">Locking hints are not supported.</span></span> <span data-ttu-id="257d9-176">En su lugar, declare las garantías necesarias a través de los niveles de aislamiento de transacción.</span><span class="sxs-lookup"><span data-stu-id="257d9-176">Instead, declare the required guarantees through the transaction isolation levels.</span></span> <span data-ttu-id="257d9-177">(Se admite NOLOCK porque [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] no adopta bloqueos en las tablas optimizadas para memoria.</span><span class="sxs-lookup"><span data-stu-id="257d9-177">(NOLOCK is supported because [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] does not take locks on memory-optimized tables.</span></span> <span data-ttu-id="257d9-178">Tenga en cuenta que, a diferencia de las tablas basadas en disco, NOLOCK no implica el comportamiento READ UNCOMMITTED para las tablas optimizadas para memoria).</span><span class="sxs-lookup"><span data-stu-id="257d9-178">Note that, in contrast to disk-based tables, NOLOCK does not imply READ UNCOMMITTED behavior for memory-optimized tables.)</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="257d9-179">Consulte también</span><span class="sxs-lookup"><span data-stu-id="257d9-179">See Also</span></span>  
 <span data-ttu-id="257d9-180">[Descripción de las transacciones en tablas optimizadas para memoria](../../2014/database-engine/understanding-transactions-on-memory-optimized-tables.md) </span><span class="sxs-lookup"><span data-stu-id="257d9-180">[Understanding Transactions on Memory-Optimized Tables](../../2014/database-engine/understanding-transactions-on-memory-optimized-tables.md) </span></span>  
 <span data-ttu-id="257d9-181">[Instrucciones para la lógica de reintento de transacciones en tablas optimizadas para memoria](../../2014/database-engine/guidelines-for-retry-logic-for-transactions-on-memory-optimized-tables.md) </span><span class="sxs-lookup"><span data-stu-id="257d9-181">[Guidelines for Retry Logic for Transactions on Memory-Optimized Tables](../../2014/database-engine/guidelines-for-retry-logic-for-transactions-on-memory-optimized-tables.md) </span></span>  
 [<span data-ttu-id="257d9-182">Niveles de aislamiento de transacción</span><span class="sxs-lookup"><span data-stu-id="257d9-182">Transaction Isolation Levels</span></span>](../../2014/database-engine/transaction-isolation-levels.md)  
  
  
