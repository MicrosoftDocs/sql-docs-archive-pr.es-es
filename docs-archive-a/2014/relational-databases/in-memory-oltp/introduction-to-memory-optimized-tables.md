---
title: Introducción a las tablas con optimización para memoria | Microsoft Docs
ms.custom: ''
ms.date: 07/14/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: in-memory-oltp
ms.topic: conceptual
ms.assetid: ef1cc7de-63be-4fa3-a622-6d93b440e3ac
author: rothja
ms.author: jroth
ms.openlocfilehash: edcdea9d266cf0ef231b1e16be4da7009372dcd6
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 08/04/2020
ms.locfileid: "87751001"
---
# <a name="introduction-to-memory-optimized-tables"></a><span data-ttu-id="86bd6-102">Introducción a las tablas con optimización para memoria</span><span class="sxs-lookup"><span data-stu-id="86bd6-102">Introduction to Memory-Optimized Tables</span></span>
  <span data-ttu-id="86bd6-103">Las tablas con optimización para memoria son tablas creadas por medio de [CREATE TABLE &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-table-transact-sql).</span><span class="sxs-lookup"><span data-stu-id="86bd6-103">Memory-optimized tables are tables, created using [CREATE TABLE &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-table-transact-sql).</span></span>  
  
 <span data-ttu-id="86bd6-104">Las tablas con optimización para memoria residen en la memoria.</span><span class="sxs-lookup"><span data-stu-id="86bd6-104">Memory-optimized tables reside in memory.</span></span> <span data-ttu-id="86bd6-105">Las filas de la tabla se leen y se escriben en la memoria.</span><span class="sxs-lookup"><span data-stu-id="86bd6-105">Rows in the table are read from and written to memory.</span></span> <span data-ttu-id="86bd6-106">Toda la tabla reside en memoria.</span><span class="sxs-lookup"><span data-stu-id="86bd6-106">The entire table resides in memory.</span></span> <span data-ttu-id="86bd6-107">Una segunda copia de los datos de la tabla se conserva en el disco pero solo por la durabilidad.</span><span class="sxs-lookup"><span data-stu-id="86bd6-107">A second copy of the table data is maintained on disk, but only for durability purposes.</span></span>  
  
 <span data-ttu-id="86bd6-108">OLTP en memoria está integrado con [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] para proporcionar una experiencia satisfactoria en todas las áreas como el desarrollo, la implementación, la facilidad de uso y la compatibilidad.</span><span class="sxs-lookup"><span data-stu-id="86bd6-108">In-Memory OLTP is integrated with [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] to provide a seamless experience in all areas such as development, deployment, manageability, and supportability.</span></span> <span data-ttu-id="86bd6-109">Una base de datos puede contener objetos en memoria y objetos basados en disco.</span><span class="sxs-lookup"><span data-stu-id="86bd6-109">A database can contain in-memory as well as disk-based objects.</span></span>  
  
 <span data-ttu-id="86bd6-110">Las tablas optimizadas para memoria son siempre con control de versiones.</span><span class="sxs-lookup"><span data-stu-id="86bd6-110">Rows in memory-optimized tables are versioned.</span></span> <span data-ttu-id="86bd6-111">Esto significa que cada fila de la tabla puede tener varias versiones.</span><span class="sxs-lookup"><span data-stu-id="86bd6-111">This means that each row in the table potentially has multiple versions.</span></span> <span data-ttu-id="86bd6-112">Todas las versiones de fila se mantienen en la misma estructura de datos de la tabla.</span><span class="sxs-lookup"><span data-stu-id="86bd6-112">All row versions are maintained in the same table data structure.</span></span> <span data-ttu-id="86bd6-113">El control de versiones de fila se utiliza para permitir las lecturas y las escrituras simultáneas en la misma fila.</span><span class="sxs-lookup"><span data-stu-id="86bd6-113">Row versioning is used to allow concurrent reads and writes on the same row.</span></span> <span data-ttu-id="86bd6-114">Para obtener más información sobre las lecturas y las escrituras simultáneas en la misma fila, vea [Transactions in Memory-Optimized Tables](memory-optimized-tables.md).</span><span class="sxs-lookup"><span data-stu-id="86bd6-114">For more information about concurrent reads and writes on the same row, see [Transactions in Memory-Optimized Tables](memory-optimized-tables.md).</span></span>  
  
 <span data-ttu-id="86bd6-115">La siguiente ilustración muestra la multiversión.</span><span class="sxs-lookup"><span data-stu-id="86bd6-115">The following figure illustrates multi-versioning.</span></span> <span data-ttu-id="86bd6-116">La ilustración muestra una tabla con tres filas y cada fila tiene versiones diferentes.</span><span class="sxs-lookup"><span data-stu-id="86bd6-116">The figure shows a table with three rows and each row has different versions.</span></span>  
  
 <span data-ttu-id="86bd6-117">![Multiversión.](../../database-engine/media/hekaton-tables-1.gif "Multiversión.")</span><span class="sxs-lookup"><span data-stu-id="86bd6-117">![Multi-versioning.](../../database-engine/media/hekaton-tables-1.gif "Multi-versioning.")</span></span>  
  
 <span data-ttu-id="86bd6-118">La tabla tiene tres filas: r1, r2 y r3.</span><span class="sxs-lookup"><span data-stu-id="86bd6-118">The table has three rows: r1, r2, and r3.</span></span> <span data-ttu-id="86bd6-119">r1 tiene tres versiones, r2 tiene dos versiones y r3 tiene cuatro.</span><span class="sxs-lookup"><span data-stu-id="86bd6-119">r1 has three versions, r2 has two versions, and r3 has four versions.</span></span> <span data-ttu-id="86bd6-120">Observe que las diferentes versiones de la misma fila no ocupan necesariamente ubicaciones de memoria consecutivas.</span><span class="sxs-lookup"><span data-stu-id="86bd6-120">Note that different versions of the same row do not necessarily occupy consecutive memory locations.</span></span> <span data-ttu-id="86bd6-121">Las diferentes versiones de fila pueden estar dispersas por la estructura de datos de la tabla.</span><span class="sxs-lookup"><span data-stu-id="86bd6-121">The different row versions can be dispersed throughout the table data structure.</span></span>  
  
 <span data-ttu-id="86bd6-122">La estructura de datos de una tabla optimizada para memoria se puede considerar como una colección de versiones de fila.</span><span class="sxs-lookup"><span data-stu-id="86bd6-122">The memory-optimized table data structure can be seen as a collection of row versions.</span></span> <span data-ttu-id="86bd6-123">Las filas de tablas basadas en disco se organizan en páginas y extensiones, las filas individuales se direccionan con el desplazamiento de página y número de página, y las versiones de fila de las tablas optimizadas para memoria se direccionan con punteros de memoria de 8 bytes.</span><span class="sxs-lookup"><span data-stu-id="86bd6-123">Rows in disk-based tables are organized in pages and extents, and individual rows addressed using page number and page offset, row versions in memory-optimized tables are addressed using 8-byte memory pointers.</span></span>  
  
## <a name="durability"></a><span data-ttu-id="86bd6-124">Durabilidad.</span><span class="sxs-lookup"><span data-stu-id="86bd6-124">Durability</span></span>  
 <span data-ttu-id="86bd6-125">De forma predeterminada, las tablas optimizadas para memoria son totalmente durables y, al igual que las transacciones en tablas basadas en disco (tradicionales), las transacciones totalmente durables en este tipo de tablas tienen todas las propiedades de atomicidad, coherencia, aislamiento y durabilidad (ACID).</span><span class="sxs-lookup"><span data-stu-id="86bd6-125">Memory-optimized tables are fully durable by default, and, like transactions on (traditional) disk-based tables, fully durable transactions on memory-optimized tables are fully atomic, consistent, isolated, and durable (ACID).</span></span> <span data-ttu-id="86bd6-126">Las tablas con optimización para memoria y los procedimientos almacenados compilados de forma nativa admiten un subconjunto de [!INCLUDE[tsql](../../../includes/tsql-md.md)].</span><span class="sxs-lookup"><span data-stu-id="86bd6-126">Memory-optimized tables and natively compiled stored procedures support a subset of [!INCLUDE[tsql](../../../includes/tsql-md.md)].</span></span>  
  
 <span data-ttu-id="86bd6-127">OLTP en memoria admite las tablas duraderas con durabilidad de transacciones retrasada.</span><span class="sxs-lookup"><span data-stu-id="86bd6-127">In-Memory OLTP supports durable tables with transaction durability delayed.</span></span> <span data-ttu-id="86bd6-128">Las transacciones duraderas retrasadas se guardan en el disco poco después de confirmarse la transacción.</span><span class="sxs-lookup"><span data-stu-id="86bd6-128">Delayed durable transactions are saved to disk soon after the transaction has committed.</span></span> <span data-ttu-id="86bd6-129">El rendimiento es mayor pero, a cambio, las transacciones confirmadas que no se guardaron en el disco se perderán en caso de bloqueo del servidor o conmutación por error.</span><span class="sxs-lookup"><span data-stu-id="86bd6-129">In exchange for the increased performance, committed transactions that have not saved to disk are lost in a server crash or failover.</span></span>  
  
 <span data-ttu-id="86bd6-130">Además de las tablas optimizadas para memoria durables predeterminadas, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] también admite tablas optimizadas para memoria no durables, que no se registran y cuyos datos no se guardan en el disco.</span><span class="sxs-lookup"><span data-stu-id="86bd6-130">Besides the default durable memory-optimized tables, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] also supports non-durable memory-optimized tables, which are not logged and their data is not persisted on disk.</span></span> <span data-ttu-id="86bd6-131">Esto significa que las transacciones en estas tablas no requieren ninguna E/S de disco, pero los datos no se recuperarán si hay un bloqueo o una conmutación por error del servidor.</span><span class="sxs-lookup"><span data-stu-id="86bd6-131">This means that transactions on these tables do not require any disk IO, but the data will not be recovered if there is a server crash or failover.</span></span>  
  
## <a name="accessing-data-in-memory-optimized-tables"></a><span data-ttu-id="86bd6-132">Acceso a datos en tablas con optimización para memoria</span><span class="sxs-lookup"><span data-stu-id="86bd6-132">Accessing Data in Memory-Optimized Tables</span></span>  
 <span data-ttu-id="86bd6-133">Se puede tener acceso a los datos de las tablas optimizadas para memoria de dos maneras:</span><span class="sxs-lookup"><span data-stu-id="86bd6-133">Data in memory-optimized tables is accessed in two ways:</span></span>  
  
-   <span data-ttu-id="86bd6-134">Con [!INCLUDE[tsql](../../../includes/tsql-md.md)] interpretado (fuera de un procedimiento almacenado compilado de forma nativa).</span><span class="sxs-lookup"><span data-stu-id="86bd6-134">Through interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] (outside of a natively-compiled stored procedure).</span></span> <span data-ttu-id="86bd6-135">Estas instrucciones de [!INCLUDE[tsql](../../../includes/tsql-md.md)] pueden ser procedimientos almacenados interpretados internamente o pueden ser instrucciones [!INCLUDE[tsql](../../../includes/tsql-md.md)] ad hoc.</span><span class="sxs-lookup"><span data-stu-id="86bd6-135">These [!INCLUDE[tsql](../../../includes/tsql-md.md)] statements may be either inside interpreted stored procedures or they may be ad-hoc [!INCLUDE[tsql](../../../includes/tsql-md.md)] statements.</span></span>  
  
-   <span data-ttu-id="86bd6-136">A través de procedimientos almacenados compilados de forma nativa.</span><span class="sxs-lookup"><span data-stu-id="86bd6-136">Through natively compiled stored procedures.</span></span>  
  
 <span data-ttu-id="86bd6-137">Se puede tener acceso a las tablas con optimización para memoria de forma más eficaz desde procedimientos almacenados compilados de forma nativa ([Procedimientos almacenados compilados de forma nativa](natively-compiled-stored-procedures.md)).</span><span class="sxs-lookup"><span data-stu-id="86bd6-137">Memory-optimized tables can be accessed most efficiently from natively compiled stored procedures ([Natively Compiled Stored Procedures](natively-compiled-stored-procedures.md)).</span></span> <span data-ttu-id="86bd6-138">Se puede tener acceso también a las tablas con optimización para memoria con [!INCLUDE[tsql](../../../includes/tsql-md.md)]interpretado (tradicional).</span><span class="sxs-lookup"><span data-stu-id="86bd6-138">Memory-optimized tables can also be accessed with (traditional) interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)].</span></span> <span data-ttu-id="86bd6-139">[!INCLUDE[tsql](../../../includes/tsql-md.md)] interpretado hace referencia al acceso a tablas optimizadas para memoria sin un procedimiento almacenado compilado de forma nativa.</span><span class="sxs-lookup"><span data-stu-id="86bd6-139">Interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] refers to accessing memory-optimized tables without a natively compiled stored procedure.</span></span> <span data-ttu-id="86bd6-140">Algunos ejemplos de acceso con [!INCLUDE[tsql](../../../includes/tsql-md.md)] interpretado son el acceso a una tabla optimizada para memoria desde un desencadenador DML, un lote ad hoc de [!INCLUDE[tsql](../../../includes/tsql-md.md)] , una vista y una función con valores de tabla.</span><span class="sxs-lookup"><span data-stu-id="86bd6-140">Some examples of interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] access include accessing a memory-optimized table from a DML trigger, ad hoc [!INCLUDE[tsql](../../../includes/tsql-md.md)] batch, view, and table-valued function.</span></span>  
  
 <span data-ttu-id="86bd6-141">En la tabla siguiente se resume el acceso con [!INCLUDE[tsql](../../../includes/tsql-md.md)] interpretado y nativo para varios objetos.</span><span class="sxs-lookup"><span data-stu-id="86bd6-141">The following table summarizes native and interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] access for various objects.</span></span>  
  
|<span data-ttu-id="86bd6-142">Característica</span><span class="sxs-lookup"><span data-stu-id="86bd6-142">Feature</span></span>|<span data-ttu-id="86bd6-143">Acceso con un procedimiento almacenado compilado de forma nativa</span><span class="sxs-lookup"><span data-stu-id="86bd6-143">Access Using a Natively Compiled Stored Procedure</span></span>|<span data-ttu-id="86bd6-144">Acceso con [!INCLUDE[tsql](../../../includes/tsql-md.md)] interpretado</span><span class="sxs-lookup"><span data-stu-id="86bd6-144">Interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] Access</span></span>|<span data-ttu-id="86bd6-145">Acceso CLR</span><span class="sxs-lookup"><span data-stu-id="86bd6-145">CLR Access</span></span>|  
|-------------|-------------------------------------------------------|-------------------------------------------|----------------|  
|<span data-ttu-id="86bd6-146">Tablas optimizadas para memoria</span><span class="sxs-lookup"><span data-stu-id="86bd6-146">Memory-optimized tables</span></span>|<span data-ttu-id="86bd6-147">Sí</span><span class="sxs-lookup"><span data-stu-id="86bd6-147">Yes</span></span>|<span data-ttu-id="86bd6-148">Sí</span><span class="sxs-lookup"><span data-stu-id="86bd6-148">Yes</span></span>|<span data-ttu-id="86bd6-149">No <sup>1</sup></span><span class="sxs-lookup"><span data-stu-id="86bd6-149">No <sup>1</sup></span></span>|  
|[<span data-ttu-id="86bd6-150">Variables de tabla con optimización para memoria</span><span class="sxs-lookup"><span data-stu-id="86bd6-150">Memory-Optimized Table Variables</span></span>](../../database-engine/memory-optimized-table-variables.md)|<span data-ttu-id="86bd6-151">Sí</span><span class="sxs-lookup"><span data-stu-id="86bd6-151">Yes</span></span>|<span data-ttu-id="86bd6-152">Sí</span><span class="sxs-lookup"><span data-stu-id="86bd6-152">Yes</span></span>|<span data-ttu-id="86bd6-153">No</span><span class="sxs-lookup"><span data-stu-id="86bd6-153">No</span></span>|  
|[<span data-ttu-id="86bd6-154">Procedimientos almacenados compilados de forma nativa</span><span class="sxs-lookup"><span data-stu-id="86bd6-154">Natively Compiled Stored Procedures</span></span>](https://msdn.microsoft.com/library/dn133184.aspx)|<span data-ttu-id="86bd6-155">No puede utilizar la instrucción EXECUTE para ejecutar un procedimiento almacenado desde un procedimiento almacenado compilado de forma nativa.</span><span class="sxs-lookup"><span data-stu-id="86bd6-155">You cannot use the EXECUTE statement to execute any stored procedure from a natively compiled stored procedure.</span></span>|<span data-ttu-id="86bd6-156">Sí</span><span class="sxs-lookup"><span data-stu-id="86bd6-156">Yes</span></span>|<span data-ttu-id="86bd6-157">No <sup>1</sup></span><span class="sxs-lookup"><span data-stu-id="86bd6-157">No <sup>1</sup></span></span>|  
  
 <span data-ttu-id="86bd6-158"><sup>1</sup> no puede tener acceso a una tabla optimizada para memoria o a un procedimiento almacenado compilado de forma nativa desde la conexión de contexto (la conexión de [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] al ejecutar un módulo CLR).</span><span class="sxs-lookup"><span data-stu-id="86bd6-158"><sup>1</sup> You cannot access a memory-optimized table or natively compiled stored procedure from the context connection (the connection from [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] when executing a CLR module).</span></span> <span data-ttu-id="86bd6-159">Sin embargo, puede crear y abrir otra conexión en la que pueda tener acceso a las tablas optimizadas para memoria y a los procedimientos almacenados compilados de forma nativa.</span><span class="sxs-lookup"><span data-stu-id="86bd6-159">You can, however, create and open another connection from which you can access memory-optimized tables and natively compiled stored procedures.</span></span> <span data-ttu-id="86bd6-160">Para obtener más información, vea [conexiones regulares frente a contextos](../clr-integration/data-access/context-connections-vs-regular-connections.md).</span><span class="sxs-lookup"><span data-stu-id="86bd6-160">For more information, see [Regular vs. Context Connections](../clr-integration/data-access/context-connections-vs-regular-connections.md).</span></span>  
  
## <a name="performance-and-scalability"></a><span data-ttu-id="86bd6-161">Escalabilidad y rendimiento</span><span class="sxs-lookup"><span data-stu-id="86bd6-161">Performance and Scalability</span></span>  
 <span data-ttu-id="86bd6-162">Los siguientes factores afectarán a las mejoras del rendimiento que se pueden lograr con OLTP en memoria:</span><span class="sxs-lookup"><span data-stu-id="86bd6-162">The following factors will affect the performance gains that can be achieved with In-Memory OLTP:</span></span>  
  
 <span data-ttu-id="86bd6-163">Comunicación</span><span class="sxs-lookup"><span data-stu-id="86bd6-163">Communication</span></span>  
 <span data-ttu-id="86bd6-164">Una aplicación que realiza muchas llamadas a procedimientos almacenados cortos puede suponer un aumento del rendimiento menor en comparación con una aplicación que realiza menos llamadas e implementa más funcionalidad en cada procedimiento almacenado.</span><span class="sxs-lookup"><span data-stu-id="86bd6-164">An application with many calls to short stored procedures may see a smaller performance gain compared to an application with fewer calls and more functionality implemented in each stored procedure.</span></span>  
  
 [!INCLUDE[tsql](../../../includes/tsql-md.md)] <span data-ttu-id="86bd6-165">Ejecución</span><span class="sxs-lookup"><span data-stu-id="86bd6-165">Execution</span></span>  
 <span data-ttu-id="86bd6-166">OLTP en memoria alcanza el máximo rendimiento cuando se usan procedimientos almacenados compilados de forma nativa en lugar de procedimientos almacenados interpretados o de ejecución de consultas.</span><span class="sxs-lookup"><span data-stu-id="86bd6-166">In-Memory OLTP achieves the best performance when using natively compiled stored procedures rather than interpreted stored procedures or query execution.</span></span> <span data-ttu-id="86bd6-167">Los procedimientos almacenados que ejecutan otros procedimientos almacenados no se pueden compilar de forma nativa, pero puede resultar beneficioso el acceso a tablas optimizadas para memoria desde estos procedimientos.</span><span class="sxs-lookup"><span data-stu-id="86bd6-167">Stored procedures that execute other stored procedures cannot be natively compiled, but there can be a benefit to accessing memory-optimized tables from such stored procedures.</span></span>  
  
 <span data-ttu-id="86bd6-168">Examen de intervalo y búsqueda de puntos</span><span class="sxs-lookup"><span data-stu-id="86bd6-168">Range Scan vs Point Lookup</span></span>  
 <span data-ttu-id="86bd6-169">Los índices no clúster con optimización para memoria admiten los exámenes de intervalo y los exámenes ordenados.</span><span class="sxs-lookup"><span data-stu-id="86bd6-169">Memory-optimized nonclustered indexes support range scans and ordered scans.</span></span> <span data-ttu-id="86bd6-170">Para las búsquedas de puntos, los índices hash optimizados para memoria tienen mejor rendimiento que los índices no clúster optimizados para memoria.</span><span class="sxs-lookup"><span data-stu-id="86bd6-170">For point lookups, memory-optimized hash indexes have better performance than memory-optimized nonclustered indexes.</span></span> <span data-ttu-id="86bd6-171">Los índices no clúster con optimización para memoria tienen mejor rendimiento que los índices basados en disco.</span><span class="sxs-lookup"><span data-stu-id="86bd6-171">Memory-optimized nonclustered indexes have better performance than disk-based indexes.</span></span>  
  
 <span data-ttu-id="86bd6-172">Las operaciones de índice no se registran y solo existen en memoria.</span><span class="sxs-lookup"><span data-stu-id="86bd6-172">Index operations are not logged and they exist only in memory.</span></span>  
  
 <span data-ttu-id="86bd6-173">Simultaneidad</span><span class="sxs-lookup"><span data-stu-id="86bd6-173">Concurrency</span></span>  
 <span data-ttu-id="86bd6-174">Las aplicaciones cuyo rendimiento se ve afectado por la simultaneidad del nivel de motor, como la contención de bloqueos temporales o el bloqueo, mejoran significativamente cuando se pasan a OLTP en memoria.</span><span class="sxs-lookup"><span data-stu-id="86bd6-174">Applications whose performance is affected by engine-level concurrency, such as latch contention or blocking, improves significantly when the application moves to In-Memory OLTP.</span></span>  
  
 <span data-ttu-id="86bd6-175">En la tabla siguiente se enumeran los problemas de rendimiento y escalabilidad que se suelen encontrar en las bases de datos relacionales y el modo en que OLTP en memoria puede mejorar el rendimiento.</span><span class="sxs-lookup"><span data-stu-id="86bd6-175">The following table lists the performance and scalability issues that are commonly found in relational databases and how In-Memory OLTP can improve performance.</span></span>  
  
|<span data-ttu-id="86bd6-176">Incidencia</span><span class="sxs-lookup"><span data-stu-id="86bd6-176">Issue</span></span>|<span data-ttu-id="86bd6-177">Impacto de OLTP en memoria</span><span class="sxs-lookup"><span data-stu-id="86bd6-177">In-Memory OLTP Impact</span></span>|  
|-----------|----------------------------|  
|<span data-ttu-id="86bd6-178">Rendimiento</span><span class="sxs-lookup"><span data-stu-id="86bd6-178">Performance</span></span><br /><br /> <span data-ttu-id="86bd6-179">Uso elevado de los recursos (CPU, E/S, red o memoria).</span><span class="sxs-lookup"><span data-stu-id="86bd6-179">High resource (CPU, I/O, network or memory) usage.</span></span>|<span data-ttu-id="86bd6-180">CPU</span><span class="sxs-lookup"><span data-stu-id="86bd6-180">CPU</span></span><br /> <span data-ttu-id="86bd6-181">Los procedimientos almacenados compilados de forma nativa pueden reducir el uso de la CPU de forma significativa porque requieren muchas menos instrucciones para ejecutar una instrucción de [!INCLUDE[tsql](../../../includes/tsql-md.md)] si se compara con los procedimientos almacenados interpretados.</span><span class="sxs-lookup"><span data-stu-id="86bd6-181">Natively compiled stored procedures can lower CPU usage significantly because they require significantly fewer instructions to execute a [!INCLUDE[tsql](../../../includes/tsql-md.md)] statement compared to interpreted stored procedures.</span></span><br /><br /> <span data-ttu-id="86bd6-182">OLTP en memoria puede ayudar a reducir la inversión en hardware en las cargas de trabajo con escalado horizontal, ya que un servidor podría ofrecer el rendimiento de entre cinco y diez servidores.</span><span class="sxs-lookup"><span data-stu-id="86bd6-182">In-Memory OLTP can help reduce the hardware investment in scaled-out workloads because one server can potentially deliver the throughput of five to ten servers.</span></span><br /><br /> <span data-ttu-id="86bd6-183">E/S</span><span class="sxs-lookup"><span data-stu-id="86bd6-183">I/O</span></span><br /> <span data-ttu-id="86bd6-184">Si encuentra un cuello de botella de E/S desde el procesamiento hasta las páginas de datos o de índices, OLTP en memoria puede reducir el cuello de botella.</span><span class="sxs-lookup"><span data-stu-id="86bd6-184">If you encounter an I/O bottleneck from processing to data or index pages, In-Memory OLTP may reduce the bottleneck.</span></span> <span data-ttu-id="86bd6-185">Además, la comprobación de los objetos de OLTP en memoria es continua y no produce incrementos súbitos de las operaciones de E/S.</span><span class="sxs-lookup"><span data-stu-id="86bd6-185">Additionally, the checkpointing of In-Memory OLTP objects is continuous and does not lead to sudden increases in I/O operations.</span></span> <span data-ttu-id="86bd6-186">Sin embargo, si el espacio de trabajo de las tablas de rendimiento crítico no cabe en la memoria, OLTP en memoria no mejorará el rendimiento porque requiere que los datos residan en la memoria.</span><span class="sxs-lookup"><span data-stu-id="86bd6-186">However, if the working set of the performance critical tables does not fit in memory, In-Memory OLTP will not improve performance because it requires data to be memory resident.</span></span> <span data-ttu-id="86bd6-187">Si encuentra un cuello de botella de E/S en el registro, OLTP en memoria puede reducirlo porque realiza menos tareas de registro.</span><span class="sxs-lookup"><span data-stu-id="86bd6-187">If you encounter an I/O bottleneck in logging, In-Memory OLTP can reduce the bottleneck because it does less logging.</span></span> <span data-ttu-id="86bd6-188">Si una o más tablas optimizadas para memoria se configuran como tablas no durables, puede eliminar el registro de los datos.</span><span class="sxs-lookup"><span data-stu-id="86bd6-188">If one or more memory-optimized tables are configured as non-durable tables, you can eliminate logging for data.</span></span><br /><br /> <span data-ttu-id="86bd6-189">Memoria</span><span class="sxs-lookup"><span data-stu-id="86bd6-189">Memory</span></span><br /> <span data-ttu-id="86bd6-190">OLTP en memoria no proporciona ninguna ventaja de rendimiento.</span><span class="sxs-lookup"><span data-stu-id="86bd6-190">In-Memory OLTP does not offer any performance benefit.</span></span> <span data-ttu-id="86bd6-191">OLTP en memoria puede suponer una presión adicional sobre la memoria, ya que los objetos deben residir en la memoria.</span><span class="sxs-lookup"><span data-stu-id="86bd6-191">In-Memory OLTP can put extra pressure on memory as the objects need to be memory resident.</span></span><br /><br /> <span data-ttu-id="86bd6-192">Red</span><span class="sxs-lookup"><span data-stu-id="86bd6-192">Network</span></span><br /> <span data-ttu-id="86bd6-193">OLTP en memoria no proporciona ninguna ventaja de rendimiento.</span><span class="sxs-lookup"><span data-stu-id="86bd6-193">In-Memory OLTP does not offer any performance benefit.</span></span> <span data-ttu-id="86bd6-194">Los datos tienen que comunicarse desde la capa de datos en el nivel de aplicación.</span><span class="sxs-lookup"><span data-stu-id="86bd6-194">The data needs to be communicated from data tier to application tier.</span></span>|  
|<span data-ttu-id="86bd6-195">Escalabilidad</span><span class="sxs-lookup"><span data-stu-id="86bd6-195">Scalability</span></span><br /><br /> <span data-ttu-id="86bd6-196">La mayoría de los problemas de escala de las aplicaciones de [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] son causados por problemas de simultaneidad como la contención de bloqueos, bloqueos temporales y bloqueos por subproceso.</span><span class="sxs-lookup"><span data-stu-id="86bd6-196">Most scaling issues in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] applications are caused by concurrency issues such as contention in locks, latches, and spinlocks.</span></span>|<span data-ttu-id="86bd6-197">Contención de bloqueos temporales</span><span class="sxs-lookup"><span data-stu-id="86bd6-197">Latch Contention</span></span><br /> <span data-ttu-id="86bd6-198">Un escenario típico es la contención en la última página de un índice al insertar filas simultáneamente en el orden de clave.</span><span class="sxs-lookup"><span data-stu-id="86bd6-198">A typical scenario is contention on the last page of an index when inserting rows concurrently in key order.</span></span> <span data-ttu-id="86bd6-199">Dado que OLTP en memoria no adopta bloqueos temporales para tener acceso a los datos, los problemas de escalabilidad relacionados con las contenciones de bloqueos temporales desaparecen por completo.</span><span class="sxs-lookup"><span data-stu-id="86bd6-199">Because In-Memory OLTP does not take latches when accessing data, the scalability issues related to latch contentions are fully removed.</span></span><br /><br /> <span data-ttu-id="86bd6-200">Contención de bloqueo por subproceso</span><span class="sxs-lookup"><span data-stu-id="86bd6-200">Spinlock Contention</span></span><br /> <span data-ttu-id="86bd6-201">Dado que OLTP en memoria no adopta bloqueos temporales para tener acceso a los datos, los problemas de escalabilidad relacionados con las contenciones de bloqueos por subproceso desaparecen por completo.</span><span class="sxs-lookup"><span data-stu-id="86bd6-201">Because In-Memory OLTP does not take latches when accessing data, the scalability issues related to spinlock contentions are fully removed.</span></span><br /><br /> <span data-ttu-id="86bd6-202">Contención relacionada con el bloqueo</span><span class="sxs-lookup"><span data-stu-id="86bd6-202">Locking Related Contention</span></span><br /> <span data-ttu-id="86bd6-203">Si la aplicación de base de datos encuentra problemas de bloqueo entre las operaciones de lectura y escritura, OLTP en memoria evita dichos problemas porque usa un nuevo formato de control de simultaneidad optimista para implementar todos los niveles de aislamiento de las transacciones.</span><span class="sxs-lookup"><span data-stu-id="86bd6-203">If your database application encounters blocking issues between read and write operations, In-Memory OLTP removes the blocking issues because it uses a new form of optimistic concurrency control to implement all transaction isolation levels.</span></span> <span data-ttu-id="86bd6-204">OLTP en memoria no usa TempDB para almacenar las versiones de fila.</span><span class="sxs-lookup"><span data-stu-id="86bd6-204">In-Memory OLTP does not use TempDB to store row versions.</span></span><br /><br /> <span data-ttu-id="86bd6-205">Si el problema de escala se debe al conflicto entre dos operaciones de escritura, como dos transacciones simultáneas que intenten actualizar la misma fila, OLTP en memoria permite que una transacción sea correcta y que la otra dé error.</span><span class="sxs-lookup"><span data-stu-id="86bd6-205">If the scaling issue is caused by conflict between two write operations, such as two concurrent transactions trying to update the same row, In-Memory OLTP lets one transaction succeed and fails the other transaction.</span></span> <span data-ttu-id="86bd6-206">La transacción errónea debe volver a enviarse ya sea de forma explícita o implícita, volviendo a intentar la transacción.</span><span class="sxs-lookup"><span data-stu-id="86bd6-206">The failed transaction must be re-submitted either explicitly or implicitly, re-trying the transaction.</span></span> <span data-ttu-id="86bd6-207">En cualquier caso, debe realizar cambios en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="86bd6-207">In either case, you need to make changes to the application.</span></span><br /><br /> <span data-ttu-id="86bd6-208">Si la aplicación experimenta conflictos frecuentes entre dos operaciones de escritura, el valor de bloqueo optimista se reduce.</span><span class="sxs-lookup"><span data-stu-id="86bd6-208">If your application experiences frequent conflicts between two write operations, the value of optimistic locking is diminished.</span></span> <span data-ttu-id="86bd6-209">La aplicación no es adecuada para OLTP en memoria.</span><span class="sxs-lookup"><span data-stu-id="86bd6-209">The application is not suitable for In-Memory OLTP.</span></span> <span data-ttu-id="86bd6-210">La mayoría de las aplicaciones OLTP no tienen conflictos de escritura a menos que el conflicto sea inducido por la extensión de bloqueo.</span><span class="sxs-lookup"><span data-stu-id="86bd6-210">Most OLTP applications don't have a write conflicts unless the conflict is induced by lock escalation.</span></span>|  
  
## <a name="see-also"></a><span data-ttu-id="86bd6-211">Consulte también</span><span class="sxs-lookup"><span data-stu-id="86bd6-211">See Also</span></span>  
 [<span data-ttu-id="86bd6-212">OLTP en memoria &#40;optimización en memoria&#41;</span><span class="sxs-lookup"><span data-stu-id="86bd6-212">In-Memory OLTP &#40;In-Memory Optimization&#41;</span></span>](in-memory-oltp-in-memory-optimization.md)  
  
  
