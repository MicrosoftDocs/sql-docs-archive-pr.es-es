---
title: Restaurar y recuperar tablas con optimización para memoria | Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: in-memory-oltp
ms.topic: conceptual
ms.assetid: 294975b7-e7d1-491b-b66a-fdb1100d2acc
author: CarlRabeler
ms.author: carlrab
ms.openlocfilehash: 5e702798ea68745a038407fb65af7726a5c5d50e
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 08/04/2020
ms.locfileid: "87675368"
---
# <a name="restore-and-recovery-of-memory-optimized-tables"></a><span data-ttu-id="858d9-102">Restaurar y recuperar tablas con optimización para memoria</span><span class="sxs-lookup"><span data-stu-id="858d9-102">Restore and Recovery of Memory-Optimized Tables</span></span>
  <span data-ttu-id="858d9-103">El mecanismo básico para recuperar o restaurar una base de datos con tablas optimizadas para memoria es similar al de las bases de datos con solo tablas basadas en disco.</span><span class="sxs-lookup"><span data-stu-id="858d9-103">The basic mechanism to recover or restore a database with memory-optimized tables is similar to databases with only disk-based tables.</span></span> <span data-ttu-id="858d9-104">Pero a diferencia de las tablas basadas en disco, las tablas optimizadas para memoria deben cargarse en memoria antes de que la base de datos esté disponible para el acceso de usuario.</span><span class="sxs-lookup"><span data-stu-id="858d9-104">But unlike disk-based tables, memory-optimized tables must be loaded into memory before database is available for user access.</span></span> <span data-ttu-id="858d9-105">Esto agrega un nuevo paso en la recuperación de la base de datos.</span><span class="sxs-lookup"><span data-stu-id="858d9-105">This adds a new step in the database recovery.</span></span> <span data-ttu-id="858d9-106">Los pasos modificados en la recuperación de base de datos cambian de este modo:</span><span class="sxs-lookup"><span data-stu-id="858d9-106">The modified steps in database recovery are changed as follows:</span></span>

 <span data-ttu-id="858d9-107">Cuando se reinicia [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] , cada base de datos pasa por una fase de recuperación que consta de las tres fases siguientes:</span><span class="sxs-lookup"><span data-stu-id="858d9-107">When the [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] restarts, each database goes through a recovery phase that consists of the following three phases:</span></span>

1.  <span data-ttu-id="858d9-108">La fase de análisis.</span><span class="sxs-lookup"><span data-stu-id="858d9-108">The analysis phase.</span></span> <span data-ttu-id="858d9-109">Durante esta fase, se realiza un paso en los registros de transacciones activos para detectar las transacciones confirmadas y no confirmadas.</span><span class="sxs-lookup"><span data-stu-id="858d9-109">During this phase, a pass is made on the active transaction logs to detect committed and uncommitted transactions.</span></span> <span data-ttu-id="858d9-110">El motor de OLTP en memoria identifica el punto de comprobación que se va a cargar y carga previamente sus entradas de registro de la tabla del sistema.</span><span class="sxs-lookup"><span data-stu-id="858d9-110">The In-Memory OLTP engine identifies the checkpoint to load and preloads its system table log entries.</span></span> <span data-ttu-id="858d9-111">También procesará algunas entradas del registro de asignación de archivos.</span><span class="sxs-lookup"><span data-stu-id="858d9-111">It will also process some file allocation log records.</span></span>

2.  <span data-ttu-id="858d9-112">La fase de rehacer.</span><span class="sxs-lookup"><span data-stu-id="858d9-112">The redo phase.</span></span> <span data-ttu-id="858d9-113">Esta fase se ejecuta simultáneamente en tablas basadas en disco y en tablas optimizadas para memoria.</span><span class="sxs-lookup"><span data-stu-id="858d9-113">This phase is run concurrently on both disk-based and memory-optimized tables.</span></span>

     <span data-ttu-id="858d9-114">Para las tablas basadas en disco, la base de datos se mueve al punto actual en el tiempo y adquiere los bloqueos obtenidos por las transacciones no confirmadas.</span><span class="sxs-lookup"><span data-stu-id="858d9-114">For disk-based tables, the database is moved to the current point in time and acquires locks taken by uncommitted transactions.</span></span>

     <span data-ttu-id="858d9-115">Para las tablas optimizadas para memoria, los datos de los pares de archivos delta y de datos se cargan en memoria y luego se actualizan los datos con el registro de transacciones activo en función del último punto de comprobación durable.</span><span class="sxs-lookup"><span data-stu-id="858d9-115">For memory-optimized tables, data from the data and delta file pairs are loaded into memory and then update the data with the active transaction log based on the last durable checkpoint.</span></span>

     <span data-ttu-id="858d9-116">Cuando las operaciones anteriores en las tablas optimizadas para memoria y las basadas en disco se completan, la base de datos está disponible para su acceso.</span><span class="sxs-lookup"><span data-stu-id="858d9-116">When the above operations on disk-based and memory-optimized tables are complete, the database is available for access.</span></span>

3.  <span data-ttu-id="858d9-117">La fase de deshacer.</span><span class="sxs-lookup"><span data-stu-id="858d9-117">The undo phase.</span></span> <span data-ttu-id="858d9-118">En esta fase, las transacciones no confirmadas se revierten.</span><span class="sxs-lookup"><span data-stu-id="858d9-118">In this phase, the uncommitted transactions are rolled back.</span></span>

 <span data-ttu-id="858d9-119">Cargar en memoria las tablas optimizadas para memoria puede afectar el rendimiento del objetivo de tiempo de recuperación (RTO).</span><span class="sxs-lookup"><span data-stu-id="858d9-119">Loading memory-optimized tables into memory can affect performance of the recovery time objective (RTO).</span></span> <span data-ttu-id="858d9-120">Para mejorar el tiempo de carga de los datos optimizados para memoria de los archivos delta y de datos, el motor de OLTP en memoria carga los archivos delta y de datos en paralelo como se indica a continuación:</span><span class="sxs-lookup"><span data-stu-id="858d9-120">To improve the load time of memory-optimized data from data and delta files, the In-Memory OLTP engine loads the data/delta files in parallel as follows:</span></span>

-   <span data-ttu-id="858d9-121">Crear un filtro de mapas de delta.</span><span class="sxs-lookup"><span data-stu-id="858d9-121">Creating a Delta Map Filter.</span></span> <span data-ttu-id="858d9-122">Los archivos delta almacenan las referencias a las filas eliminadas.</span><span class="sxs-lookup"><span data-stu-id="858d9-122">Delta files store references to the deleted rows.</span></span> <span data-ttu-id="858d9-123">Un subproceso por contenedor lee los archivos delta y crea un filtro de mapas de delta.</span><span class="sxs-lookup"><span data-stu-id="858d9-123">One thread per container reads the delta files and creates a delta map filter.</span></span> <span data-ttu-id="858d9-124">(Un grupo de archivos de datos con optimización para memoria puede tener uno o varios contenedores).</span><span class="sxs-lookup"><span data-stu-id="858d9-124">(A memory optimized data filegroup can have one or more containers.)</span></span>

-   <span data-ttu-id="858d9-125">Transmitir los archivos de datos.</span><span class="sxs-lookup"><span data-stu-id="858d9-125">Streaming the data files.</span></span>  <span data-ttu-id="858d9-126">Una vez creado el filtro de mapas de delta, se leen los archivos de datos utilizando tantos subprocesos como CPU lógicas haya.</span><span class="sxs-lookup"><span data-stu-id="858d9-126">Once the delta-map filter is created, data files are read using as many threads as there are logical CPUs.</span></span> <span data-ttu-id="858d9-127">Cada subproceso que lee el archivo de datos lee las filas de datos, comprueba el mapa de delta asociado e inserta únicamente la fila en la tabla si esta fila no se ha marcado como eliminada.</span><span class="sxs-lookup"><span data-stu-id="858d9-127">Each thread reading the data file reads the data rows, checks the associated delta map and only inserts the row into table if this row has not been marked deleted.</span></span> <span data-ttu-id="858d9-128">Esta parte de la recuperación puede estar limitada por la CPU en algunos casos como se indica a continuación.</span><span class="sxs-lookup"><span data-stu-id="858d9-128">This part of recovery can be CPU bound in some cases as noted below.</span></span>

 <span data-ttu-id="858d9-129">![Tablas con optimización para memoria.](../../database-engine/media/memory-optimized-tables.gif "Tablas optimizadas para memoria.")</span><span class="sxs-lookup"><span data-stu-id="858d9-129">![Memory-optimized tables.](../../database-engine/media/memory-optimized-tables.gif "Memory-optimized tables.")</span></span>

 <span data-ttu-id="858d9-130">Las tablas con optimización para memoria se pueden cargar normalmente en memoria a la velocidad de E/S pero hay casos que al cargar las filas de datos en memoria será más lento.</span><span class="sxs-lookup"><span data-stu-id="858d9-130">Memory-optimized tables can generally be loaded into memory at the speed of I/O but there are cases when loading data rows into memory will be slower.</span></span> <span data-ttu-id="858d9-131">Los casos específicos son:</span><span class="sxs-lookup"><span data-stu-id="858d9-131">Specific cases are:</span></span>

-   <span data-ttu-id="858d9-132">Un número bajo de cubos para el índice de hash puede llevar a una colisión excesiva con lo que la inserción de filas de datos será más lenta.</span><span class="sxs-lookup"><span data-stu-id="858d9-132">Low bucket count for hash index can lead to excessive collision causing data row inserts to be slower.</span></span> <span data-ttu-id="858d9-133">Esto produce normalmente un uso de CPU muy elevado en su totalidad, sobre todo al final de la recuperación.</span><span class="sxs-lookup"><span data-stu-id="858d9-133">This generally results in very high CPU utilization throughout, and especially towards the end of recovery.</span></span> <span data-ttu-id="858d9-134">Si ha configurado el índice de hash correctamente, no debería afectar el tiempo de recuperación.</span><span class="sxs-lookup"><span data-stu-id="858d9-134">If you configured the hash index correctly, it should not impact the recovery time.</span></span>

-   <span data-ttu-id="858d9-135">En tablas de gran tamaño optimizadas para memoria y con uno o varios índices no clúster (a diferencia de un índice de hash, cuyo número de cubos se establece en el momento de la creación), los índices no clúster aumentan dinámicamente, lo que da lugar a un uso elevado de la CPU.</span><span class="sxs-lookup"><span data-stu-id="858d9-135">Large memory-optimized tables with one or more nonclustered indexes, unlike a hash index whose bucket count is sized at create time, the nonclustered indexes grow dynamically, resulting in high CPU utilization.</span></span>

## <a name="restoring-a-database-with-memory-optimized-tables"></a><span data-ttu-id="858d9-136">Restaurar una base de datos con tablas con optimización para memoria</span><span class="sxs-lookup"><span data-stu-id="858d9-136">Restoring a Database with Memory-optimized tables</span></span>
 <span data-ttu-id="858d9-137">Sabe que tiene memoria suficiente en el servidor para restaurar una base de datos, pero hay un requisito de que la memoria necesaria para la base de datos se tenga en cuenta como parte de un grupo de recursos existente.</span><span class="sxs-lookup"><span data-stu-id="858d9-137">You know that you have sufficient memory on the server to restore a database, but there's a requirement  that the memory needed by the database is accounted for as part of an existing Resource Pool.</span></span>  <span data-ttu-id="858d9-138">Sabe que no se puede crear el enlace al grupo de recursos antes de que exista la base de datos, por lo que realiza la restauración WITH NORECOVERY.</span><span class="sxs-lookup"><span data-stu-id="858d9-138">You know that you cannot create the binding to the resource pool before the database exists, so you perform the restore WITH NORECOVERY.</span></span>  <span data-ttu-id="858d9-139">Esto hace que la imagen de disco de la base de datos se restaure y se cree la base de datos, pero no se consume memoria de OLTP en memoria debido a que la base de datos no se pone en línea.</span><span class="sxs-lookup"><span data-stu-id="858d9-139">This causes the disk image of the database to be restored and the database to be created, but no In-Memory OLTP memory is consumed because the database is not brought online.</span></span>

 <span data-ttu-id="858d9-140">En este punto, puede crear el grupo de recursos para el enlace de la base de datos y luego usar RESTORE WITH RECOVERY para poner en línea la base de datos restaurada.</span><span class="sxs-lookup"><span data-stu-id="858d9-140">At this point, you can create the Resource Pool to Database binding, and then use RESTORE WITH RECOVERY to bring the restored database online.</span></span>  <span data-ttu-id="858d9-141">Dado que el enlace se coloca antes de poner en línea la base de datos, su consumo de memoria de OLTP en memoria se tiene en cuenta correctamente.</span><span class="sxs-lookup"><span data-stu-id="858d9-141">Since the binding is in place before the database is brought online, its In-Memory OLTP memory consumption is properly accounted for.</span></span> <span data-ttu-id="858d9-142">Esto requiere restaurar la base de datos solo una vez.</span><span class="sxs-lookup"><span data-stu-id="858d9-142">This requires restoring the database only once.</span></span> <span data-ttu-id="858d9-143">El primer comando RESTORE es un comando informativo que solo lee el encabezado de copia de seguridad y el último comando solo desencadena una recuperación sin restaurar realmente ningún bit.</span><span class="sxs-lookup"><span data-stu-id="858d9-143">The first RESTORE command is an informational command that only reads the backup header, and the last command simply triggers recovery without actually restoring any bits.</span></span>

## <a name="see-also"></a><span data-ttu-id="858d9-144">Consulte también</span><span class="sxs-lookup"><span data-stu-id="858d9-144">See Also</span></span>
 [<span data-ttu-id="858d9-145">Hacer copia de seguridad, restaurar y recuperar tablas con optimización para memoria</span><span class="sxs-lookup"><span data-stu-id="858d9-145">Backup, Restore, and Recovery of Memory-Optimized Tables</span></span>](memory-optimized-tables.md)


