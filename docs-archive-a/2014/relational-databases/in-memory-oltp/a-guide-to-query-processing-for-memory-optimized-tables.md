---
title: Guía del procesamiento de consultas para tablas con optimización para memoria | Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: in-memory-oltp
ms.topic: conceptual
ms.assetid: 065296fe-6711-4837-965e-252ef6c13a0f
author: rothja
ms.author: jroth
ms.openlocfilehash: 93489e5dea295964826005e081bcffe889cb7586
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 08/04/2020
ms.locfileid: "87675869"
---
# <a name="a-guide-to-query-processing-for-memory-optimized-tables"></a><span data-ttu-id="bb997-102">Guía del procesamiento de consultas para tablas con optimización para memoria</span><span class="sxs-lookup"><span data-stu-id="bb997-102">A Guide to Query Processing for Memory-Optimized Tables</span></span>
  <span data-ttu-id="bb997-103">OLTP en memoria incluye en [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] los procedimientos almacenados compilados de forma nativa y las tablas optimizadas para memoria.</span><span class="sxs-lookup"><span data-stu-id="bb997-103">In-Memory OLTP introduces memory-optimized tables and natively compiled stored procedures in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="bb997-104">Este artículo proporciona información general del procesamiento de consultas tanto para las tablas optimizadas para memoria como para los procedimientos almacenados compilados de forma nativa.</span><span class="sxs-lookup"><span data-stu-id="bb997-104">This article gives an overview of query processing for both memory-optimized tables and natively compiled stored procedures.</span></span>  
  
 <span data-ttu-id="bb997-105">En el documento se explica cómo se compilan y ejecutan las consultas en tablas optimizadas para memoria, incluido:</span><span class="sxs-lookup"><span data-stu-id="bb997-105">The document explains how queries on memory-optimized tables are compiled and executed, including:</span></span>  
  
-   <span data-ttu-id="bb997-106">La canalización de procesamiento de consultas de [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] para las tablas basadas en disco.</span><span class="sxs-lookup"><span data-stu-id="bb997-106">The query processing pipeline in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] for disk-based tables.</span></span>  
  
-   <span data-ttu-id="bb997-107">Optimización de consultas; el rol de las estadísticas en las tablas optimizadas para memoria así como instrucciones para solucionar problemas de planes de consulta no válidos.</span><span class="sxs-lookup"><span data-stu-id="bb997-107">Query optimization; the role of statistics on memory-optimized tables as well as guidelines for troubleshooting bad query plans.</span></span>  
  
-   <span data-ttu-id="bb997-108">El uso de [!INCLUDE[tsql](../../../includes/tsql-md.md)] interpretado para tener acceso a tablas optimizadas para memoria.</span><span class="sxs-lookup"><span data-stu-id="bb997-108">The use of interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] to access memory-optimized tables.</span></span>  
  
-   <span data-ttu-id="bb997-109">Consideraciones sobre la optimización de consultas para el acceso a tablas optimizadas para memoria.</span><span class="sxs-lookup"><span data-stu-id="bb997-109">Considerations about query optimization for memory-optimized table access.</span></span>  
  
-   <span data-ttu-id="bb997-110">Compilación y procesamiento de procedimientos almacenados de forma nativa.</span><span class="sxs-lookup"><span data-stu-id="bb997-110">Natively compiled stored procedure compilation and processing.</span></span>  
  
-   <span data-ttu-id="bb997-111">Estadísticas usadas para la estimación del costo por el optimizador.</span><span class="sxs-lookup"><span data-stu-id="bb997-111">Statistics that are used for cost estimation by the optimizer.</span></span>  
  
-   <span data-ttu-id="bb997-112">Formas de solucionar los planes de consulta no válidos.</span><span class="sxs-lookup"><span data-stu-id="bb997-112">Ways to fix bad query plans.</span></span>  
  
## <a name="example-query"></a><span data-ttu-id="bb997-113">Consulta de ejemplo</span><span class="sxs-lookup"><span data-stu-id="bb997-113">Example Query</span></span>  
 <span data-ttu-id="bb997-114">El ejemplo siguiente se utilizará para mostrar los conceptos del procesamiento de consultas descritos en este artículo.</span><span class="sxs-lookup"><span data-stu-id="bb997-114">The following example will be used to illustrate the query processing concepts discussed in this article.</span></span>  
  
 <span data-ttu-id="bb997-115">Consideramos dos tablas, Customer y Order.</span><span class="sxs-lookup"><span data-stu-id="bb997-115">We consider two tables, Customer and Order.</span></span> <span data-ttu-id="bb997-116">El siguiente script de [!INCLUDE[tsql](../../../includes/tsql-md.md)] contiene las definiciones de estas dos tablas y los índices asociados, en su formato basado en disco (tradicional):</span><span class="sxs-lookup"><span data-stu-id="bb997-116">The following [!INCLUDE[tsql](../../../includes/tsql-md.md)] script contains the definitions for these two tables and associated indexes, in their (traditional) disk-based form:</span></span>  
  
```sql  
CREATE TABLE dbo.[Customer] (  
  CustomerID nchar (5) NOT NULL PRIMARY KEY,  
  ContactName nvarchar (30) NOT NULL   
)  
GO  
  
CREATE TABLE dbo.[Order] (  
  OrderID int NOT NULL PRIMARY KEY,  
  CustomerID nchar (5) NOT NULL,  
  OrderDate date NOT NULL  
)  
GO  
CREATE INDEX IX_CustomerID ON dbo.[Order](CustomerID)  
GO  
CREATE INDEX IX_OrderDate ON dbo.[Order](OrderDate)  
GO  
```  
  
 <span data-ttu-id="bb997-117">Para crear los planes de consulta mostrados en este artículo, las dos tablas se rellenaron con datos de ejemplo de la base de datos de ejemplo Northwind, que puede descargar desde [Bases de datos de ejemplo Northwind y pubs para SQL Server 2000](https://github.com/Microsoft/sql-server-samples/tree/master/samples/databases/northwind-pubs).</span><span class="sxs-lookup"><span data-stu-id="bb997-117">For constructing the query plans shown in this article, the two tables were populated with sample data from the Northwind sample database, which you can download from [Northwind and pubs Sample Databases for SQL Server 2000](https://github.com/Microsoft/sql-server-samples/tree/master/samples/databases/northwind-pubs).</span></span>  
  
 <span data-ttu-id="bb997-118">Considere la siguiente consulta, que combina las tablas Customer y Order y devuelve el identificador del pedido y la información del cliente asociada:</span><span class="sxs-lookup"><span data-stu-id="bb997-118">Consider the following query, which joins the tables Customer and Order and returns the ID of the order and the associated customer information:</span></span>  
  
```sql  
SELECT o.OrderID, c.* FROM dbo.[Customer] c INNER JOIN dbo.[Order] o ON c.CustomerID = o.CustomerID  
```  
  
 <span data-ttu-id="bb997-119">El plan de ejecución estimado como se muestra en [!INCLUDE[ssManStudioFull](../../../includes/ssmanstudiofull-md.md)] es el siguiente:</span><span class="sxs-lookup"><span data-stu-id="bb997-119">The estimated execution plan as displayed by [!INCLUDE[ssManStudioFull](../../../includes/ssmanstudiofull-md.md)] is as follows</span></span>  
  
 <span data-ttu-id="bb997-120">![Plan de consulta para una combinación de tablas basadas en disco.](../../database-engine/media/hekaton-query-plan-1.gif "Plan de consulta para una combinación de tablas basadas en disco.")</span><span class="sxs-lookup"><span data-stu-id="bb997-120">![Query plan for join of disk-based tables.](../../database-engine/media/hekaton-query-plan-1.gif "Query plan for join of disk-based tables.")</span></span>  
<span data-ttu-id="bb997-121">Plan de consulta para una combinación de tablas basadas en disco.</span><span class="sxs-lookup"><span data-stu-id="bb997-121">Query plan for join of disk-based tables.</span></span>  
  
 <span data-ttu-id="bb997-122">Acerca de este plan de consulta:</span><span class="sxs-lookup"><span data-stu-id="bb997-122">About this query plan:</span></span>  
  
-   <span data-ttu-id="bb997-123">Las filas de la tabla Customer se recuperan del índice clúster, que es la estructura de datos principal y tiene los datos completos de la tabla.</span><span class="sxs-lookup"><span data-stu-id="bb997-123">The rows from the Customer table are retrieved from the clustered index, which is the primary data structure and has the full table data.</span></span>  
  
-   <span data-ttu-id="bb997-124">Los datos de la tabla Order se recuperan usando el índice no agrupado en la columna CustomerID.</span><span class="sxs-lookup"><span data-stu-id="bb997-124">Data from the Order table is retrieved using the nonclustered index on the CustomerID column.</span></span> <span data-ttu-id="bb997-125">Este índice contiene la columna CustomerID, que se utiliza para la combinación, y la columna de clave principal OrderID, que se devuelve al usuario.</span><span class="sxs-lookup"><span data-stu-id="bb997-125">This index contains both the CustomerID column, which is used for the join, and the primary key column OrderID, which is returned to the user.</span></span> <span data-ttu-id="bb997-126">Devolver columnas adicionales de la tabla Order requeriría búsquedas en el índice clúster de la tabla Order.</span><span class="sxs-lookup"><span data-stu-id="bb997-126">Returning additional columns from the Order table would require lookups in the clustered index for the Order table.</span></span>  
  
-   <span data-ttu-id="bb997-127">El operador físico `Inner Join` implementa el operador lógico `Merge Join`.</span><span class="sxs-lookup"><span data-stu-id="bb997-127">The logical operator `Inner Join` is implemented by the physical operator `Merge Join`.</span></span> <span data-ttu-id="bb997-128">Los otros tipos de combinación físicos son `Nested Loops` y `Hash Join`.</span><span class="sxs-lookup"><span data-stu-id="bb997-128">The other physical join types are `Nested Loops` and `Hash Join`.</span></span> <span data-ttu-id="bb997-129">El operador `Merge Join` se aprovecha del hecho de que ambos índices están ordenados por la columna de combinación CustomerID.</span><span class="sxs-lookup"><span data-stu-id="bb997-129">The `Merge Join` operator takes advantage of the fact that both indexes are sorted on the join column CustomerID.</span></span>  
  
 <span data-ttu-id="bb997-130">Considere una ligera variación en esta consulta, que devuelve todas las filas de la tabla Order, no solo OrderID:</span><span class="sxs-lookup"><span data-stu-id="bb997-130">Consider a slight variation on this query, which returns all rows from the Order table, not only OrderID:</span></span>  
  
```sql  
SELECT o.*, c.* FROM dbo.[Customer] c INNER JOIN dbo.[Order] o ON c.CustomerID = o.CustomerID  
```  
  
 <span data-ttu-id="bb997-131">El plan estimado de esta consulta es:</span><span class="sxs-lookup"><span data-stu-id="bb997-131">The estimated plan for this query is:</span></span>  
  
 <span data-ttu-id="bb997-132">![Plan de consulta para una combinación hash de tablas basadas en disco.](../../database-engine/media/hekaton-query-plan-2.gif "Plan de consulta para una combinación hash de tablas basadas en disco.")</span><span class="sxs-lookup"><span data-stu-id="bb997-132">![Query plan for a hash join of disk-based tables.](../../database-engine/media/hekaton-query-plan-2.gif "Query plan for a hash join of disk-based tables.")</span></span>  
<span data-ttu-id="bb997-133">Plan de consulta para una combinación hash de tablas basadas en disco.</span><span class="sxs-lookup"><span data-stu-id="bb997-133">Query plan for a hash join of disk-based tables.</span></span>  
  
 <span data-ttu-id="bb997-134">En esta consulta, las filas de la tabla Order se recuperan con el índice clúster.</span><span class="sxs-lookup"><span data-stu-id="bb997-134">In this query, rows from the Order table are retrieved using the clustered index.</span></span> <span data-ttu-id="bb997-135">Ahora se utiliza el operador físico `Hash Match` para `Inner Join`.</span><span class="sxs-lookup"><span data-stu-id="bb997-135">The `Hash Match` physical operator is now used for the `Inner Join`.</span></span> <span data-ttu-id="bb997-136">El índice clúster en la tabla Order no está ordenado en CustomerID y, por lo tanto, `Merge Join` requeriría un operador de ordenación, lo que afectaría al rendimiento.</span><span class="sxs-lookup"><span data-stu-id="bb997-136">The clustered index on Order is not sorted on CustomerID, and so a `Merge Join` would require a sort operator, which would affect performance.</span></span> <span data-ttu-id="bb997-137">Tenga en cuenta el costo relativo del operador `Hash Match` (75 %) en comparación con el costo del operador `Merge Join` del ejemplo anterior (46 %).</span><span class="sxs-lookup"><span data-stu-id="bb997-137">Note the relative cost of the `Hash Match` operator (75%) compared with the cost of the `Merge Join` operator in the previous example (46%).</span></span> <span data-ttu-id="bb997-138">El optimizador habría considerado el operador `Hash Match` también en el ejemplo anterior pero concluyó que el operador `Merge Join` proporcionaba un rendimiento mejor.</span><span class="sxs-lookup"><span data-stu-id="bb997-138">The optimizer would have considered the `Hash Match` operator also in the previous example, but concluded that the `Merge Join` operator gave better performance.</span></span>  
  
## <a name="ssnoversion-query-processing-for-disk-based-tables"></a>[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] <span data-ttu-id="bb997-139">Procesamiento de consultas para las tablas basadas en disco</span><span class="sxs-lookup"><span data-stu-id="bb997-139">Query Processing for Disk-Based Tables</span></span>  
 <span data-ttu-id="bb997-140">El siguiente diagrama muestra el flujo de procesamiento de consultas en [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] para las consultas ad hoc:</span><span class="sxs-lookup"><span data-stu-id="bb997-140">The following diagram outlines the query processing flow in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] for ad hoc queries:</span></span>  
  
 <span data-ttu-id="bb997-141">![Canalización de procesamiento de consultas de SQL Server](../../database-engine/media/hekaton-query-plan-3.gif "Canalización de procesamiento de consultas de SQL Server")</span><span class="sxs-lookup"><span data-stu-id="bb997-141">![SQL Server query processing pipeline.](../../database-engine/media/hekaton-query-plan-3.gif "SQL Server query processing pipeline.")</span></span>  
<span data-ttu-id="bb997-142">Canalización de procesamiento de consultas de SQL Server</span><span class="sxs-lookup"><span data-stu-id="bb997-142">SQL Server query processing pipeline.</span></span>  
  
 <span data-ttu-id="bb997-143">En este escenario:</span><span class="sxs-lookup"><span data-stu-id="bb997-143">In this scenario:</span></span>  
  
1.  <span data-ttu-id="bb997-144">El usuario emite una consulta.</span><span class="sxs-lookup"><span data-stu-id="bb997-144">The user issues a query.</span></span>  
  
2.  <span data-ttu-id="bb997-145">El analizador y el algebrizador construyen un árbol de consulta con operadores lógicos según el texto de [!INCLUDE[tsql](../../../includes/tsql-md.md)] enviado por el usuario.</span><span class="sxs-lookup"><span data-stu-id="bb997-145">The parser and algebrizer construct a query tree with logical operators based on the [!INCLUDE[tsql](../../../includes/tsql-md.md)] text submitted by the user.</span></span>  
  
3.  <span data-ttu-id="bb997-146">El optimizador crea un plan de consulta optimizado que contiene los operadores físicos (por ejemplo, la combinación de bucles anidados).</span><span class="sxs-lookup"><span data-stu-id="bb997-146">The optimizer creates an optimized query plan containing physical operators (for example, nested-loops join).</span></span> <span data-ttu-id="bb997-147">Después de la optimización, el plan se puede almacenar en la memoria caché de planes.</span><span class="sxs-lookup"><span data-stu-id="bb997-147">After optimization, the plan may be stored in the plan cache.</span></span> <span data-ttu-id="bb997-148">Se omite este paso si la memoria caché de planes ya contiene un plan para esta consulta.</span><span class="sxs-lookup"><span data-stu-id="bb997-148">This step is bypassed if the plan cache already contains a plan for this query.</span></span>  
  
4.  <span data-ttu-id="bb997-149">El motor de ejecución de consultas procesa una interpretación del plan de consulta.</span><span class="sxs-lookup"><span data-stu-id="bb997-149">The query execution engine processes an interpretation of the query plan.</span></span>  
  
5.  <span data-ttu-id="bb997-150">Para cada operador de recorrido de tabla, búsqueda de índice y recorrido de índice, el motor de ejecución solicita las filas de las estructuras respectivas de índice y tabla de Access Methods.</span><span class="sxs-lookup"><span data-stu-id="bb997-150">For each index seek, index scan, and table scan operator, the execution engine requests rows from the respective index and table structures from Access Methods.</span></span>  
  
6.  <span data-ttu-id="bb997-151">Access Methods recupera las filas de las páginas de datos e índices del grupo de búferes y carga las páginas del disco al grupo de búferes según sea necesario.</span><span class="sxs-lookup"><span data-stu-id="bb997-151">Access Methods retrieves the rows from the index and data pages in the buffer pool and loads pages from disk into the buffer pool as needed.</span></span>  
  
 <span data-ttu-id="bb997-152">Para la primera consulta del ejemplo, el motor de ejecución solicita filas del índice agrupado en la tabla Customer y el índice no agrupado en la tabla Order de Access Methods.</span><span class="sxs-lookup"><span data-stu-id="bb997-152">For the first example query, the execution engine requests rows in the clustered index on Customer and the nonclustered index on Order from Access Methods.</span></span> <span data-ttu-id="bb997-153">Access Methods atraviesa las estructuras de índice del árbol B para recuperar las filas solicitadas.</span><span class="sxs-lookup"><span data-stu-id="bb997-153">Access Methods traverses the B-tree index structures to retrieve the requested rows.</span></span> <span data-ttu-id="bb997-154">En este caso, todas las filas se recuperan como las llamadas de plan para los recorridos de índice completos.</span><span class="sxs-lookup"><span data-stu-id="bb997-154">In this case all rows are retrieved as the plan calls for full index scans.</span></span>  
  
## <a name="interpreted-tsql-access-to-memory-optimized-tables"></a><span data-ttu-id="bb997-155">Acceso de [!INCLUDE[tsql](../../../includes/tsql-md.md)] interpretado a las tablas con optimización para memoria</span><span class="sxs-lookup"><span data-stu-id="bb997-155">Interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] Access to Memory-Optimized Tables</span></span>  
 [!INCLUDE[tsql](../../../includes/tsql-md.md)] <span data-ttu-id="bb997-156">también se denominan [!INCLUDE[tsql](../../../includes/tsql-md.md)].</span><span class="sxs-lookup"><span data-stu-id="bb997-156">ad hoc batches and stored procedures are also referred to as interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)].</span></span> <span data-ttu-id="bb997-157">Interpretado hace referencia al hecho de que el plan de consulta es interpretado por el motor de ejecución de consulta para cada operador del plan de consultas.</span><span class="sxs-lookup"><span data-stu-id="bb997-157">Interpreted refers to the fact that the query plan is interpreted by the query execution engine for each operator in the query plan.</span></span> <span data-ttu-id="bb997-158">El motor de ejecución lee el operador y sus parámetros y realiza la operación.</span><span class="sxs-lookup"><span data-stu-id="bb997-158">The execution engine reads the operator and its parameters and performs the operation.</span></span>  
  
 <span data-ttu-id="bb997-159">[!INCLUDE[tsql](../../../includes/tsql-md.md)] interpretado se puede utilizar para tener acceso a tablas optimizadas para memoria y a tablas basadas en disco.</span><span class="sxs-lookup"><span data-stu-id="bb997-159">Interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] can be used to access both memory-optimized and disk-based tables.</span></span> <span data-ttu-id="bb997-160">La ilustración siguiente muestra el procesamiento de consultas para el acceso de [!INCLUDE[tsql](../../../includes/tsql-md.md)] interpretado a las tablas optimizadas para memoria:</span><span class="sxs-lookup"><span data-stu-id="bb997-160">The following figure illustrates query processing for interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] access to memory-optimized tables:</span></span>  
  
 <span data-ttu-id="bb997-161">![Canalización de procesamiento de consulta para tsql interpretado.](../../database-engine/media/hekaton-query-plan-4.gif "Canalización de procesamiento de consulta para tsql interpretado.")</span><span class="sxs-lookup"><span data-stu-id="bb997-161">![Query processing pipeline for interpreted tsql.](../../database-engine/media/hekaton-query-plan-4.gif "Query processing pipeline for interpreted tsql.")</span></span>  
<span data-ttu-id="bb997-162">Canalización de procesamiento de consultas para acceso de Transact-SQL interpretado a tablas optimizadas para memoria.</span><span class="sxs-lookup"><span data-stu-id="bb997-162">Query processing pipeline for interpreted Transact-SQL access to memory-optimized tables.</span></span>  
  
 <span data-ttu-id="bb997-163">Como se muestra en la ilustración, la canalización del procesamiento de consultas permanece principalmente sin cambios:</span><span class="sxs-lookup"><span data-stu-id="bb997-163">As illustrated by the figure, the query processing pipeline remains mostly unchanged:</span></span>  
  
-   <span data-ttu-id="bb997-164">El analizador y el algebrizador construyen el árbol de consulta.</span><span class="sxs-lookup"><span data-stu-id="bb997-164">The parser and algebrizer construct the query tree.</span></span>  
  
-   <span data-ttu-id="bb997-165">El optimizador crea el plan de ejecución.</span><span class="sxs-lookup"><span data-stu-id="bb997-165">The optimizer creates the execution plan.</span></span>  
  
-   <span data-ttu-id="bb997-166">El motor de ejecución de consultas interpreta el plan de ejecución.</span><span class="sxs-lookup"><span data-stu-id="bb997-166">The query execution engine interprets the execution plan.</span></span>  
  
 <span data-ttu-id="bb997-167">La diferencia principal con la canalización de procesamiento de consultas tradicional (la ilustración 2) es que las filas de las tablas optimizadas para memoria no se recuperan del grupo de búferes mediante Access Methods.</span><span class="sxs-lookup"><span data-stu-id="bb997-167">The main difference with the traditional query processing pipeline (figure 2) is that rows for memory-optimized tables are not retrieved from the buffer pool using Access Methods.</span></span> <span data-ttu-id="bb997-168">En su lugar, las filas se recuperan de las estructuras de datos en memoria a través del motor OLTP en memoria.</span><span class="sxs-lookup"><span data-stu-id="bb997-168">Instead, rows are retrieved from the in-memory data structures through the In-Memory OLTP engine.</span></span> <span data-ttu-id="bb997-169">Las diferencias en las estructuras de datos hacen que el optimizador elija distintos planes en algunos casos, como se muestra en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="bb997-169">Differences in data structures cause the optimizer to pick different plans in some cases, as illustrated by the following example.</span></span>  
  
 <span data-ttu-id="bb997-170">El siguiente script de [!INCLUDE[tsql](../../../includes/tsql-md.md)] contiene las versiones optimizadas para memoria de las tablas Order y Customer, con índices hash:</span><span class="sxs-lookup"><span data-stu-id="bb997-170">The following [!INCLUDE[tsql](../../../includes/tsql-md.md)] script contains memory-optimized versions of the Order and Customer tables, using hash indexes:</span></span>  
  
```sql  
CREATE TABLE dbo.[Customer] (  
  CustomerID nchar (5) NOT NULL PRIMARY KEY NONCLUSTERED,  
  ContactName nvarchar (30) NOT NULL   
) WITH (MEMORY_OPTIMIZED=ON)  
GO  
  
CREATE TABLE dbo.[Order] (  
  OrderID int NOT NULL PRIMARY KEY NONCLUSTERED,  
  CustomerID nchar (5) NOT NULL INDEX IX_CustomerID HASH(CustomerID) WITH (BUCKET_COUNT=100000),  
  OrderDate date NOT NULL INDEX IX_OrderDate HASH(OrderDate) WITH (BUCKET_COUNT=100000)  
) WITH (MEMORY_OPTIMIZED=ON)  
GO  
```  
  
 <span data-ttu-id="bb997-171">Considere la misma consulta ejecutada en tablas optimizadas para memoria:</span><span class="sxs-lookup"><span data-stu-id="bb997-171">Consider the same query executed on memory-optimized tables:</span></span>  
  
```sql  
SELECT o.OrderID, c.* FROM dbo.[Customer] c INNER JOIN dbo.[Order] o ON c.CustomerID = o.CustomerID  
```  
  
 <span data-ttu-id="bb997-172">El plan estimado es el siguiente:</span><span class="sxs-lookup"><span data-stu-id="bb997-172">The estimated plan is as follows:</span></span>  
  
 <span data-ttu-id="bb997-173">![Plan de consulta para una combinación de tablas con optimización para memoria.](../../database-engine/media/hekaton-query-plan-5.gif "Plan de consulta para una combinación de tablas optimizadas para memoria.")</span><span class="sxs-lookup"><span data-stu-id="bb997-173">![Query plan for join of memory optimized tables.](../../database-engine/media/hekaton-query-plan-5.gif "Query plan for join of memory optimized tables.")</span></span>  
<span data-ttu-id="bb997-174">Plan de consulta para una combinación de tablas optimizadas para memoria.</span><span class="sxs-lookup"><span data-stu-id="bb997-174">Query plan for join of memory-optimized tables.</span></span>  
  
 <span data-ttu-id="bb997-175">Observe las siguientes diferencias con el plan para la misma consulta en las tablas basadas en disco (ilustración 1):</span><span class="sxs-lookup"><span data-stu-id="bb997-175">Observe the following differences with the plan for the same query on disk-based tables (figure 1):</span></span>  
  
-   <span data-ttu-id="bb997-176">Este plan contiene un recorrido de tabla en lugar de un recorrido de índice clúster para la tabla Customer:</span><span class="sxs-lookup"><span data-stu-id="bb997-176">This plan contains a table scan rather than a clustered index scan for the table Customer:</span></span>  
  
    -   <span data-ttu-id="bb997-177">La definición de la tabla no contiene un índice clúster.</span><span class="sxs-lookup"><span data-stu-id="bb997-177">The definition of the table does not contain a clustered index.</span></span>  
  
    -   <span data-ttu-id="bb997-178">Los índices clúster no se admiten con tablas optimizadas para memoria.</span><span class="sxs-lookup"><span data-stu-id="bb997-178">Clustered indexes are not supported with memory-optimized tables.</span></span> <span data-ttu-id="bb997-179">En su lugar, cada tabla optimizada para memoria debe tener al menos un índice no clúster y todos los índices de las tablas optimizadas para memoria pueden tener acceso eficazmente a todas las columnas de la tabla sin tener que almacenarlas en el índice o hacer referencia a un índice clúster.</span><span class="sxs-lookup"><span data-stu-id="bb997-179">Instead, every memory-optimized table must have at least one nonclustered index and all indexes on memory-optimized tables can efficiently access all columns in the table without having to store them in the index or refer to a clustered index.</span></span>  
  
-   <span data-ttu-id="bb997-180">Este plan contiene una `Hash Match` en lugar de una `Merge Join`.</span><span class="sxs-lookup"><span data-stu-id="bb997-180">This plan contains a `Hash Match` rather than a `Merge Join`.</span></span> <span data-ttu-id="bb997-181">Los índices en las tablas Order y Customer son índices hash y, por tanto, no se ordenan.</span><span class="sxs-lookup"><span data-stu-id="bb997-181">The indexes on both the Order and the Customer table are hash indexes, and are thus not ordered.</span></span> <span data-ttu-id="bb997-182">Una `Merge Join` requeriría operadores de ordenación que reducirían el rendimiento.</span><span class="sxs-lookup"><span data-stu-id="bb997-182">A `Merge Join` would require sort operators that would decrease performance.</span></span>  
  
## <a name="natively-compiled-stored-procedures"></a><span data-ttu-id="bb997-183">procedimientos almacenados compilados de forma nativa</span><span class="sxs-lookup"><span data-stu-id="bb997-183">Natively Compiled Stored Procedures</span></span>  
 <span data-ttu-id="bb997-184">Los procedimientos almacenados compilados de forma nativa son procedimientos almacenados de [!INCLUDE[tsql](../../../includes/tsql-md.md)] compilados con código máquina, en lugar de interpretados por el motor de ejecución de consultas.</span><span class="sxs-lookup"><span data-stu-id="bb997-184">Natively compiled stored procedures are [!INCLUDE[tsql](../../../includes/tsql-md.md)] stored procedures compiled to machine code, rather than interpreted by the query execution engine.</span></span> <span data-ttu-id="bb997-185">El siguiente script crea un procedimiento almacenado compilado de forma nativa que ejecuta la consulta de ejemplo (de la sección Consulta de ejemplo).</span><span class="sxs-lookup"><span data-stu-id="bb997-185">The following script creates a natively compiled stored procedure that runs the example query (from the Example Query section).</span></span>  
  
```sql  
CREATE PROCEDURE usp_SampleJoin  
WITH NATIVE_COMPILATION, SCHEMABINDING, EXECUTE AS OWNER  
AS BEGIN ATOMIC WITH   
(  TRANSACTION ISOLATION LEVEL = SNAPSHOT,  
  LANGUAGE = 'english')  
  
  SELECT o.OrderID, c.CustomerID, c.ContactName   
FROM dbo.[Order] o INNER JOIN dbo.[Customer] c   
  ON c.CustomerID = o.CustomerID  
  
END  
```  
  
 <span data-ttu-id="bb997-186">Los procedimientos almacenados compilados de forma nativa se compilan en el momento de su creación, mientras que los procedimientos almacenados interpretados se compilan la primera vez que se ejecutan.</span><span class="sxs-lookup"><span data-stu-id="bb997-186">Natively compiled stored procedures are compiled at create time, whereas interpreted stored procedures are compiled at first execution time.</span></span> <span data-ttu-id="bb997-187">(Una parte de la compilación, en particular el análisis y la algebrización, tienen lugar en la creación.</span><span class="sxs-lookup"><span data-stu-id="bb997-187">(A portion of the compilation, particularly parsing and algebrization, take place at create.</span></span> <span data-ttu-id="bb997-188">Sin embargo, para los procedimientos almacenados interpretados, la optimización de los planes de consulta tiene lugar en la primera ejecución). La lógica de la recompilación es similar.</span><span class="sxs-lookup"><span data-stu-id="bb997-188">However, for interpreted stored procedures, optimization of the query plans takes place at first execution.) The recompilation logic is similar.</span></span> <span data-ttu-id="bb997-189">Los procedimientos almacenados compilados de forma nativa se recompilan en la primera ejecución del procedimiento si el servidor se reinicia.</span><span class="sxs-lookup"><span data-stu-id="bb997-189">Natively compiled stored procedures are recompiled on first execution of the procedure if the server is restarted.</span></span> <span data-ttu-id="bb997-190">Los procedimientos almacenados interpretados se recompilan si el plan ya no está en la memoria caché de planes.</span><span class="sxs-lookup"><span data-stu-id="bb997-190">Interpreted stored procedures are recompiled if the plan is no longer in the plan cache.</span></span> <span data-ttu-id="bb997-191">En la tabla siguiente se resumen los casos de compilación y de recompilación tanto para los procedimientos almacenados interpretados como para los compilados de forma nativa:</span><span class="sxs-lookup"><span data-stu-id="bb997-191">The following table summarizes compilation and recompilation cases for both natively compiled and interpreted stored procedures:</span></span>  
  
||<span data-ttu-id="bb997-192">Compilado de forma nativa</span><span class="sxs-lookup"><span data-stu-id="bb997-192">Natively compiled</span></span>|<span data-ttu-id="bb997-193">Acceso de</span><span class="sxs-lookup"><span data-stu-id="bb997-193">Interpreted</span></span>|  
|-|-----------------------|-----------------|  
|<span data-ttu-id="bb997-194">Compilación inicial</span><span class="sxs-lookup"><span data-stu-id="bb997-194">Initial compilation</span></span>|<span data-ttu-id="bb997-195">En el momento de la creación.</span><span class="sxs-lookup"><span data-stu-id="bb997-195">At create time.</span></span>|<span data-ttu-id="bb997-196">En la primera ejecución.</span><span class="sxs-lookup"><span data-stu-id="bb997-196">At first execution.</span></span>|  
|<span data-ttu-id="bb997-197">Recompilación automática</span><span class="sxs-lookup"><span data-stu-id="bb997-197">Automatic recompilation</span></span>|<span data-ttu-id="bb997-198">En la primera ejecución del procedimiento después del reinicio de la base de datos o del servidor.</span><span class="sxs-lookup"><span data-stu-id="bb997-198">Upon first execution of the procedure after a database or server restart.</span></span>|<span data-ttu-id="bb997-199">Al reiniciar el servidor.</span><span class="sxs-lookup"><span data-stu-id="bb997-199">On server restart.</span></span> <span data-ttu-id="bb997-200">O bien, se expulsa de la memoria caché de planes, generalmente según los cambios de esquema o de estadísticas, o por presión en la memoria.</span><span class="sxs-lookup"><span data-stu-id="bb997-200">Or, eviction from the plan cache, usually based on schema or stats changes, or memory pressure.</span></span>|  
|<span data-ttu-id="bb997-201">Recompilación manual</span><span class="sxs-lookup"><span data-stu-id="bb997-201">Manual recompilation</span></span>|<span data-ttu-id="bb997-202">No compatible.</span><span class="sxs-lookup"><span data-stu-id="bb997-202">Not supported.</span></span> <span data-ttu-id="bb997-203">La solución es quitar y volver a crear el procedimiento almacenado.</span><span class="sxs-lookup"><span data-stu-id="bb997-203">The workaround is to drop and recreate the stored procedure.</span></span>|<span data-ttu-id="bb997-204">Use `sp_recompile`.</span><span class="sxs-lookup"><span data-stu-id="bb997-204">Use `sp_recompile`.</span></span> <span data-ttu-id="bb997-205">Puede expulsar manualmente el plan de la memoria caché, por ejemplo con DBCC FREEPROCCACHE.</span><span class="sxs-lookup"><span data-stu-id="bb997-205">You can manually evict the plan from the cache, for example through DBCC FREEPROCCACHE.</span></span> <span data-ttu-id="bb997-206">También puede crear el procedimiento almacenado WITH RECOMPILE y el procedimiento almacenado se recompilará en cada ejecución.</span><span class="sxs-lookup"><span data-stu-id="bb997-206">You can also create the stored procedure WITH RECOMPILE and the stored procedure will be recompiled at every execution.</span></span>|  
  
### <a name="compilation-and-query-processing"></a><span data-ttu-id="bb997-207">Compilación y procesamiento de consultas</span><span class="sxs-lookup"><span data-stu-id="bb997-207">Compilation and Query Processing</span></span>  
 <span data-ttu-id="bb997-208">El siguiente diagrama muestra el proceso de compilación para los procedimientos almacenados compilados de forma nativa:</span><span class="sxs-lookup"><span data-stu-id="bb997-208">The following diagram illustrates the compilation process for natively compiled stored procedures:</span></span>  
  
 <span data-ttu-id="bb997-209">![Compilación nativa de procedimientos almacenados.](../../database-engine/media/hekaton-query-plan-6.gif "Compilación nativa de procedimientos almacenados.")</span><span class="sxs-lookup"><span data-stu-id="bb997-209">![Native compilation of stored procedures.](../../database-engine/media/hekaton-query-plan-6.gif "Native compilation of stored procedures.")</span></span>  
<span data-ttu-id="bb997-210">Compilación nativa de procedimientos almacenados.</span><span class="sxs-lookup"><span data-stu-id="bb997-210">Native compilation of stored procedures.</span></span>  
  
 <span data-ttu-id="bb997-211">El proceso se describe como</span><span class="sxs-lookup"><span data-stu-id="bb997-211">The process is described as,</span></span>  
  
1.  <span data-ttu-id="bb997-212">El usuario emite una instrucción `CREATE PROCEDURE` a [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span><span class="sxs-lookup"><span data-stu-id="bb997-212">The user issues a `CREATE PROCEDURE` statement to [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span>  
  
2.  <span data-ttu-id="bb997-213">El analizador y el algebrizador crean el flujo de procesamiento del procedimiento, así como los árboles de consulta para las consultas de [!INCLUDE[tsql](../../../includes/tsql-md.md)] del procedimiento almacenado.</span><span class="sxs-lookup"><span data-stu-id="bb997-213">The parser and algebrizer create the processing flow for the procedure, as well as query trees for the [!INCLUDE[tsql](../../../includes/tsql-md.md)] queries in the stored procedure.</span></span>  
  
3.  <span data-ttu-id="bb997-214">El optimizador crea planes optimizados de ejecución de consultas para todas las consultas en el procedimiento almacenado.</span><span class="sxs-lookup"><span data-stu-id="bb997-214">The optimizer creates optimized query execution plans for all the queries in the stored procedure.</span></span>  
  
4.  <span data-ttu-id="bb997-215">El compilador OLTP en memoria toma el flujo de procesamiento con los planes de consulta optimizados incrustados y genera un archivo DLL que contiene el código máquina para ejecutar el procedimiento almacenado.</span><span class="sxs-lookup"><span data-stu-id="bb997-215">The In-Memory OLTP compiler takes the processing flow with the embedded optimized query plans and generates a DLL that contains the machine code for executing the stored procedure.</span></span>  
  
5.  <span data-ttu-id="bb997-216">El archivo DLL generado se carga en memoria.</span><span class="sxs-lookup"><span data-stu-id="bb997-216">The generated DLL is loaded into memory.</span></span>  
  
 <span data-ttu-id="bb997-217">La invocación de un procedimiento almacenado compilado de forma nativa se traduce en la llamada a una función del archivo DLL.</span><span class="sxs-lookup"><span data-stu-id="bb997-217">Invocation of a natively compiled stored procedure translates to calling a function in the DLL.</span></span>  
  
 <span data-ttu-id="bb997-218">![Ejecución de los procedimientos almacenados compilados de forma nativa.](../../database-engine/media/hekaton-query-plan-7.gif "Ejecución de los procedimientos almacenados compilados de forma nativa.")</span><span class="sxs-lookup"><span data-stu-id="bb997-218">![Execution of natively compiled stored procedures.](../../database-engine/media/hekaton-query-plan-7.gif "Execution of natively compiled stored procedures.")</span></span>  
<span data-ttu-id="bb997-219">Ejecución de los procedimientos almacenados compilados de forma nativa.</span><span class="sxs-lookup"><span data-stu-id="bb997-219">Execution of natively compiled stored procedures.</span></span>  
  
 <span data-ttu-id="bb997-220">La invocación de un procedimiento almacenado compilado de forma nativa se describe como sigue:</span><span class="sxs-lookup"><span data-stu-id="bb997-220">Invocation of a natively compiled stored procedure is described as follows:</span></span>  
  
1.  <span data-ttu-id="bb997-221">El usuario emite una `EXEC` instrucción *usp_myproc* .</span><span class="sxs-lookup"><span data-stu-id="bb997-221">The user issues an `EXEC`*usp_myproc* statement.</span></span>  
  
2.  <span data-ttu-id="bb997-222">El analizador extrae los parámetros del nombre y del procedimiento almacenado.</span><span class="sxs-lookup"><span data-stu-id="bb997-222">The parser extracts the name and stored procedure parameters.</span></span>  
  
     <span data-ttu-id="bb997-223">Si la instrucción se preparó, por ejemplo con `sp_prep_exec`, el analizador no necesita extraer el nombre y los parámetros de los procedimientos en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="bb997-223">If the statement was prepared, for example using `sp_prep_exec`, the parser does not need to extract the procedure name and parameters at execution time.</span></span>  
  
3.  <span data-ttu-id="bb997-224">El runtime de OLTP en memoria encuentra el punto de entrada del archivo DLL para el procedimiento almacenado.</span><span class="sxs-lookup"><span data-stu-id="bb997-224">The In-Memory OLTP runtime locates the DLL entry point for the stored procedure.</span></span>  
  
4.  <span data-ttu-id="bb997-225">El código máquina del archivo DLL se ejecuta y los resultados se devuelven al cliente.</span><span class="sxs-lookup"><span data-stu-id="bb997-225">The machine code in the DLL is executed and the results of are returned to the client.</span></span>  
  
 <span data-ttu-id="bb997-226">**Examen de parámetros**</span><span class="sxs-lookup"><span data-stu-id="bb997-226">**Parameter sniffing**</span></span>  
  
 <span data-ttu-id="bb997-227">Los procedimientos almacenados de [!INCLUDE[tsql](../../../includes/tsql-md.md)] interpretado se compilan en la primera ejecución, a diferencia de los procedimientos almacenados compilados de forma nativa, que se compilan en el momento de su creación.</span><span class="sxs-lookup"><span data-stu-id="bb997-227">Interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] stored procedures are compiled at first execution, in contrast to natively compiled stored procedures, which are compiled at create time.</span></span> <span data-ttu-id="bb997-228">Cuando los procedimientos almacenados interpretados se compilan al invocarlos, el optimizador usa los valores de los parámetros proporcionados para esta invocación al generar el plan de ejecución.</span><span class="sxs-lookup"><span data-stu-id="bb997-228">When interpreted stored procedures are compiled at invocation, the values of the parameters supplied for this invocation are used by the optimizer when generating the execution plan.</span></span> <span data-ttu-id="bb997-229">Este uso de parámetros durante la compilación se denomina examen de parámetros.</span><span class="sxs-lookup"><span data-stu-id="bb997-229">This use of parameters during compilation is called parameter sniffing.</span></span>  
  
 <span data-ttu-id="bb997-230">El examen de parámetros no se utiliza para compilar procedimientos almacenados compilados de forma nativa.</span><span class="sxs-lookup"><span data-stu-id="bb997-230">Parameter sniffing is not used for compiling natively compiled stored procedures.</span></span> <span data-ttu-id="bb997-231">Todos los parámetros para el procedimiento almacenado se considera que tienen valores UNKNOWN.</span><span class="sxs-lookup"><span data-stu-id="bb997-231">All parameters to the stored procedure are considered to have UNKNOWN values.</span></span> <span data-ttu-id="bb997-232">Al igual que sucede con los procedimientos almacenados interpretados, los procedimientos almacenados compilados de forma nativa también admiten la sugerencia `OPTIMIZE FOR`.</span><span class="sxs-lookup"><span data-stu-id="bb997-232">Like interpreted stored procedures, natively compiled stored procedures also support the `OPTIMIZE FOR` hint.</span></span> <span data-ttu-id="bb997-233">Para obtener más información, vea [Sugerencias de consulta &#40;Transact-SQL&#41;](/sql/t-sql/queries/hints-transact-sql-query).</span><span class="sxs-lookup"><span data-stu-id="bb997-233">For more information, see [Query Hints &#40;Transact-SQL&#41;](/sql/t-sql/queries/hints-transact-sql-query).</span></span>  
  
### <a name="retrieving-a-query-execution-plan-for-natively-compiled-stored-procedures"></a><span data-ttu-id="bb997-234">Recuperar un plan de ejecución de consultas para los procedimientos almacenados compilados de forma nativa</span><span class="sxs-lookup"><span data-stu-id="bb997-234">Retrieving a Query Execution Plan for Natively Compiled Stored Procedures</span></span>  
 <span data-ttu-id="bb997-235">El plan de ejecución de consulta para un procedimiento almacenado compilado de forma nativa se puede recuperar con un **Plan de ejecución estimado** en [!INCLUDE[ssManStudio](../../includes/ssmanstudio-md.md)]o con la opción SHOWPLAN_XML en [!INCLUDE[tsql](../../../includes/tsql-md.md)].</span><span class="sxs-lookup"><span data-stu-id="bb997-235">The query execution plan for a natively compiled stored procedure can be retrieved using **Estimated Execution Plan** in [!INCLUDE[ssManStudio](../../includes/ssmanstudio-md.md)], or using the SHOWPLAN_XML option in [!INCLUDE[tsql](../../../includes/tsql-md.md)].</span></span> <span data-ttu-id="bb997-236">Por ejemplo:</span><span class="sxs-lookup"><span data-stu-id="bb997-236">For example:</span></span>  
  
```sql  
SET SHOWPLAN_XML ON  
GO  
EXEC dbo.usp_myproc  
GO  
SET SHOWPLAN_XML OFF  
GO  
```  
  
 <span data-ttu-id="bb997-237">El plan de ejecución generado por el optimizador de consultas está compuesto de un árbol con operadores de consulta en los nodos y en las hojas de árbol.</span><span class="sxs-lookup"><span data-stu-id="bb997-237">The execution plan generated by the query optimizer consists of a tree with query operators on the nodes and leaves of the tree.</span></span> <span data-ttu-id="bb997-238">La estructura del árbol determina la interacción (el flujo de filas de un operador a otro) entre los operadores.</span><span class="sxs-lookup"><span data-stu-id="bb997-238">The structure of the tree determines the interaction (the flow of rows from one operator to another) between the operators.</span></span> <span data-ttu-id="bb997-239">En la vista gráfica de [!INCLUDE[ssManStudioFull](../../../includes/ssmanstudiofull-md.md)], el flujo es de derecha a izquierda.</span><span class="sxs-lookup"><span data-stu-id="bb997-239">In the graphical view of [!INCLUDE[ssManStudioFull](../../../includes/ssmanstudiofull-md.md)], the flow is from right to left.</span></span> <span data-ttu-id="bb997-240">Por ejemplo, el plan de consulta de la ilustración 1 contiene dos operadores de examen de índices, lo que proporciona filas para un operador de combinación de mezcla.</span><span class="sxs-lookup"><span data-stu-id="bb997-240">For example, the query plan in figure 1 contains two index scan operators, which supplies rows to a merge join operator.</span></span> <span data-ttu-id="bb997-241">El operador merge join proporciona filas para un operador select.</span><span class="sxs-lookup"><span data-stu-id="bb997-241">The merge join operator supplies rows to a select operator.</span></span> <span data-ttu-id="bb997-242">El operador select, finalmente, devuelve las filas al cliente.</span><span class="sxs-lookup"><span data-stu-id="bb997-242">The select operator, finally, returns the rows to the client.</span></span>  
  
### <a name="query-operators-in-natively-compiled-stored-procedures"></a><span data-ttu-id="bb997-243">Operadores de consulta en procedimientos almacenados compilados de forma nativa</span><span class="sxs-lookup"><span data-stu-id="bb997-243">Query Operators in Natively Compiled Stored Procedures</span></span>  
 <span data-ttu-id="bb997-244">En la tabla siguiente se resumen los operadores de consulta admitidos dentro de procedimientos almacenados compilados de forma nativa:</span><span class="sxs-lookup"><span data-stu-id="bb997-244">The following table summarizes the query operators supported inside natively compiled stored procedures:</span></span>  
  
|<span data-ttu-id="bb997-245">Operator</span><span class="sxs-lookup"><span data-stu-id="bb997-245">Operator</span></span>|<span data-ttu-id="bb997-246">Consulta de ejemplo</span><span class="sxs-lookup"><span data-stu-id="bb997-246">Sample query</span></span>|  
|--------------|------------------|  
|<span data-ttu-id="bb997-247">SELECT</span><span class="sxs-lookup"><span data-stu-id="bb997-247">SELECT</span></span>|`SELECT OrderID FROM dbo.[Order]`|  
|<span data-ttu-id="bb997-248">INSERT</span><span class="sxs-lookup"><span data-stu-id="bb997-248">INSERT</span></span>|`INSERT dbo.Customer VALUES ('abc', 'def')`|  
|<span data-ttu-id="bb997-249">UPDATE</span><span class="sxs-lookup"><span data-stu-id="bb997-249">UPDATE</span></span>|`UPDATE dbo.Customer SET ContactName='ghi' WHERE CustomerID='abc'`|  
|<span data-ttu-id="bb997-250">Delete</span><span class="sxs-lookup"><span data-stu-id="bb997-250">DELETE</span></span>|`DELETE dbo.Customer WHERE CustomerID='abc'`|  
|<span data-ttu-id="bb997-251">Compute Scalar</span><span class="sxs-lookup"><span data-stu-id="bb997-251">Compute Scalar</span></span>|<span data-ttu-id="bb997-252">Este operador se usa tanto para las funciones intrínsecas como para las conversiones de tipos.</span><span class="sxs-lookup"><span data-stu-id="bb997-252">This operator is used both for intrinsic functions and type conversions.</span></span> <span data-ttu-id="bb997-253">No todas las funciones y conversiones de tipos se admiten en los procedimientos almacenados compilados de forma nativa.</span><span class="sxs-lookup"><span data-stu-id="bb997-253">Not all functions and type conversions are supported inside natively compiled stored procedures.</span></span><br /><br /> `SELECT OrderID+1 FROM dbo.[Order]`|  
|<span data-ttu-id="bb997-254">Combinación de bucles anidados</span><span class="sxs-lookup"><span data-stu-id="bb997-254">Nested Loops Join</span></span>|<span data-ttu-id="bb997-255">Nested Loops es el único operador de combinación admitido en los procedimientos almacenados compilados de forma nativa.</span><span class="sxs-lookup"><span data-stu-id="bb997-255">Nested Loops is the only join operator supported in natively compiled stored procedures.</span></span> <span data-ttu-id="bb997-256">Todos los planes que contienen combinaciones utilizarán el operador Nested Loops, incluso si el plan para la misma consulta ejecutada como [!INCLUDE[tsql](../../../includes/tsql-md.md)] interpretado contiene una combinación de mezcla o hash.</span><span class="sxs-lookup"><span data-stu-id="bb997-256">All plans that contain joins will use the Nested Loops operator, even if the plan for same query executed as interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] contains a hash or merge join.</span></span><br /><br /> `SELECT o.OrderID, c.CustomerID`  <br /> `FROM dbo.[Order] o INNER JOIN dbo.[Customer] c`|  
|<span data-ttu-id="bb997-257">Sort</span><span class="sxs-lookup"><span data-stu-id="bb997-257">Sort</span></span>|`SELECT ContactName FROM dbo.Customer`  <br /> `ORDER BY ContactName`|  
|<span data-ttu-id="bb997-258">TOP</span><span class="sxs-lookup"><span data-stu-id="bb997-258">Top</span></span>|`SELECT TOP 10 ContactName FROM dbo.Customer`|  
|<span data-ttu-id="bb997-259">Top-sort</span><span class="sxs-lookup"><span data-stu-id="bb997-259">Top-sort</span></span>|<span data-ttu-id="bb997-260">La expresión `TOP` (número de filas que se van a devolver) no puede superar 8000 filas.</span><span class="sxs-lookup"><span data-stu-id="bb997-260">The `TOP` expression (the number of rows to be returned) cannot exceed 8,000 rows.</span></span> <span data-ttu-id="bb997-261">Si hay también en la consulta operadores de combinación y agregación, habrá menos filas.</span><span class="sxs-lookup"><span data-stu-id="bb997-261">Fewer if there are also join and aggregation operators in the query.</span></span> <span data-ttu-id="bb997-262">Las combinaciones y agregaciones suelen reducir el número de filas que se van a ordenar, en comparación con el recuento de filas de las tablas base.</span><span class="sxs-lookup"><span data-stu-id="bb997-262">Joins and aggregation do typically reduce the number of rows to be sorted, compared with the row count of the base tables.</span></span><br /><br /> `SELECT TOP 10 ContactName FROM dbo.Customer`  <br /> `ORDER BY ContactName`|  
|<span data-ttu-id="bb997-263">Stream Aggregate</span><span class="sxs-lookup"><span data-stu-id="bb997-263">Stream Aggregate</span></span>|<span data-ttu-id="bb997-264">Observe que el operador Hash Match no se admite para la agregación.</span><span class="sxs-lookup"><span data-stu-id="bb997-264">Note that the Hash Match operator is not supported for aggregation.</span></span> <span data-ttu-id="bb997-265">Por consiguiente, toda la agregación en los procedimientos almacenados compilados de forma nativa utiliza el operador Stream Aggregate, incluso si el plan para la misma consulta en [!INCLUDE[tsql](../../../includes/tsql-md.md)] interpretado utiliza el operador Hash Match.</span><span class="sxs-lookup"><span data-stu-id="bb997-265">Therefore, all aggregation in natively compiled stored procedures uses the Stream Aggregate operator, even if the plan for the same query in interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] uses the Hash Match operator.</span></span><br /><br /> `SELECT count(CustomerID) FROM dbo.Customer`|  
  
## <a name="column-statistics-and-joins"></a><span data-ttu-id="bb997-266">Combinaciones y estadísticas de columnas</span><span class="sxs-lookup"><span data-stu-id="bb997-266">Column Statistics and Joins</span></span>  
 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] <span data-ttu-id="bb997-267">mantiene estadísticas en los valores de columnas de clave de índice para ayudar a evaluar el costo de ciertas operaciones, como el examen de índice y las búsquedas de índice.</span><span class="sxs-lookup"><span data-stu-id="bb997-267">maintains statistics on values in index key columns to help estimate the cost of certain operations, such as index scan and index seeks.</span></span> <span data-ttu-id="bb997-268">([!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] también crea estadísticas en columnas de clave sin índice si se crean explícitamente o si el optimizador de consultas las crea en respuesta a una consulta con predicado). La métrica principal en la estimación del costo es el número de filas procesadas por un único operador.</span><span class="sxs-lookup"><span data-stu-id="bb997-268">( [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] also creates statistics on non-index key columns if you explicitly create them or if the query optimizer creates them in response to a query with a predicate.) The main metric in cost estimation is the number of rows processed by a single operator.</span></span> <span data-ttu-id="bb997-269">Tenga en cuenta que para las tablas basadas en disco, el número de páginas a las que tiene acceso un operador determinado es importante en la estimación de costos.</span><span class="sxs-lookup"><span data-stu-id="bb997-269">Note that for disk-based tables, the number of pages accessed by a particular operator is significant in cost estimation.</span></span> <span data-ttu-id="bb997-270">Sin embargo, como el recuento de páginas no es importante para las tablas optimizadas para memoria (siempre es cero), esta explicación se centra en el recuento de filas.</span><span class="sxs-lookup"><span data-stu-id="bb997-270">However, as page count is not important for memory-optimized tables (it is always zero), this discussion focuses on row count.</span></span> <span data-ttu-id="bb997-271">La estimación comienza por los operadores de examen y búsqueda de índice en el plan, y se extiende después para incluir los otros operadores, como el operador de combinación.</span><span class="sxs-lookup"><span data-stu-id="bb997-271">The estimation starts with the index seek and scan operators in the plan, and is then extended to include the other operators, like the join operator.</span></span> <span data-ttu-id="bb997-272">El número estimado de filas que va a procesar un operador de combinación se basa en la estimación de los operadores de examen, índice y búsqueda subyacentes.</span><span class="sxs-lookup"><span data-stu-id="bb997-272">The estimated number of rows to be processed by a join operator is based on the estimation for the underlying index, seek, and scan operators.</span></span> <span data-ttu-id="bb997-273">Para que [!INCLUDE[tsql](../../../includes/tsql-md.md)] interpretado pueda obtener acceso a las tablas optimizadas para memoria, puede seguir el plan de ejecución real para ver la diferencia entre los recuentos de filas estimado y real de los operadores del plan.</span><span class="sxs-lookup"><span data-stu-id="bb997-273">For interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] access to memory-optimized tables, you can observe the actual execution plan to see the difference between the estimated and actual row counts for the operators in the plan.</span></span>  
  
 <span data-ttu-id="bb997-274">Para el ejemplo en la ilustración 1,</span><span class="sxs-lookup"><span data-stu-id="bb997-274">For the example in figure 1,</span></span>  
  
-   <span data-ttu-id="bb997-275">El examen de índice clúster en Customer ha estimado 91; reales 91.</span><span class="sxs-lookup"><span data-stu-id="bb997-275">The clustered index scan on Customer has estimated 91; actual 91.</span></span>  
  
-   <span data-ttu-id="bb997-276">El examen de índice no clúster en CustomerID ha estimado 830; reales 830.</span><span class="sxs-lookup"><span data-stu-id="bb997-276">The nonclustered index scan on CustomerID has estimated 830; actual 830.</span></span>  
  
-   <span data-ttu-id="bb997-277">El operador Merge Join ha estimado 815; reales 830.</span><span class="sxs-lookup"><span data-stu-id="bb997-277">The Merge Join operator has estimated 815; actual 830.</span></span>  
  
 <span data-ttu-id="bb997-278">Las estimaciones de los exámenes de índice son precisas.</span><span class="sxs-lookup"><span data-stu-id="bb997-278">The estimates for the index scans are accurate.</span></span> [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] <span data-ttu-id="bb997-279">mantiene el recuento de filas en las tablas basadas en disco.</span><span class="sxs-lookup"><span data-stu-id="bb997-279">maintains the row count for disk-based tables.</span></span> <span data-ttu-id="bb997-280">Las estimaciones para los recorridos de índice y de la tabla completa siempre son precisas.</span><span class="sxs-lookup"><span data-stu-id="bb997-280">Estimates for full table and index scans are always accurate.</span></span> <span data-ttu-id="bb997-281">La estimación de la combinación es bastante precisa también.</span><span class="sxs-lookup"><span data-stu-id="bb997-281">The estimate for the join is fairly accurate, too.</span></span>  
  
 <span data-ttu-id="bb997-282">Si estas estimaciones cambian, las consideraciones de costo para las diferentes alternativas de plan también cambian.</span><span class="sxs-lookup"><span data-stu-id="bb997-282">If these estimates change, the cost considerations for different plan alternatives change as well.</span></span> <span data-ttu-id="bb997-283">Por ejemplo, si uno de los lados de la combinación tiene un recuento estimado de filas de 1 o menos, usar las combinaciones de bucles anidados es menos costoso.</span><span class="sxs-lookup"><span data-stu-id="bb997-283">For example, if one of the sides of the join has an estimated row count of 1 or just a few rows, using a nested loops joins is less expensive.</span></span>  
  
 <span data-ttu-id="bb997-284">A continuación se muestra el plan de la consulta:</span><span class="sxs-lookup"><span data-stu-id="bb997-284">The following is the plan for the query:</span></span>  
  
```  
SELECT o.OrderID, c.* FROM dbo.[Customer] c INNER JOIN dbo.[Order] o ON c.CustomerID = o.CustomerID  
```  
  
 <span data-ttu-id="bb997-285">Después de eliminar todas las filas menos una en la tabla Customer:</span><span class="sxs-lookup"><span data-stu-id="bb997-285">After deleting all rows but one in the table Customer:</span></span>  
  
 <span data-ttu-id="bb997-286">![Combinaciones y estadísticas de columnas.](../../database-engine/media/hekaton-query-plan-9.gif "Combinaciones y estadísticas de columnas.")</span><span class="sxs-lookup"><span data-stu-id="bb997-286">![Column statistics and joins.](../../database-engine/media/hekaton-query-plan-9.gif "Column statistics and joins.")</span></span>  
  
 <span data-ttu-id="bb997-287">Acerca de este plan de consulta:</span><span class="sxs-lookup"><span data-stu-id="bb997-287">Regarding this query plan:</span></span>  
  
-   <span data-ttu-id="bb997-288">Hash Match se ha reemplazado por un operador de combinación anidada Nested Loops.</span><span class="sxs-lookup"><span data-stu-id="bb997-288">The Hash Match has been replaced with a Nested Loops physical join operator.</span></span>  
  
-   <span data-ttu-id="bb997-289">El examen de índice completo en IX_CustomerID se ha reemplazado por index seek.</span><span class="sxs-lookup"><span data-stu-id="bb997-289">The full index scan on IX_CustomerID has been replaced with an index seek.</span></span> <span data-ttu-id="bb997-290">Esto provocó el examen de 5 filas en lugar de las 830 necesarias para el examen de índice completo.</span><span class="sxs-lookup"><span data-stu-id="bb997-290">This resulted in scanning 5 rows, instead of the 830 rows required for the full index scan.</span></span>  
  
### <a name="statistics-and-cardinality-for-memory-optimized-tables"></a><span data-ttu-id="bb997-291">Estadísticas y cardinalidad para las tablas con optimización para memoria</span><span class="sxs-lookup"><span data-stu-id="bb997-291">Statistics and Cardinality for Memory-Optimized Tables</span></span>  
 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] <span data-ttu-id="bb997-292">mantiene las estadísticas de nivel de columna de las tablas optimizadas para memoria.</span><span class="sxs-lookup"><span data-stu-id="bb997-292">maintains column-level statistics for memory-optimized tables.</span></span> <span data-ttu-id="bb997-293">Además, mantiene el recuento de filas real de la tabla.</span><span class="sxs-lookup"><span data-stu-id="bb997-293">In addition, it maintains the actual row count of the table.</span></span> <span data-ttu-id="bb997-294">Sin embargo, a diferencia de las tablas basadas en disco, las estadísticas de las tablas optimizadas para memoria no se actualizan automáticamente.</span><span class="sxs-lookup"><span data-stu-id="bb997-294">However, in contrast to disk-based tables, the statistics for memory-optimized tables are not automatically updated.</span></span> <span data-ttu-id="bb997-295">Por tanto, las estadísticas se deben actualizar manualmente cuando se produzcan cambios significativos en las tablas.</span><span class="sxs-lookup"><span data-stu-id="bb997-295">Therefore, statistics need to be manually updated after significant changes in the tables.</span></span> <span data-ttu-id="bb997-296">Para obtener más información, vea [Estadísticas para las tablas con optimización para memoria](memory-optimized-tables.md).</span><span class="sxs-lookup"><span data-stu-id="bb997-296">For more information, see [Statistics for Memory-Optimized Tables](memory-optimized-tables.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="bb997-297">Consulte también</span><span class="sxs-lookup"><span data-stu-id="bb997-297">See Also</span></span>  
 [<span data-ttu-id="bb997-298">Tablas optimizadas para la memoria</span><span class="sxs-lookup"><span data-stu-id="bb997-298">Memory-Optimized Tables</span></span>](memory-optimized-tables.md)  
  
  
