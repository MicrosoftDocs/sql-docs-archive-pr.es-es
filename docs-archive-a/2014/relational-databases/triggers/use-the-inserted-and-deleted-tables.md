---
title: Usar las tablas insertadas y eliminadas | Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: ''
ms.topic: conceptual
helpviewer_keywords:
- inserted tables
- UPDATE statement [SQL Server], DML triggers
- DELETE statement [SQL Server], DML triggers
- INSTEAD OF triggers
- deleted tables
- INSERT statement [SQL Server], DML triggers
- DML triggers, deleted or inserted tables
ms.assetid: ed84567f-7b91-4b44-b5b2-c400bda4590d
author: rothja
ms.author: jroth
ms.openlocfilehash: facc534177113bd93e56e50fca3ae14c3e6b2cfc
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 08/04/2020
ms.locfileid: "87676907"
---
# <a name="use-the-inserted-and-deleted-tables"></a><span data-ttu-id="87e03-102">Usar las tablas insertadas y eliminadas</span><span class="sxs-lookup"><span data-stu-id="87e03-102">Use the inserted and deleted Tables</span></span>
  <span data-ttu-id="87e03-103">En las instrucciones de desencadenadores DML se usan dos tablas especiales: la tabla inserted y la tabla deleted.</span><span class="sxs-lookup"><span data-stu-id="87e03-103">DML trigger statements use two special tables: the deleted table and the inserted tables.</span></span> [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] <span data-ttu-id="87e03-104">crea y administra automáticamente ambas tablas.</span><span class="sxs-lookup"><span data-stu-id="87e03-104">automatically creates and manages these tables.</span></span> <span data-ttu-id="87e03-105">Puede utilizar estas tablas temporales residentes en memoria para probar los efectos de determinadas modificaciones de datos y para establecer condiciones para las acciones de los desencadenadores DML.</span><span class="sxs-lookup"><span data-stu-id="87e03-105">You can use these temporary, memory-resident tables to test the effects of certain data modifications and to set conditions for DML trigger actions.</span></span> <span data-ttu-id="87e03-106">No puede modificar directamente los datos de estas tablas ni realizar en ellas operaciones de lenguaje de definición de datos (DDL), como CREATE INDEX.</span><span class="sxs-lookup"><span data-stu-id="87e03-106">You cannot directly modify the data in the tables or perform data definition language (DDL) operations on the tables, such as CREATE INDEX.</span></span>  
  
 <span data-ttu-id="87e03-107">En los desencadenadores DML, las tablas inserted y deleted se utilizan principalmente para realizar las siguientes tareas:</span><span class="sxs-lookup"><span data-stu-id="87e03-107">In DML triggers, the inserted and deleted tables are primarily used to perform the following:</span></span>  
  
-   <span data-ttu-id="87e03-108">Ampliar la integridad referencial entre tablas.</span><span class="sxs-lookup"><span data-stu-id="87e03-108">Extend referential integrity between tables.</span></span>  
  
-   <span data-ttu-id="87e03-109">Insertar o actualizar datos de tablas base subyacentes a una vista.</span><span class="sxs-lookup"><span data-stu-id="87e03-109">Insert or update data in base tables underlying a view.</span></span>  
  
-   <span data-ttu-id="87e03-110">Comprobar errores y realizar acciones en función del error.</span><span class="sxs-lookup"><span data-stu-id="87e03-110">Test for errors and take action based on the error.</span></span>  
  
-   <span data-ttu-id="87e03-111">Conocer la diferencia entre el estado de una tabla antes y después de realizar una modificación en los datos, y actuar en función de dicha diferencia.</span><span class="sxs-lookup"><span data-stu-id="87e03-111">Find the difference between the state of a table before and after a data modification and take actions based on that difference.</span></span>  
  
 <span data-ttu-id="87e03-112">La tabla deleted almacena copias de las filas afectadas por las instrucciones DELETE y UPDATE.</span><span class="sxs-lookup"><span data-stu-id="87e03-112">The deleted table stores copies of the affected rows during DELETE and UPDATE statements.</span></span> <span data-ttu-id="87e03-113">Durante la ejecución de una instrucción DELETE o UPDATE, las filas se eliminan de la tabla del desencadenador y se transfieren a la tabla deleted.</span><span class="sxs-lookup"><span data-stu-id="87e03-113">During the execution of a DELETE or UPDATE statement, rows are deleted from the trigger table and transferred to the deleted table.</span></span> <span data-ttu-id="87e03-114">La tabla deleted y la tabla del desencadenador no suelen tener filas en común.</span><span class="sxs-lookup"><span data-stu-id="87e03-114">The deleted table and the trigger table ordinarily have no rows in common.</span></span>  
  
 <span data-ttu-id="87e03-115">La tabla inserted almacena copias de las filas afectadas durante las instrucciones INSERT y UPDATE.</span><span class="sxs-lookup"><span data-stu-id="87e03-115">The inserted table stores copies of the affected rows during INSERT and UPDATE statements.</span></span> <span data-ttu-id="87e03-116">Durante una transacción de inserción o actualización, se agregan nuevas filas a la tabla inserted y a la tabla del desencadenador.</span><span class="sxs-lookup"><span data-stu-id="87e03-116">During an insert or update transaction, new rows are added to both the inserted table and the trigger table.</span></span> <span data-ttu-id="87e03-117">Las filas de la tabla inserted son copias de las nuevas filas de la tabla del desencadenador.</span><span class="sxs-lookup"><span data-stu-id="87e03-117">The rows in the inserted table are copies of the new rows in the trigger table.</span></span>  
  
 <span data-ttu-id="87e03-118">Una transacción de actualización es similar a una operación de eliminación seguida de una operación de inserción; primero, se copian las filas antiguas en la tabla deleted y luego se copian las filas nuevas en la tabla del desencadenador y en la tabla inserted.</span><span class="sxs-lookup"><span data-stu-id="87e03-118">An update transaction is similar to a delete operation followed by an insert operation; the old rows are copied to the deleted table first, and then the new rows are copied to the trigger table and to the inserted table.</span></span>  
  
 <span data-ttu-id="87e03-119">Cuando establezca condiciones para el desencadenador, utilice las tablas inserted y deleted correspondientes a la acción que lo activó.</span><span class="sxs-lookup"><span data-stu-id="87e03-119">When you set trigger conditions, use the inserted and deleted tables appropriately for the action that fired the trigger.</span></span> <span data-ttu-id="87e03-120">Aunque no se produce ningún error al hacer referencia a la tabla deleted cuando se prueba una instrucción INSERT, o bien al hacer referencia a la tabla inserted cuando se prueba una instrucción DELETE, estas tablas de prueba del desencadenador no contendrán filas en estos casos.</span><span class="sxs-lookup"><span data-stu-id="87e03-120">Although referencing the deleted table when testing an INSERT or the inserted table when testing a DELETE does not cause any errors, these trigger test tables do not contain any rows in these cases.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="87e03-121">Si las acciones del desencadenador dependen del número de filas afectadas por una modificación de datos, use pruebas (como, por ejemplo, un examen de @@ROWCOUNT) para las modificaciones de datos que afecten a varias filas (instrucciones INSERT, DELETE o UPDATE basadas en una instrucción SELECT) y tome las medidas oportunas.</span><span class="sxs-lookup"><span data-stu-id="87e03-121">If trigger actions depend on the number of rows a data modification effects, use tests (such as an examination of @@ROWCOUNT) for multirow data modifications (an INSERT, DELETE, or UPDATE based on a SELECT statement), and take appropriate actions.</span></span>  
  
 [!INCLUDE[ssCurrent](../../includes/sscurrent-md.md)] <span data-ttu-id="87e03-122">no permite referencias a las columnas `text`, `ntext` o `image` en las tablas insertadas y eliminadas por los desencadenadores AFTER.</span><span class="sxs-lookup"><span data-stu-id="87e03-122">does not allow for `text`, `ntext`, or `image` column references in the inserted and deleted tables for AFTER triggers.</span></span> <span data-ttu-id="87e03-123">Sin embargo, estos tipos de datos se incluyen únicamente por motivos de compatibilidad con versiones anteriores.</span><span class="sxs-lookup"><span data-stu-id="87e03-123">However, these data types are included for backward compatibility purposes only.</span></span> <span data-ttu-id="87e03-124">El almacenamiento preferido para datos de gran tamaño es el uso de tipos de datos `varchar(max)`, `nvarchar(max)` y `varbinary(max)`.</span><span class="sxs-lookup"><span data-stu-id="87e03-124">The preferred storage for large data is to use the `varchar(max)`, `nvarchar(max)`, and `varbinary(max)` data types.</span></span> <span data-ttu-id="87e03-125">Tanto los desencadenadores AFTER como INSTEAD OF admiten los datos `varchar(max)`, `nvarchar(max)` y `varbinary(max)` en las tablas insertadas y eliminadas.</span><span class="sxs-lookup"><span data-stu-id="87e03-125">Both AFTER and INSTEAD OF triggers support `varchar(max)`, `nvarchar(max)`, and `varbinary(max)` data in the inserted and deleted tables.</span></span> <span data-ttu-id="87e03-126">Para obtener más información, vea [CREATE TRIGGER &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-trigger-transact-sql).</span><span class="sxs-lookup"><span data-stu-id="87e03-126">For more information, see [CREATE TRIGGER &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-trigger-transact-sql).</span></span>  
  
 <span data-ttu-id="87e03-127">**Ejemplo del uso de la tabla inserted en un desencadenador para exigir reglas de negocios**</span><span class="sxs-lookup"><span data-stu-id="87e03-127">**An Example of Using the inserted Table in a Trigger to Enforce Business Rules**</span></span>  
  
 <span data-ttu-id="87e03-128">Debido a que las restricciones CHECK solo pueden hacer referencia a las columnas en las que se han definido las restricciones de columna o de tabla, cualquier restricción entre tablas, en este caso, reglas de negocios, debe definirse como desencadenadores.</span><span class="sxs-lookup"><span data-stu-id="87e03-128">Because CHECK constraints can reference only the columns on which the column-level or table-level constraint is defined, any cross-table constraints (in this case, business rules) must be defined as triggers.</span></span>  
  
 <span data-ttu-id="87e03-129">En este ejemplo se crea un desencadenador DML.</span><span class="sxs-lookup"><span data-stu-id="87e03-129">The following example creates a DML trigger.</span></span> <span data-ttu-id="87e03-130">El desencadenador comprueba que la solvencia del proveedor es satisfactoria cuando se intenta insertar un nuevo pedido de compra en la tabla `PurchaseOrderHeader` .</span><span class="sxs-lookup"><span data-stu-id="87e03-130">This trigger checks to make sure the credit rating for the vendor is good when an attempt is made to insert a new purchase order into the `PurchaseOrderHeader` table.</span></span> <span data-ttu-id="87e03-131">Para obtener la solvencia de crédito del proveedor correspondiente al pedido de compra recién insertado, la tabla `Vendor` debe hacer referencia a la tabla insertada y estar combinada con ella.</span><span class="sxs-lookup"><span data-stu-id="87e03-131">To obtain the credit rating of the vendor corresponding to the purchase order that was just inserted, the `Vendor` table must be referenced and joined with the inserted table.</span></span> <span data-ttu-id="87e03-132">Si la solvencia no es satisfactoria, se obtiene un mensaje y no se ejecuta la inserción.</span><span class="sxs-lookup"><span data-stu-id="87e03-132">If the credit rating is too low, a message is displayed and the insertion does not execute.</span></span> <span data-ttu-id="87e03-133">Tenga en cuenta que en este ejemplo no se permiten las modificaciones de datos en varias filas.</span><span class="sxs-lookup"><span data-stu-id="87e03-133">Note that this example does not allow for multirow data modifications.</span></span> <span data-ttu-id="87e03-134">Para más información, consulte [Crear desencadenadores DML para administrar varias filas de datos](../triggers/create-dml-triggers-to-handle-multiple-rows-of-data.md).</span><span class="sxs-lookup"><span data-stu-id="87e03-134">For more information, see [Create DML Triggers to Handle Multiple Rows of Data](../triggers/create-dml-triggers-to-handle-multiple-rows-of-data.md).</span></span>  
  
 [!code-sql[TriggerDDL#CreateTrigger3](../../snippets/tsql/SQL14/tsql/triggerddl/transact-sql/snippet_create_alter_drop_trigger.sql#createtrigger3)]  
  
## <a name="using-the-inserted-and-deleted-tables-in-instead-of-triggers"></a><span data-ttu-id="87e03-135">Utilizar las tablas inserted y deleted en desencadenadores INSTEAD OF</span><span class="sxs-lookup"><span data-stu-id="87e03-135">Using the inserted and deleted Tables in INSTEAD OF Triggers</span></span>  
 <span data-ttu-id="87e03-136">Las tablas inserted y deleted pasadas a desencadenadores INSTEAD OF definidos en tablas siguen las mismas reglas que las tablas inserted y deleted pasadas a desencadenadores AFTER.</span><span class="sxs-lookup"><span data-stu-id="87e03-136">The inserted and deleted tables passed to INSTEAD OF triggers defined on tables follow the same rules as the inserted and deleted tables passed to AFTER triggers.</span></span> <span data-ttu-id="87e03-137">El formato de las tablas inserted y deleted es el mismo que el de una tabla que tiene definido un desencadenador INSTEAD OF.</span><span class="sxs-lookup"><span data-stu-id="87e03-137">The format of the inserted and deleted tables is the same as the format of the table on which the INSTEAD OF trigger is defined.</span></span> <span data-ttu-id="87e03-138">Cada columna de las tablas inserted y deleted se asigna directamente a una columna de la tabla base.</span><span class="sxs-lookup"><span data-stu-id="87e03-138">Each column in the inserted and deleted tables maps directly to a column in the base table.</span></span>  
  
 <span data-ttu-id="87e03-139">Las siguientes reglas aplicables cuando una instrucción INSERT o UPDATE que hace referencia a una tabla con un desencadenador INSTEAD OF debe suministrar valores para las columnas, son las mismas que se utilizan cuando la tabla no tiene un desencadenador INSTEAD OF:</span><span class="sxs-lookup"><span data-stu-id="87e03-139">The following rules regarding when an INSERT or UPDATE statement referencing a table with an INSTEAD OF trigger must supply values for columns are the same as if the table did not have an INSTEAD OF trigger:</span></span>  
  
-   <span data-ttu-id="87e03-140">No se pueden especificar los valores para las columnas calculadas ni para las que contienen el tipo de datos `timestamp`.</span><span class="sxs-lookup"><span data-stu-id="87e03-140">Values cannot be specified for computed columns or columns with a `timestamp` data type.</span></span>  
  
-   <span data-ttu-id="87e03-141">Solo se pueden especificar valores para columnas con la propiedad IDENTITY si la opción IDENTITY_INSERT se ha establecido en ON para la tabla.</span><span class="sxs-lookup"><span data-stu-id="87e03-141">Values cannot be specified for columns with an IDENTITY property, unless IDENTITY_INSERT is ON for that table.</span></span> <span data-ttu-id="87e03-142">Cuando el valor de IDENTITY_INSERT es ON, las instrucciones INSERT deben suministrar un valor.</span><span class="sxs-lookup"><span data-stu-id="87e03-142">When IDENTITY_INSERT is ON, INSERT statements must supply a value.</span></span>  
  
-   <span data-ttu-id="87e03-143">Las instrucciones INSERT deben suministrar valores para todas las columnas NOT NULL que no tienen restricciones DEFAULT.</span><span class="sxs-lookup"><span data-stu-id="87e03-143">INSERT statements must supply values for all NOT NULL columns that do not have DEFAULT constraints.</span></span>  
  
-   <span data-ttu-id="87e03-144">Los valores son opcionales para cualquier columna que admita valores NULL o para cualquier columna NOT NULL que tenga una definición DEFAULT, excepto para las columnas calculadas, de identidad o `timestamp`.</span><span class="sxs-lookup"><span data-stu-id="87e03-144">For any columns except computed, identity, or `timestamp` columns, values are optional for any column that allows nulls, or any NOT NULL column that has a DEFAULT definition.</span></span>  
  
 <span data-ttu-id="87e03-145">Cuando una instrucción INSERT, UPDATE o DELETE hace referencia a una vista que tiene un desencadenador INSTEAD OF, el [!INCLUDE[ssDE](../../includes/ssde-md.md)] llama al desencadenador en lugar de realizar una acción directa en cualquier tabla.</span><span class="sxs-lookup"><span data-stu-id="87e03-145">When an INSERT, UPDATE, or DELETE statement references a view that has an INSTEAD OF trigger, the [!INCLUDE[ssDE](../../includes/ssde-md.md)] calls the trigger instead of taking any direct action against any table.</span></span> <span data-ttu-id="87e03-146">El desencadenador utiliza la información de las tablas inserted y deleted a fin de generar las instrucciones necesarias para implementar la acción solicitada en las tablas base, incluso si el formato de la información de las tablas inserted y deleted generadas para la vista es distinto del formato de los datos de las tablas base.</span><span class="sxs-lookup"><span data-stu-id="87e03-146">The trigger must use the information presented in the inserted and deleted tables to build any statements required to implement the requested action in the base tables, even when the format of the information in the inserted and deleted tables built for the view is different from the format of the data in the base tables.</span></span>  
  
 <span data-ttu-id="87e03-147">El formato de las tablas inserted y deleted pasado a un desencadenador INSTEAD OF definido en una vista coincide con la lista de selección de la instrucción SELECT definida para la vista.</span><span class="sxs-lookup"><span data-stu-id="87e03-147">The format of the inserted and deleted tables passed to an INSTEAD OF trigger defined on a view matches the select list of the SELECT statement defined for the view.</span></span> <span data-ttu-id="87e03-148">Por ejemplo:</span><span class="sxs-lookup"><span data-stu-id="87e03-148">For example:</span></span>  
  
```  
USE AdventureWorks2012;  
GO  
CREATE VIEW dbo.EmployeeNames (BusinessEntityID, LName, FName)  
AS  
SELECT e.BusinessEntityID, p.LastName, p.FirstName  
FROM HumanResources.Employee AS e   
JOIN Person.Person AS p  
ON e.BusinessEntityID = p.BusinessEntityID;  
```  
  
 <span data-ttu-id="87e03-149">El conjunto de resultados de esta vista tiene tres columnas: una columna de tipo `int` y dos columnas de tipo `nvarchar`.</span><span class="sxs-lookup"><span data-stu-id="87e03-149">The result set for this view has three columns: an `int` column and two `nvarchar` columns.</span></span> <span data-ttu-id="87e03-150">Las tablas insertadas y eliminadas a un desencadenador INSTEAD OF también tiene una columna `int` llamada `BusinessEntityID`, una columna `nvarchar` llamada `LName` y una columna `nvarchar` llamada `FName`.</span><span class="sxs-lookup"><span data-stu-id="87e03-150">The inserted and deleted tables passed to an INSTEAD OF trigger defined on the view also have an `int` column named `BusinessEntityID`, an `nvarchar` column named `LName`, and an `nvarchar` column named `FName`.</span></span>  
  
 <span data-ttu-id="87e03-151">La lista de selección de una vista también puede contener expresiones que no se asignen directamente a una sola columna de tabla base.</span><span class="sxs-lookup"><span data-stu-id="87e03-151">The select list of a view can also contain expressions that do not directly map to a single base-table column.</span></span> <span data-ttu-id="87e03-152">Es posible que algunas expresiones de las vistas, como las llamadas a constantes o funciones, no hagan referencia a ninguna columna y puedan omitirse.</span><span class="sxs-lookup"><span data-stu-id="87e03-152">Some view expressions, such as a constant or function invocation, may not reference any columns and can be ignored.</span></span> <span data-ttu-id="87e03-153">Las expresiones complejas pueden hacer referencia a varias columnas, aunque las tablas inserted y deleted solo tienen un valor para cada fila insertada.</span><span class="sxs-lookup"><span data-stu-id="87e03-153">Complex expressions can reference multiple columns, yet the inserted and deleted tables have only one value for each inserted row.</span></span> <span data-ttu-id="87e03-154">Esto mismo se aplica a las expresiones sencillas de una vista si hacen referencia a columnas calculadas que contienen expresiones complejas.</span><span class="sxs-lookup"><span data-stu-id="87e03-154">The same issues apply to simple expressions in a view if they reference a computed column that has a complex expression.</span></span> <span data-ttu-id="87e03-155">Los desencadenadores INSTEAD OF de las vistas pueden tratar estos tipos de expresiones.</span><span class="sxs-lookup"><span data-stu-id="87e03-155">An INSTEAD OF trigger on the view must handle these types of expressions.</span></span>  
  
  
