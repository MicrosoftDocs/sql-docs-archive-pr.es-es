---
title: Tipos de datos de XPath (SQLXML 4,0) | Microsoft Docs
ms.custom: ''
ms.date: 03/06/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: xml
ms.topic: reference
helpviewer_keywords:
- mapping XDR types to XPath types [SQLXML]
- data types [XPath]
- arithmetic operators
- mapping data types [SQLXML]
- relational operators [SQLXML]
- node-set [SQLXML]
- data types [SQLXML], XPath
- XPath operators [SQLXML]
- XDR data type [SQLXML]
- equality operators [SQLXML]
- XPath conversions [SQLXML]
- converting data types [SQLXML]
- Boolean operators
- XPath queries [SQLXML], data types
- XPath data types [SQLXML]
- operators [SQLXML]
ms.assetid: a90374bf-406f-4384-ba81-59478017db68
author: rothja
ms.author: jroth
ms.openlocfilehash: 846fc5a17ac97d30b6f0ab65fee176ac459c20cc
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 08/04/2020
ms.locfileid: "87674728"
---
# <a name="xpath-data-types-sqlxml-40"></a><span data-ttu-id="6c253-102">Tipos de datos de XPath (SQLXML 4.0)</span><span class="sxs-lookup"><span data-stu-id="6c253-102">XPath Data Types (SQLXML 4.0)</span></span>
  [!INCLUDE[msCoName](../../includes/msconame-md.md)]<span data-ttu-id="6c253-103">[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], XPath y esquema XML (XSD) tienen tipos de datos muy diferentes.</span><span class="sxs-lookup"><span data-stu-id="6c253-103">[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], XPath, and XML Schema (XSD) have very different data types.</span></span> <span data-ttu-id="6c253-104">Por ejemplo, XPath no tiene tipos de datos enteros ni fecha, pero [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] y XSD tienen muchos.</span><span class="sxs-lookup"><span data-stu-id="6c253-104">For example, XPath does not have integer or date data types, but [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] and XSD have many.</span></span> <span data-ttu-id="6c253-105">XSD utiliza la precisión del nanosegundo para los valores de hora y [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] utiliza a lo sumo una precisión de 1/300 de segundo.</span><span class="sxs-lookup"><span data-stu-id="6c253-105">XSD uses nanosecond precision for time values, and [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] uses at most 1/300-second precision.</span></span> <span data-ttu-id="6c253-106">Por consiguiente, no siempre es posible asignar un tipo de datos a otro.</span><span class="sxs-lookup"><span data-stu-id="6c253-106">Consequently, mapping one data type to another is not always possible.</span></span> <span data-ttu-id="6c253-107">Para obtener más información sobre [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] la asignación de tipos de datos a tipos de datos XSD, vea conversiones de tipos de [datos y la anotación sql: DataType &#40;SQLXML 4,0&#41;](../sqlxml-annotated-xsd-schemas-using/data-type-coercions-and-the-sql-datatype-annotation-sqlxml-4-0.md).</span><span class="sxs-lookup"><span data-stu-id="6c253-107">For more information about mapping [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] data types to XSD data types, see [Data Type Coercions and the sql:datatype Annotation &#40;SQLXML 4.0&#41;](../sqlxml-annotated-xsd-schemas-using/data-type-coercions-and-the-sql-datatype-annotation-sqlxml-4-0.md).</span></span>  
  
 <span data-ttu-id="6c253-108">XPath tiene tres tipos de datos: `string`, `number` y `boolean`.</span><span class="sxs-lookup"><span data-stu-id="6c253-108">XPath has three data types: `string`, `number`, and `boolean`.</span></span> <span data-ttu-id="6c253-109">El tipo de datos `number` siempre es un IEEE 754 en punto flotante de doble precisión.</span><span class="sxs-lookup"><span data-stu-id="6c253-109">The `number` data type is always an IEEE 754 double-precision floating-point.</span></span> <span data-ttu-id="6c253-110">El [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] `float(53)` tipo de datos es el más cercano a XPath `number` .</span><span class="sxs-lookup"><span data-stu-id="6c253-110">The [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]`float(53)` data type is the closest to XPath `number`.</span></span> <span data-ttu-id="6c253-111">Sin embargo, `float(53)` no es exactamente IEEE 754.</span><span class="sxs-lookup"><span data-stu-id="6c253-111">However, `float(53)` is not exactly IEEE 754.</span></span> <span data-ttu-id="6c253-112">Por ejemplo, no se utiliza NaN (no es un número) ni infinito.</span><span class="sxs-lookup"><span data-stu-id="6c253-112">For example, neither NaN (Not-a-Number) nor infinity is used.</span></span> <span data-ttu-id="6c253-113">Cualquier intento de convertir una cadena no numérica en `number` o de dividir por cero da como resultado un error.</span><span class="sxs-lookup"><span data-stu-id="6c253-113">Attempting to convert a nonnumeric string to `number` and trying to divide by zero results in an error.</span></span>  
  
## <a name="xpath-conversions"></a><span data-ttu-id="6c253-114">Conversiones de XPath</span><span class="sxs-lookup"><span data-stu-id="6c253-114">XPath Conversions</span></span>  
 <span data-ttu-id="6c253-115">Al utilizar una consulta de XPath como `OrderDetail[@UnitPrice > "10.0"]`, las conversiones de tipos de datos implícitas y explícitas pueden cambiar el significado de la consulta de manera sutil.</span><span class="sxs-lookup"><span data-stu-id="6c253-115">When you use an XPath query such as `OrderDetail[@UnitPrice > "10.0"]`, implicit and explicit data type conversions can change the meaning of the query in subtle ways.</span></span> <span data-ttu-id="6c253-116">Por consiguiente, es importante entender cómo se implementan los tipos de datos de XPath.</span><span class="sxs-lookup"><span data-stu-id="6c253-116">Therefore, it is important to understand how XPath data types are implemented.</span></span> <span data-ttu-id="6c253-117">La especificación del lenguaje XPath, XML Path Language (XPath) versión 1,0 W3C propuesto Recomendación 8 de octubre de 1999, se puede encontrar en el sitio web de W3C en http://www.w3.org/TR/1999/PR-xpath-19991008.html .</span><span class="sxs-lookup"><span data-stu-id="6c253-117">The XPath language specification, XML Path Language (XPath) version 1.0 W3C Proposed Recommendation 8 October 1999, can be found at the W3C Web site at http://www.w3.org/TR/1999/PR-xpath-19991008.html.</span></span>  
  
 <span data-ttu-id="6c253-118">Los operadores de XPath se dividen en cuatro categorías:</span><span class="sxs-lookup"><span data-stu-id="6c253-118">XPath operators are divided into four categories:</span></span>  
  
-   <span data-ttu-id="6c253-119">Operadores booleanos (and, or).</span><span class="sxs-lookup"><span data-stu-id="6c253-119">Boolean operators (and, or)</span></span>  
  
-   <span data-ttu-id="6c253-120">Operadores relacionales ( \<, > , \<=, > =)</span><span class="sxs-lookup"><span data-stu-id="6c253-120">Relational operators (\<, >, \<=, >=)</span></span>  
  
-   <span data-ttu-id="6c253-121">Operadores de igualdad (=, !=)</span><span class="sxs-lookup"><span data-stu-id="6c253-121">Equality operators (=, !=)</span></span>  
  
-   <span data-ttu-id="6c253-122">Operadores aritméticos (+, -, \*, div, mod)</span><span class="sxs-lookup"><span data-stu-id="6c253-122">Arithmetic operators (+, -, \*, div, mod)</span></span>  
  
 <span data-ttu-id="6c253-123">Cada categoría de operador convierte de manera diferente los operandos.</span><span class="sxs-lookup"><span data-stu-id="6c253-123">Each category of operator converts its operands differently.</span></span> <span data-ttu-id="6c253-124">Los operadores de XPath convierten implícitamente los operandos si es necesario.</span><span class="sxs-lookup"><span data-stu-id="6c253-124">XPath operators implicitly convert their operands if necessary.</span></span> <span data-ttu-id="6c253-125">Los operadores aritméticos convierten los operandos en `number` y generan un valor numérico.</span><span class="sxs-lookup"><span data-stu-id="6c253-125">Arithmetic operators convert their operands to `number`, and result in a number value.</span></span> <span data-ttu-id="6c253-126">Los operadores booleanos convierten los operandos en `boolean` y generan un valor booleano.</span><span class="sxs-lookup"><span data-stu-id="6c253-126">Boolean operators convert their operands to `boolean`, and result in a Boolean value.</span></span> <span data-ttu-id="6c253-127">Los operadores relacionales y operadores de igualdad generan un valor booleano.</span><span class="sxs-lookup"><span data-stu-id="6c253-127">Relational operators and equality operators result in a Boolean value.</span></span> <span data-ttu-id="6c253-128">Sin embargo, tienen reglas de conversión distintas en función de los tipos de datos originales de sus operandos, como se muestra en esta tabla.</span><span class="sxs-lookup"><span data-stu-id="6c253-128">However, they have different conversion rules depending on the original data types of their operands, as shown in this table.</span></span>  
  
|<span data-ttu-id="6c253-129">Operando</span><span class="sxs-lookup"><span data-stu-id="6c253-129">Operand</span></span>|<span data-ttu-id="6c253-130">Operador relacional</span><span class="sxs-lookup"><span data-stu-id="6c253-130">Relational operator</span></span>|<span data-ttu-id="6c253-131">Operador de igualdad</span><span class="sxs-lookup"><span data-stu-id="6c253-131">Equality operator</span></span>|  
|-------------|-------------------------|-----------------------|  
|<span data-ttu-id="6c253-132">Los dos operandos son conjuntos de nodos.</span><span class="sxs-lookup"><span data-stu-id="6c253-132">Both operands are node-sets.</span></span>|<span data-ttu-id="6c253-133">TRUE si y solo si hay un nodo en un conjunto y un nodo en el segundo conjunto tal que la comparación de sus valores `string` es TRUE.</span><span class="sxs-lookup"><span data-stu-id="6c253-133">TRUE if and only if there is a node in one set and a node in the second set such that the comparison of their `string` values is TRUE.</span></span>|<span data-ttu-id="6c253-134">Igual.</span><span class="sxs-lookup"><span data-stu-id="6c253-134">Same.</span></span>|  
|<span data-ttu-id="6c253-135">Uno es un conjunto de nodos, el otro un `string`.</span><span class="sxs-lookup"><span data-stu-id="6c253-135">One is a node-set, the other a `string`.</span></span>|<span data-ttu-id="6c253-136">TRUE si y solo si hay un nodo en el conjunto de nodos tal que cuando se convierte en `number`, la comparación de éste con el `string` convertido en `number` es TRUE.</span><span class="sxs-lookup"><span data-stu-id="6c253-136">TRUE if and only if there is a node in the node-set such that when converted to `number`, the comparison of it with the `string` converted to `number` is TRUE.</span></span>|<span data-ttu-id="6c253-137">TRUE si y solo si hay un nodo en el conjunto de nodos tal que cuando se convierte en `string`, la comparación de éste con el `string` es TRUE.</span><span class="sxs-lookup"><span data-stu-id="6c253-137">TRUE if and only if there is a node in the node-set such that when converted to `string`, the comparison of it with the `string` is TRUE.</span></span>|  
|<span data-ttu-id="6c253-138">Uno es un conjunto de nodos, el otro un `number`.</span><span class="sxs-lookup"><span data-stu-id="6c253-138">One is a node-set, the other a `number`.</span></span>|<span data-ttu-id="6c253-139">TRUE si y solo si hay un nodo en el conjunto de nodos tal que cuando se convierte en `number`, la comparación de éste con el `number` es TRUE.</span><span class="sxs-lookup"><span data-stu-id="6c253-139">TRUE if and only if there is a node in the node-set such that when converted to `number`, the comparison of it with the `number` is TRUE.</span></span>|<span data-ttu-id="6c253-140">Igual.</span><span class="sxs-lookup"><span data-stu-id="6c253-140">Same.</span></span>|  
|<span data-ttu-id="6c253-141">Uno es un conjunto de nodos, el otro un `boolean`.</span><span class="sxs-lookup"><span data-stu-id="6c253-141">One is a node-set, the other a `boolean`.</span></span>|<span data-ttu-id="6c253-142">TRUE si y solo si hay un nodo en el conjunto de nodos tal que cuando se convierte en `boolean` y luego en `number`, la comparación de éste con el `boolean` convertido en `number` es TRUE.</span><span class="sxs-lookup"><span data-stu-id="6c253-142">TRUE if and only if there is a node in the node-set such that when converted to `boolean` and then to `number`, the comparison of it with the `boolean` converted to `number` is TRUE.</span></span>|<span data-ttu-id="6c253-143">TRUE si y solo si hay un nodo en el conjunto de nodos tal que cuando se convierte en `boolean`, la comparación de éste con el `boolean` es TRUE.</span><span class="sxs-lookup"><span data-stu-id="6c253-143">TRUE if and only if there is a node in the node-set such that when converted to `boolean`, the comparison of it with the `boolean` is TRUE.</span></span>|  
|<span data-ttu-id="6c253-144">Ninguno es un conjunto de nodos.</span><span class="sxs-lookup"><span data-stu-id="6c253-144">Neither is a node-set.</span></span>|<span data-ttu-id="6c253-145">Convierta los dos operandos en `number` y, a continuación, compare.</span><span class="sxs-lookup"><span data-stu-id="6c253-145">Convert both operands to `number` and then compare.</span></span>|<span data-ttu-id="6c253-146">Convierta los dos operandos en un tipo común y, a continuación, compare.</span><span class="sxs-lookup"><span data-stu-id="6c253-146">Convert both operands to a common type and then compare.</span></span> <span data-ttu-id="6c253-147">Convierta en `boolean` si es `boolean`, en `number` si es `number`; de lo contrario, convierta en `string`.</span><span class="sxs-lookup"><span data-stu-id="6c253-147">Convert to `boolean` if either is `boolean`, `number` if either is `number`; otherwise, convert to `string`.</span></span>|  
  
> [!NOTE]  
>  <span data-ttu-id="6c253-148">Dado que los operadores relacionales de XPath convierten siempre los operandos en `number`, las comparaciones de `string` no son posibles.</span><span class="sxs-lookup"><span data-stu-id="6c253-148">Because XPath relational operators always convert their operands to `number`, `string` comparisons are not possible.</span></span> <span data-ttu-id="6c253-149">Para incluir las comparaciones de fecha, SQL Server 2000 ofrece esta variación a la especificación de XPath: cuando un operador relacional compara un `string` con un `string`, un conjunto de nodos con un `string` o un conjunto de nodos con valores de cadena con un conjunto de nodos con valores de cadena, se realiza una comparación de `string` (no una comparación de `number`).</span><span class="sxs-lookup"><span data-stu-id="6c253-149">To include date comparisons, SQL Server 2000 offers this variation to the XPath specification: When a relational operator compares a `string` to a `string`, a node-set to a `string`, or a string-valued node-set to a string-valued node-set, a `string` comparison (not a `number` comparison) is performed.</span></span>  
  
## <a name="node-set-conversions"></a><span data-ttu-id="6c253-150">Conversiones de conjunto de nodos</span><span class="sxs-lookup"><span data-stu-id="6c253-150">Node-Set Conversions</span></span>  
 <span data-ttu-id="6c253-151">Las conversiones de conjunto de nodos no son siempre intuitivas.</span><span class="sxs-lookup"><span data-stu-id="6c253-151">Node-set conversions are not always intuitive.</span></span> <span data-ttu-id="6c253-152">Un conjunto de nodos se convierte en un `string` tomando el valor de cadena de únicamente primer nodo del conjunto.</span><span class="sxs-lookup"><span data-stu-id="6c253-152">A node-set is converted to a `string` by taking the string value of only the first node in the set.</span></span> <span data-ttu-id="6c253-153">Un conjunto de nodos se convierte en `number` convirtiéndolo en `string` y convirtiendo luego el `string` en `number`.</span><span class="sxs-lookup"><span data-stu-id="6c253-153">A node-set is converted to `number` by converting it to `string`, and then converting `string` to `number`.</span></span> <span data-ttu-id="6c253-154">Un conjunto de nodos se convierte en `boolean` probando su existencia.</span><span class="sxs-lookup"><span data-stu-id="6c253-154">A node-set is converted to `boolean` by testing for its existence.</span></span>  
  
> [!NOTE]  
>  [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] <span data-ttu-id="6c253-155">no realiza la selección por posición en los conjuntos de nodos: por ejemplo, la consulta de XPath `Customer[3]` significa el tercer cliente; este tipo de selección por posición no se admite en [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)].</span><span class="sxs-lookup"><span data-stu-id="6c253-155">does not perform positional selection on node-sets: for example, the XPath query `Customer[3]` means the third customer; this type of positional selection is not supported in [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="6c253-156">Por consiguiente, las conversiones de conjunto de nodos en `string` o de conjunto de nodos en `number` descritas en la especificación de XPath no se implementan.</span><span class="sxs-lookup"><span data-stu-id="6c253-156">Therefore, the node-set-to-`string` or node-set-to-`number` conversions as described by the XPath specification are not implemented.</span></span> [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] <span data-ttu-id="6c253-157">utiliza la semántica "cualquiera" donde la especificación de XPath especifica la semántica "primero".</span><span class="sxs-lookup"><span data-stu-id="6c253-157">uses "any" semantics wherever the XPath specification specifies "first" semantics.</span></span> <span data-ttu-id="6c253-158">Por ejemplo, según la especificación XPath de W3C, la consulta XPath `Order[OrderDetail/@UnitPrice > 10.0]` selecciona los pedidos con el primer **OrderDetail** que tiene un **UnitPrice** mayor que 10,0.</span><span class="sxs-lookup"><span data-stu-id="6c253-158">For example, based on the W3C XPath specification, the XPath query `Order[OrderDetail/@UnitPrice > 10.0]` selects those orders with the first **OrderDetail** that has a **UnitPrice** greater than 10.0.</span></span> <span data-ttu-id="6c253-159">En [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] , esta consulta XPath selecciona los pedidos con cualquier **OrderDetail** que tenga un **UnitPrice** mayor que 10,0.</span><span class="sxs-lookup"><span data-stu-id="6c253-159">In [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], this XPath query selects those orders with any **OrderDetail** that has a **UnitPrice** greater than 10.0.</span></span>  
  
 <span data-ttu-id="6c253-160">La conversión a `boolean` genera una prueba de existencia; por consiguiente, la consulta de XPath `Products[@Discontinued=true()]` es equivalente a la expresión de SQL "Products.Discontinued is not null", no a la expresión de SQL "Products.Discontinued = 1".</span><span class="sxs-lookup"><span data-stu-id="6c253-160">Conversion to `boolean` generates an existence test; therefore, the XPath query `Products[@Discontinued=true()]` is equivalent to the SQL expression "Products.Discontinued is not null", not the SQL expression "Products.Discontinued = 1".</span></span> <span data-ttu-id="6c253-161">Para hacer la consulta equivalente a la última expresión de SQL, primero convierta el conjunto de nodos a un tipo que no sea `boolean`, como `number`.</span><span class="sxs-lookup"><span data-stu-id="6c253-161">To make the query equivalent to the latter SQL expression, first convert the node-set to a non-`boolean` type, such as `number`.</span></span> <span data-ttu-id="6c253-162">Por ejemplo, `Products[number(@Discontinued) = true()]`.</span><span class="sxs-lookup"><span data-stu-id="6c253-162">For example, `Products[number(@Discontinued) = true()]`.</span></span>  
  
 <span data-ttu-id="6c253-163">Dado que la mayoría de los operadores están definidos para ser TRUE si son TRUE para cualquiera o uno de los nodos del conjunto de nodos, estas operaciones siempre se evalúan como FALSE si el conjunto de nodos está vacío.</span><span class="sxs-lookup"><span data-stu-id="6c253-163">Because most operators are defined to be TRUE if they are TRUE for any or one of the nodes in the node-set, these operations always evaluate to FALSE if the node-set is empty.</span></span> <span data-ttu-id="6c253-164">Así, si A está vacío, `A = B` y `A != B` son FALSE y `not(A=B)` y `not(A!=B)` son TRUE.</span><span class="sxs-lookup"><span data-stu-id="6c253-164">Thus, if A is empty, both `A = B` and `A != B` are FALSE, and `not(A=B)` and `not(A!=B)` are TRUE.</span></span>  
  
 <span data-ttu-id="6c253-165">Normalmente, un atributo o elemento que se asigna a una columna existe si el valor de esa columna de la base de datos no es `null`.</span><span class="sxs-lookup"><span data-stu-id="6c253-165">Usually, an attribute or element that maps to a column exists if the value of that column in the database is not `null`.</span></span> <span data-ttu-id="6c253-166">Los elementos que se asignan a filas existen si cualquiera de sus elementos secundarios existe.</span><span class="sxs-lookup"><span data-stu-id="6c253-166">Elements that map to rows exist if any of their children exist.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="6c253-167">Los elementos anotados con `is-constant` siempre existen.</span><span class="sxs-lookup"><span data-stu-id="6c253-167">Elements annotated with `is-constant` always exist.</span></span> <span data-ttu-id="6c253-168">Por consiguiente, los predicados XPath no se pueden utilizar en los elementos `is-constant`.</span><span class="sxs-lookup"><span data-stu-id="6c253-168">Consequently, XPath predicates cannot be used on `is-constant` elements.</span></span>  
  
 <span data-ttu-id="6c253-169">Cuando un conjunto de nodos se convierte en `string` o `number`, su tipo XDR (si existe) se inspecciona en el esquema anotado y ese tipo se utiliza para determinar la conversión que se requiere.</span><span class="sxs-lookup"><span data-stu-id="6c253-169">When a node-set is converted to `string` or `number`, its XDR type (if any) is inspected in the annotated schema and that type is used to determine the conversion that is required.</span></span>  
  
## <a name="mapping-xdr-data-types-to-xpath-data-types"></a><span data-ttu-id="6c253-170">Asignar tipos de datos de XDR a tipos de datos de XPath</span><span class="sxs-lookup"><span data-stu-id="6c253-170">Mapping XDR Data Types to XPath Data Types</span></span>  
 <span data-ttu-id="6c253-171">El tipo de datos XPath de un nodo se deriva del tipo de datos XDR en el esquema, tal y como se muestra en la tabla siguiente (el nodo **EmployeeID** se utiliza con fines ilustrativos).</span><span class="sxs-lookup"><span data-stu-id="6c253-171">The XPath data type of a node is derived from the XDR data type in the schema, as shown in the following table (the node **EmployeeID** is used for illustrative purpose).</span></span>  
  
|<span data-ttu-id="6c253-172">Tipo de datos XDR</span><span class="sxs-lookup"><span data-stu-id="6c253-172">XDR data type</span></span>|<span data-ttu-id="6c253-173">Tipo de datos de XPath</span><span class="sxs-lookup"><span data-stu-id="6c253-173">Equivalent</span></span><br /><br /> <span data-ttu-id="6c253-174">equivalente</span><span class="sxs-lookup"><span data-stu-id="6c253-174">XPath data type</span></span>|<span data-ttu-id="6c253-175">Conversión de SQL Server utilizada</span><span class="sxs-lookup"><span data-stu-id="6c253-175">SQL Server conversion used</span></span>|  
|-------------------|------------------------------------|--------------------------------|  
|<span data-ttu-id="6c253-176">Nonebin.base64bin.hex</span><span class="sxs-lookup"><span data-stu-id="6c253-176">Nonebin.base64bin.hex</span></span>|<span data-ttu-id="6c253-177">N/D</span><span class="sxs-lookup"><span data-stu-id="6c253-177">N/A</span></span>|<span data-ttu-id="6c253-178">NingunaEmployeeID</span><span class="sxs-lookup"><span data-stu-id="6c253-178">NoneEmployeeID</span></span>|  
|<span data-ttu-id="6c253-179">boolean</span><span class="sxs-lookup"><span data-stu-id="6c253-179">boolean</span></span>|<span data-ttu-id="6c253-180">boolean</span><span class="sxs-lookup"><span data-stu-id="6c253-180">boolean</span></span>|<span data-ttu-id="6c253-181">CONVERT (bit, IdEmpleado)</span><span class="sxs-lookup"><span data-stu-id="6c253-181">CONVERT(bit, EmployeeID)</span></span>|  
|<span data-ttu-id="6c253-182">number, int, float,i1, i2, i4, i8,r4, r8ui1, ui2, ui4, ui8</span><span class="sxs-lookup"><span data-stu-id="6c253-182">number, int, float,i1, i2, i4, i8,r4, r8ui1, ui2, ui4, ui8</span></span>|<span data-ttu-id="6c253-183">number</span><span class="sxs-lookup"><span data-stu-id="6c253-183">number</span></span>|<span data-ttu-id="6c253-184">CONVERT(float(53), EmployeeID)</span><span class="sxs-lookup"><span data-stu-id="6c253-184">CONVERT(float(53), EmployeeID)</span></span>|  
|<span data-ttu-id="6c253-185">id, idref, idrefsentity, entities, enumerationnotation, nmtoken, nmtokens, chardate, Timedate, Time.tz, string, uri, uuid</span><span class="sxs-lookup"><span data-stu-id="6c253-185">id, idref, idrefsentity, entities, enumerationnotation, nmtoken, nmtokens, chardate, Timedate, Time.tz, string, uri, uuid</span></span>|<span data-ttu-id="6c253-186">string</span><span class="sxs-lookup"><span data-stu-id="6c253-186">string</span></span>|<span data-ttu-id="6c253-187">CONVERT(nvarchar(4000), EmployeeID, 126)</span><span class="sxs-lookup"><span data-stu-id="6c253-187">CONVERT(nvarchar(4000), EmployeeID, 126)</span></span>|  
|<span data-ttu-id="6c253-188">fixed14.4</span><span class="sxs-lookup"><span data-stu-id="6c253-188">fixed14.4</span></span>|<span data-ttu-id="6c253-189">N/D (no hay ningún tipo de datos de XPath que sea equivalente al tipo de datos fixed14.4 de XDR)</span><span class="sxs-lookup"><span data-stu-id="6c253-189">N/A(There is no data type in XPath that is equivalent to the fixed14.4 XDR data type)</span></span>|<span data-ttu-id="6c253-190">CONVERT(money, EmployeeID)</span><span class="sxs-lookup"><span data-stu-id="6c253-190">CONVERT(money, EmployeeID)</span></span>|  
|<span data-ttu-id="6c253-191">date</span><span class="sxs-lookup"><span data-stu-id="6c253-191">date</span></span>|<span data-ttu-id="6c253-192">string</span><span class="sxs-lookup"><span data-stu-id="6c253-192">string</span></span>|<span data-ttu-id="6c253-193">LEFT(CONVERT(nvarchar(4000), EmployeeID, 126), 10)</span><span class="sxs-lookup"><span data-stu-id="6c253-193">LEFT(CONVERT(nvarchar(4000), EmployeeID, 126), 10)</span></span>|  
|<span data-ttu-id="6c253-194">time</span><span class="sxs-lookup"><span data-stu-id="6c253-194">time</span></span><br /><br /> <span data-ttu-id="6c253-195">time.tz</span><span class="sxs-lookup"><span data-stu-id="6c253-195">time.tz</span></span>|<span data-ttu-id="6c253-196">string</span><span class="sxs-lookup"><span data-stu-id="6c253-196">string</span></span>|<span data-ttu-id="6c253-197">SUBSTRING(CONVERT(nvarchar(4000), EmployeeID, 126), 1 + CHARINDEX(N'T', CONVERT(nvarchar(4000), EmployeeID, 126)), 24)</span><span class="sxs-lookup"><span data-stu-id="6c253-197">SUBSTRING(CONVERT(nvarchar(4000), EmployeeID, 126), 1 + CHARINDEX(N'T', CONVERT(nvarchar(4000), EmployeeID, 126)), 24)</span></span>|  
  
 <span data-ttu-id="6c253-198">Las conversiones de fecha y hora están diseñadas para funcionar si el valor se almacena en la base de datos mediante el [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] `datetime` tipo de datos o `string` .</span><span class="sxs-lookup"><span data-stu-id="6c253-198">The date and time conversions are designed to work whether the value is stored in the database using the [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]`datetime` data type or a `string`.</span></span> <span data-ttu-id="6c253-199">Tenga en cuenta que el [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] `datetime` tipo de datos no utiliza `timezone` y tiene una precisión menor que el `time` tipo de datos XML.</span><span class="sxs-lookup"><span data-stu-id="6c253-199">Note that the [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]`datetime` data type does not use `timezone` and has a smaller precision than the XML `time` data type.</span></span> <span data-ttu-id="6c253-200">Para incluir el tipo de datos `timezone` o una precisión adicional, almacene los datos en [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] utilizando un tipo `string`.</span><span class="sxs-lookup"><span data-stu-id="6c253-200">To include the `timezone` data type or additional precision, store the data in [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] using a `string` type.</span></span>  
  
 <span data-ttu-id="6c253-201">Cuando un nodo se convierte del tipo de datos de XDR al tipo de datos de XPath, a veces es necesaria una conversión adicional (de un tipo de datos de XPath a otro tipo de datos de XPath).</span><span class="sxs-lookup"><span data-stu-id="6c253-201">When a node is converted from its XDR data type to the XPath data type, additional conversion is sometimes necessary (from one XPath data type to another XPath data type).</span></span> <span data-ttu-id="6c253-202">Por ejemplo, considere esta consulta de XPath:</span><span class="sxs-lookup"><span data-stu-id="6c253-202">For example, consider this XPath query:</span></span>  
  
```  
(@m + 3) = 4  
```  
  
 <span data-ttu-id="6c253-203">Si @m es del `fixed14.4` tipo de datos XDR, la conversión del tipo de datos XDR al tipo de datos XPath se realiza mediante:</span><span class="sxs-lookup"><span data-stu-id="6c253-203">If @m is of the `fixed14.4` XDR data type, the conversion from XDR data type to XPath data type is accomplished using:</span></span>  
  
```  
CONVERT(money, m)  
```  
  
 <span data-ttu-id="6c253-204">En esta conversión, el nodo `m` se convierte de `fixed14.4` en `money`.</span><span class="sxs-lookup"><span data-stu-id="6c253-204">In this conversion, the node `m` is converted from `fixed14.4` to `money`.</span></span> <span data-ttu-id="6c253-205">Sin embargo, si se agrega el valor 3, se requiere una conversión adicional:</span><span class="sxs-lookup"><span data-stu-id="6c253-205">However, adding the value of 3, requires additional conversion:</span></span>  
  
```  
CONVERT(float(CONVERT(money, m))  
```  
  
 <span data-ttu-id="6c253-206">La expresión de XPath se evalúa como:</span><span class="sxs-lookup"><span data-stu-id="6c253-206">The XPath expression is evaluated as:</span></span>  
  
```  
CONVERT(float(CONVERT(money, m)) + CONVERT(float(53), 3) = CONVERT(float(53), 3)  
```  
  
 <span data-ttu-id="6c253-207">Como se muestra en la tabla siguiente, ésta es la misma conversión que se aplica para otras expresiones de XPath (como expresiones de literales o compuestas).</span><span class="sxs-lookup"><span data-stu-id="6c253-207">As shown in the following table, this is the same conversion that is applied for other XPath expressions (such as literals or compound expressions).</span></span>  
  
||||||  
|-|-|-|-|-|  
||<span data-ttu-id="6c253-208">X es desconocido</span><span class="sxs-lookup"><span data-stu-id="6c253-208">X is unknown</span></span>|<span data-ttu-id="6c253-209">X es de tipo `string`</span><span class="sxs-lookup"><span data-stu-id="6c253-209">X is `string`</span></span>|<span data-ttu-id="6c253-210">X es de tipo `number`</span><span class="sxs-lookup"><span data-stu-id="6c253-210">X is `number`</span></span>|<span data-ttu-id="6c253-211">X es de tipo `boolean`</span><span class="sxs-lookup"><span data-stu-id="6c253-211">X is `boolean`</span></span>|  
|<span data-ttu-id="6c253-212">string(X)</span><span class="sxs-lookup"><span data-stu-id="6c253-212">string(X)</span></span>|<span data-ttu-id="6c253-213">CONVERT (nvarchar(4000), X, 126)</span><span class="sxs-lookup"><span data-stu-id="6c253-213">CONVERT (nvarchar(4000), X, 126)</span></span>|-|<span data-ttu-id="6c253-214">CONVERT (nvarchar(4000), X, 126)</span><span class="sxs-lookup"><span data-stu-id="6c253-214">CONVERT (nvarchar(4000), X, 126)</span></span>|<span data-ttu-id="6c253-215">CASE WHEN X THEN N'true' ELSE N'false' END</span><span class="sxs-lookup"><span data-stu-id="6c253-215">CASE WHEN X THEN N'true' ELSE N'false' END</span></span>|  
|<span data-ttu-id="6c253-216">number(X)</span><span class="sxs-lookup"><span data-stu-id="6c253-216">number(X)</span></span>|<span data-ttu-id="6c253-217">CONVERT (float(53), X)</span><span class="sxs-lookup"><span data-stu-id="6c253-217">CONVERT (float(53), X)</span></span>|<span data-ttu-id="6c253-218">CONVERT (float(53), X)</span><span class="sxs-lookup"><span data-stu-id="6c253-218">CONVERT (float(53), X)</span></span>|-|<span data-ttu-id="6c253-219">CASE WHEN X THEN 1 ELSE 0 END</span><span class="sxs-lookup"><span data-stu-id="6c253-219">CASE WHEN X THEN 1 ELSE 0 END</span></span>|  
|<span data-ttu-id="6c253-220">boolean(X)</span><span class="sxs-lookup"><span data-stu-id="6c253-220">boolean(X)</span></span>|-|<span data-ttu-id="6c253-221">LEN (X) > 0</span><span class="sxs-lookup"><span data-stu-id="6c253-221">LEN(X) > 0</span></span>|<span data-ttu-id="6c253-222">X != 0</span><span class="sxs-lookup"><span data-stu-id="6c253-222">X != 0</span></span>|-|  
  
## <a name="examples"></a><span data-ttu-id="6c253-223">Ejemplos</span><span class="sxs-lookup"><span data-stu-id="6c253-223">Examples</span></span>  
  
### <a name="a-convert-a-data-type-in-an-xpath-query"></a><span data-ttu-id="6c253-224">A.</span><span class="sxs-lookup"><span data-stu-id="6c253-224">A.</span></span> <span data-ttu-id="6c253-225">Convertir un tipo de datos en una consulta de XPath</span><span class="sxs-lookup"><span data-stu-id="6c253-225">Convert a data type in an XPath query</span></span>  
 <span data-ttu-id="6c253-226">En la siguiente consulta XPath especificada en un esquema XSD anotado, la consulta selecciona todos los nodos **Employee** con el valor del atributo **EmployeeID** de E-1, donde "E-" es el prefijo especificado utilizando la `sql:id-prefix` anotación.</span><span class="sxs-lookup"><span data-stu-id="6c253-226">In the following XPath query specified against an annotated XSD schema, the query selects all **Employee** nodes with the **EmployeeID** attribute value of E-1, where "E-" is the prefix specified using the `sql:id-prefix` annotation.</span></span>  
  
 `Employee[@EmployeeID="E-1"]`  
  
 <span data-ttu-id="6c253-227">El predicado de la consulta es equivalente a la expresión de SQL:</span><span class="sxs-lookup"><span data-stu-id="6c253-227">The predicate in the query is equivalent to the SQL expression:</span></span>  
  
 `N'E-' + CONVERT(nvarchar(4000), Employees.EmployeeID, 126) = N'E-1'`  
  
 <span data-ttu-id="6c253-228">Dado que **EmployeeID** es uno de los `id` valores de tipo de datos ( `idref` , `idrefs` ,,, etc. `nmtoken` `nmtokens` ) en el esquema XSD, **EmployeeID** se convierte al `string` tipo de datos XPath mediante las reglas de conversión descritas anteriormente.</span><span class="sxs-lookup"><span data-stu-id="6c253-228">Because **EmployeeID** is one of the `id` (`idref`, `idrefs`, `nmtoken`, `nmtokens`, and so on) data type values in the XSD schema, **EmployeeID** is converted to the `string` XPath data type using the conversion rules described previously.</span></span>  
  
 `CONVERT(nvarchar(4000), Employees.EmployeeID, 126)`  
  
 <span data-ttu-id="6c253-229">El prefijo "E -" se agrega a la cadena y el resultado se compara entonces con `N'E-1'`.</span><span class="sxs-lookup"><span data-stu-id="6c253-229">The "E-" prefix is added to the string, and the result is then compared with `N'E-1'`.</span></span>  
  
### <a name="b-perform-several-data-type-conversions-in-an-xpath-query"></a><span data-ttu-id="6c253-230">B.</span><span class="sxs-lookup"><span data-stu-id="6c253-230">B.</span></span> <span data-ttu-id="6c253-231">Realizar varias conversiones de tipos de datos en una consulta de XPath</span><span class="sxs-lookup"><span data-stu-id="6c253-231">Perform several data type conversions in an XPath query</span></span>  
 <span data-ttu-id="6c253-232">Considere esta consulta especificada de XPath en un esquema XSD anotado: `OrderDetail[@UnitPrice * @OrderQty > 98]`</span><span class="sxs-lookup"><span data-stu-id="6c253-232">Consider this XPath query specified against an annotated XSD schema: `OrderDetail[@UnitPrice * @OrderQty > 98]`</span></span>  
  
 <span data-ttu-id="6c253-233">Esta consulta XPath devuelve todos los **\<OrderDetail>** elementos que satisfacen el predicado `@UnitPrice * @OrderQty > 98` .</span><span class="sxs-lookup"><span data-stu-id="6c253-233">This XPath query returns all the **\<OrderDetail>** elements satisfying the predicate `@UnitPrice * @OrderQty > 98`.</span></span> <span data-ttu-id="6c253-234">Si **UnitPrice** se anota con un `fixed14.4` tipo de datos en el esquema anotado, este predicado es equivalente a la expresión SQL:</span><span class="sxs-lookup"><span data-stu-id="6c253-234">If the **UnitPrice** is annotated with a `fixed14.4` data type in the annotated schema, this predicate is equivalent to the SQL expression:</span></span>  
  
 `CONVERT(float(53), CONVERT(money, OrderDetail.UnitPrice)) * CONVERT(float(53), OrderDetail.OrderQty) > CONVERT(float(53), 98)`  
  
 <span data-ttu-id="6c253-235">Para convertir los valores de la consulta de XPath, la primera conversión convierte el tipo de datos de XDR al tipo de datos de XPath.</span><span class="sxs-lookup"><span data-stu-id="6c253-235">In converting the values in the XPath query, the first conversion converts the XDR data type to the XPath data type.</span></span> <span data-ttu-id="6c253-236">Dado que el tipo de datos XSD de **UnitPrice** es `fixed14.4` , tal y como se describe en la tabla anterior, esta es la primera conversión que se usa:</span><span class="sxs-lookup"><span data-stu-id="6c253-236">Because the XSD data type of **UnitPrice** is `fixed14.4`, as described in the previous table, this is the first conversion that is used:</span></span>  
  
```  
CONVERT(money, OrderDetail.UnitPrice))   
```  
  
 <span data-ttu-id="6c253-237">Dado que los operadores aritméticos convierten los operandos al tipo de datos `number` de XPath, se aplica la segunda conversión (de un tipo de datos de XPath a otro tipo de datos de XPath) en la que el valor se convierte a `float(53)` (`float(53)` se aproxima al tipo de datos `number` de XPath):</span><span class="sxs-lookup"><span data-stu-id="6c253-237">Because the arithmetic operators convert their operands to the `number` XPath data type, the second conversion (from one XPath data type to another XPath data type) is applied in which the value is converted to `float(53)` (`float(53)` is close to the XPath `number` data type):</span></span>  
  
```  
CONVERT(float(53), CONVERT(money, OrderDetail.UnitPrice))   
```  
  
 <span data-ttu-id="6c253-238">Suponiendo que el atributo **OrderQty** no tiene ningún tipo de datos XSD, **OrderQty** se convierte en un `number` tipo de datos de XPath en una sola conversión:</span><span class="sxs-lookup"><span data-stu-id="6c253-238">Assuming the **OrderQty** attribute has no XSD data type, **OrderQty** is converted to a `number` XPath data type in a single conversion:</span></span>  
  
```  
CONVERT(float(53), OrderDetail.OrderQty)  
```  
  
 <span data-ttu-id="6c253-239">De igual forma, el valor 98 se convierte en el tipo de datos `number` de XPath:</span><span class="sxs-lookup"><span data-stu-id="6c253-239">Similarly, the value 98 is converted to the `number` XPath data type:</span></span>  
  
```  
CONVERT(float(53), 98)  
```  
  
> [!NOTE]  
>  <span data-ttu-id="6c253-240">Si el tipo de datos de XSD utilizado en el esquema es incompatible con el tipo de datos de [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] subyacente de la base de datos o si se realiza una conversión de tipo de datos de XPath imposible, [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] puede devolver un error.</span><span class="sxs-lookup"><span data-stu-id="6c253-240">If the XSD data type used in the schema is incompatible with the underlying [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] data type in the database, or if an impossible XPath data type conversion is performed, [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] may return an error.</span></span> <span data-ttu-id="6c253-241">Por ejemplo, si el atributo **EmployeeID** se anota con la `id-prefix` anotación, el XPath `Employee[@EmployeeID=1]` genera un error, porque **EmployeeID** tiene la `id-prefix` anotación y no se puede convertir en `number` .</span><span class="sxs-lookup"><span data-stu-id="6c253-241">For example, if the **EmployeeID** attribute is annotated with `id-prefix` annotation, the XPath `Employee[@EmployeeID=1]` generates an error, because **EmployeeID** has the `id-prefix` annotation and cannot be converted to `number`.</span></span>  
  
  
