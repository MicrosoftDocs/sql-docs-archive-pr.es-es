---
title: Capturando datos de resultados | Microsoft Docs
ms.custom: ''
ms.date: 03/06/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: native-client
ms.topic: reference
helpviewer_keywords:
- SQLFetchScroll function
- SQL Server Native Client ODBC driver, result sets
- ODBC applications, result sets
- data types [ODBC], fetching
- SQLBindCol function
- result sets [ODBC], fetching
- fetching [ODBC]
- ODBC data types, fetching
- SQLFetch function
- SQL Server Native Client ODBC driver, data types
- SQLGetData function
ms.assetid: b289c7fb-5017-4d7e-a2d3-19401e9fc4cd
author: rothja
ms.author: jroth
ms.openlocfilehash: 7eb038d431dd7f733c36e5913d72cdc6a161acad
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 08/04/2020
ms.locfileid: "87750870"
---
# <a name="fetching-result-data"></a><span data-ttu-id="09f08-102">Capturar datos de resultados</span><span class="sxs-lookup"><span data-stu-id="09f08-102">Fetching Result Data</span></span>
  <span data-ttu-id="09f08-103">Una aplicación ODBC tiene tres opciones para capturar los datos de resultados.</span><span class="sxs-lookup"><span data-stu-id="09f08-103">An ODBC application has three options for fetching result data.</span></span>  
  
 <span data-ttu-id="09f08-104">La primera opción se basa en [SQLBindCol](../native-client-odbc-api/sqlbindcol.md).</span><span class="sxs-lookup"><span data-stu-id="09f08-104">The first option is based on [SQLBindCol](../native-client-odbc-api/sqlbindcol.md).</span></span> <span data-ttu-id="09f08-105">Antes de obtener el conjunto de resultados, la aplicación usa **SQLBindCol** para enlazar cada columna del conjunto de resultados a una variable de programa.</span><span class="sxs-lookup"><span data-stu-id="09f08-105">Before fetching the result set, the application uses **SQLBindCol** to bind each column in the result set to a program variable.</span></span> <span data-ttu-id="09f08-106">Una vez enlazadas las columnas, el controlador transfiere los datos de la fila actual a las variables enlazadas a las columnas del conjunto de resultados cada vez que la aplicación llama a **SQLFetch** o a [SQLFetchScroll](../native-client-odbc-api/sqlfetchscroll.md).</span><span class="sxs-lookup"><span data-stu-id="09f08-106">After the columns have been bound, the driver transfers the data of the current row into the variables bound to the result set columns each time the application calls **SQLFetch** or [SQLFetchScroll](../native-client-odbc-api/sqlfetchscroll.md).</span></span> <span data-ttu-id="09f08-107">El controlador administra las conversiones de datos si la columna de conjunto de resultados y la variable de programa tienen tipos de datos distintos.</span><span class="sxs-lookup"><span data-stu-id="09f08-107">The driver handles data conversions if the result set column and program variable have different data types.</span></span> <span data-ttu-id="09f08-108">Si la aplicación tiene SQL_ATTR_ROW_ARRAY_SIZE establecido en un valor mayor que 1, puede enlazar columnas de resultados a matrices de variables, que se rellenarán en cada llamada a **SQLFetchScroll**.</span><span class="sxs-lookup"><span data-stu-id="09f08-108">If the application has SQL_ATTR_ROW_ARRAY_SIZE set greater than 1, it can bind result columns to arrays of variables, which will all be filled on each call to **SQLFetchScroll**.</span></span>  
  
 <span data-ttu-id="09f08-109">La segunda opción se basa en [SQLGetData](../native-client-odbc-api/sqlgetdata.md).</span><span class="sxs-lookup"><span data-stu-id="09f08-109">The second option is based on [SQLGetData](../native-client-odbc-api/sqlgetdata.md).</span></span> <span data-ttu-id="09f08-110">La aplicación no usa **SQLBindCol** para enlazar columnas del conjunto de resultados a variables de programa.</span><span class="sxs-lookup"><span data-stu-id="09f08-110">The application does not use **SQLBindCol** to bind result set columns to program variables.</span></span> <span data-ttu-id="09f08-111">Después de cada llamada a **SQLFetch**, la aplicación llama a **SQLGetData** una vez para cada columna del conjunto de resultados.</span><span class="sxs-lookup"><span data-stu-id="09f08-111">After each call to **SQLFetch**, the application calls **SQLGetData** once for each column in the result set.</span></span> <span data-ttu-id="09f08-112">**SQLGetData** indica al controlador que transfiera los datos de una columna de conjunto de resultados específica a una variable de programa concreta y especifica los tipos de datos de la columna y la variable.</span><span class="sxs-lookup"><span data-stu-id="09f08-112">**SQLGetData** instructs the driver to transfer data from a specific result set column to a specific program variable and specifies the data types of the column and variable.</span></span> <span data-ttu-id="09f08-113">Esto permite al controlador convertir los datos si la columna de resultado y la variable de programa tienen tipos de datos distintos.</span><span class="sxs-lookup"><span data-stu-id="09f08-113">This allows the driver to convert data if the result column and program variable have different data types.</span></span> <span data-ttu-id="09f08-114">Las columnas **Text**, **ntext**e **Image** suelen ser demasiado grandes para caber en una variable de programa, pero todavía se pueden recuperar mediante **SQLGetData**.</span><span class="sxs-lookup"><span data-stu-id="09f08-114">**Text**, **ntext**, and **image** columns are typically too large to fit into a program variable but can still be retrieved using **SQLGetData**.</span></span> <span data-ttu-id="09f08-115">Si los datos de tipo **Text**, **ntext**o **Image** de la columna de resultados son mayores que la variable de programa, **SQLGetData** devuelve SQL_SUCCESS_WITH_INFO y SQLSTATE 01004 (datos de cadena, truncados a la derecha).</span><span class="sxs-lookup"><span data-stu-id="09f08-115">If the **text**, **ntext**, or **image** data in the result column is larger than the program variable, **SQLGetData** returns SQL_SUCCESS_WITH_INFO and SQLSTATE 01004 (string data, right truncated).</span></span> <span data-ttu-id="09f08-116">Las llamadas sucesivas a **SQLGetData** devuelven fragmentos sucesivos de los datos de **texto** o **imagen** .</span><span class="sxs-lookup"><span data-stu-id="09f08-116">Successive calls to **SQLGetData** return successive chunks of the **text** or **image** data.</span></span> <span data-ttu-id="09f08-117">Cuando se alcanza el final de los datos, **SQLGetData** devuelve SQL_SUCCESS.</span><span class="sxs-lookup"><span data-stu-id="09f08-117">When the end of the data is reached, **SQLGetData** returns SQL_SUCCESS.</span></span> <span data-ttu-id="09f08-118">Cada captura devuelve un conjunto de filas, si SQL_ATTR_ROW_ARRAY_SIZE es mayor que 1.</span><span class="sxs-lookup"><span data-stu-id="09f08-118">Each fetch returns a set of rows, or rowset, if SQL_ATTR_ROW_ARRAY_SIZE is greater than 1.</span></span> <span data-ttu-id="09f08-119">Antes de usar **SQLGetData**, primero debe usar **SQLSetPos** para especificar una fila concreta dentro del conjunto de filas como la fila actual.</span><span class="sxs-lookup"><span data-stu-id="09f08-119">Before using **SQLGetData**, you must first use **SQLSetPos** to specify a specific row within the rowset as the current row.</span></span>  
  
 <span data-ttu-id="09f08-120">La tercera opción es usar una combinación de **SQLBindCol** y **SQLGetData**.</span><span class="sxs-lookup"><span data-stu-id="09f08-120">The third option is to use a mix of **SQLBindCol** and **SQLGetData**.</span></span> <span data-ttu-id="09f08-121">Una aplicación podría, por ejemplo, enlazar las diez primeras columnas de un conjunto de resultados y, a continuación, en cada captura, llamar a **SQLGetData** tres veces para recuperar los datos de tres columnas sin enlazar.</span><span class="sxs-lookup"><span data-stu-id="09f08-121">An application could, for example, bind the first ten columns of a result set and then, on each fetch, call **SQLGetData** three times to retrieve the data from three unbound columns.</span></span> <span data-ttu-id="09f08-122">Normalmente se utilizaría cuando un conjunto de resultados contiene una o más columnas **Text** o **Image** .</span><span class="sxs-lookup"><span data-stu-id="09f08-122">This would typically be used when a result set contains one or more **text** or **image** columns.</span></span>  
  
 <span data-ttu-id="09f08-123">Dependiendo de las opciones de cursor establecidas para el conjunto de resultados, una aplicación también puede usar las opciones de desplazamiento de **SQLFetchScroll** para desplazarse por el conjunto de resultados.</span><span class="sxs-lookup"><span data-stu-id="09f08-123">Depending on the cursor options set for the result set, an application can also use the scrolling options of **SQLFetchScroll** to scroll around the result set.</span></span>  
  
 <span data-ttu-id="09f08-124">El uso excesivo de **SQLBindCol** para enlazar una columna de conjunto de resultados a una variable de programa es costoso porque **SQLBindCol** hace que un controlador ODBC asigne memoria.</span><span class="sxs-lookup"><span data-stu-id="09f08-124">Excess use of **SQLBindCol** to bind a result set column to a program variable is expensive because **SQLBindCol** causes an ODBC driver to allocate memory.</span></span> <span data-ttu-id="09f08-125">Al enlazar una columna de resultados a una variable, ese enlace permanece en vigor hasta que se llama a [SQLFreeHandle](../native-client-odbc-api/sqlfreehandle.md) para liberar el identificador de instrucción o llamar a [SQLFreeStmt](../native-client-odbc-api/sqlfreestmt.md) con *fOption* establecido en SQL_UNBIND.</span><span class="sxs-lookup"><span data-stu-id="09f08-125">When you bind a result column to a variable, that binding remains in effect until you either call [SQLFreeHandle](../native-client-odbc-api/sqlfreehandle.md) to free the statement handle or call [SQLFreeStmt](../native-client-odbc-api/sqlfreestmt.md) with *fOption* set to SQL_UNBIND.</span></span> <span data-ttu-id="09f08-126">Los enlaces no se deshacen automáticamente cuando se completa la instrucción.</span><span class="sxs-lookup"><span data-stu-id="09f08-126">The bindings are not automatically undone when the statement completes.</span></span>  
  
 <span data-ttu-id="09f08-127">Esta lógica le permite solucionar eficazmente la ejecución de la misma instrucción SELECT varias veces con parámetros diferentes.</span><span class="sxs-lookup"><span data-stu-id="09f08-127">This logic allows you to effectively deal with executing the same SELECT statement several times with different parameters.</span></span> <span data-ttu-id="09f08-128">Dado que el conjunto de resultados mantiene la misma estructura, puede enlazar el conjunto de resultados una vez, procesar todas las instrucciones SELECT y, a continuación, llamar a **SQLFreeStmt** con *fOption* establecido en SQL_UNBIND después de la última ejecución.</span><span class="sxs-lookup"><span data-stu-id="09f08-128">Because the result set keeps the same structure, you can bind the result set once, process all the SELECT statements, then call **SQLFreeStmt** with *fOption* set to SQL_UNBIND after the last execution.</span></span> <span data-ttu-id="09f08-129">No debe llamar a **SQLBindCol** para enlazar las columnas de un conjunto de resultados sin llamar primero a **SQLFreeStmt** con *fOption* establecido en SQL_UNBIND para liberar cualquier enlace anterior.</span><span class="sxs-lookup"><span data-stu-id="09f08-129">You should not call **SQLBindCol** to bind the columns in a result set without first calling **SQLFreeStmt** with *fOption* set to SQL_UNBIND to free any previous bindings.</span></span>  
  
 <span data-ttu-id="09f08-130">Al usar **SQLBindCol**, puede realizar un enlace de modo de fila o de modo de columna.</span><span class="sxs-lookup"><span data-stu-id="09f08-130">When using **SQLBindCol**, you can either do row-wise or column-wise binding.</span></span> <span data-ttu-id="09f08-131">El enlace de modo de fila es algo más rápido que el enlace de modo de columna.</span><span class="sxs-lookup"><span data-stu-id="09f08-131">Row-wise binding is somewhat faster than column-wise binding.</span></span>  
  
 <span data-ttu-id="09f08-132">Puede usar **SQLGetData** para recuperar datos columna por columna en lugar de enlazar columnas del conjunto de resultados mediante **SQLBindCol**.</span><span class="sxs-lookup"><span data-stu-id="09f08-132">You can use **SQLGetData** to retrieve data on a column-by-column basis instead of binding result set columns using **SQLBindCol**.</span></span> <span data-ttu-id="09f08-133">Si un conjunto de resultados contiene solo unas pocas filas, el uso de **SQLGetData** en lugar de **SQLBindCol** es más rápido; de lo contrario, **SQLBindCol** proporciona el mejor rendimiento.</span><span class="sxs-lookup"><span data-stu-id="09f08-133">If a result set contains only a few rows, using **SQLGetData** instead of **SQLBindCol** is faster; otherwise, **SQLBindCol** gives the best performance.</span></span> <span data-ttu-id="09f08-134">Si no coloca siempre los datos en el mismo conjunto de variables, debe utilizar **SQLGetData** en lugar de volver a enlazar constantemente.</span><span class="sxs-lookup"><span data-stu-id="09f08-134">If you do not always put the data in the same set of variables, you should use **SQLGetData** instead of constantly rebinding.</span></span> <span data-ttu-id="09f08-135">Solo puede utilizar **SQLGetData** en las columnas que se encuentran en la lista de selección después de que todas las columnas se enlacen con **SQLBindCol**.</span><span class="sxs-lookup"><span data-stu-id="09f08-135">You can only use **SQLGetData** on columns that are in the select list after all columns are bound with **SQLBindCol**.</span></span> <span data-ttu-id="09f08-136">La columna también debe aparecer después de cualquier columna en la que ya haya utilizado **SQLGetData**.</span><span class="sxs-lookup"><span data-stu-id="09f08-136">The column must also appear after any columns on which you have already used **SQLGetData**.</span></span>  
  
 <span data-ttu-id="09f08-137">Las funciones ODBC que se ocupan de mover datos hacia o desde variables de programa, como **SQLGetData**, **SQLBindCol**y [SQLBindParameter](../native-client-odbc-api/sqlbindparameter.md), admiten la conversión implícita de tipos de datos.</span><span class="sxs-lookup"><span data-stu-id="09f08-137">The ODBC functions that deal with moving data into or out of program variables, such as **SQLGetData**, **SQLBindCol**, and [SQLBindParameter](../native-client-odbc-api/sqlbindparameter.md), support implicit data type conversion.</span></span> <span data-ttu-id="09f08-138">Por ejemplo, si una aplicación enlaza una columna entera a una variable de programa de cadena de caracteres, el controlador convierte automáticamente los datos enteros en caracteres antes de incluirlos en la variable de programa.</span><span class="sxs-lookup"><span data-stu-id="09f08-138">For example, if an application binds an integer column to a character string program variable, the driver automatically converts the data from integer to character before placing it into the program variable.</span></span>  
  
 <span data-ttu-id="09f08-139">Se debe minimizar la conversión de los datos en las aplicaciones.</span><span class="sxs-lookup"><span data-stu-id="09f08-139">Data conversion in applications should be minimized.</span></span> <span data-ttu-id="09f08-140">A menos que se requiera la conversión de datos para el procesamiento realizado por la aplicación, las aplicaciones deben enlazar las columnas y los parámetros a las variables de programa del mismo tipo de datos.</span><span class="sxs-lookup"><span data-stu-id="09f08-140">Unless data conversion is required for the processing done by the application, applications should bind columns and parameters to program variables of the same data type.</span></span> <span data-ttu-id="09f08-141">Si los datos se deben convertir de un tipo a otro, sin embargo, es más eficaz hacer que el controlador haga la conversión que hacerla en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="09f08-141">If the data must be converted from one type to another, however, it is more efficient to have the driver do the conversion than doing it in the application.</span></span> <span data-ttu-id="09f08-142">El controlador ODBC de [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Native Client normalmente solo transfiere directamente los datos desde los búferes de la red a las variables de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="09f08-142">The [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Native Client ODBC driver normally just transfers data directly from the network buffers to the variables of the application.</span></span> <span data-ttu-id="09f08-143">La solicitud al controlador de realizar la conversión de datos fuerza al controlador a almacenar en búfer los datos y usar los ciclos de CPU para convertir los datos.</span><span class="sxs-lookup"><span data-stu-id="09f08-143">Requesting the driver to do data conversion forces the driver to buffer the data and use CPU cycles to convert the data.</span></span>  
  
 <span data-ttu-id="09f08-144">Las variables de programa deben ser lo suficientemente grandes como para contener los datos transferidos desde una columna, salvo los datos **Text**, **ntext**e **Image** .</span><span class="sxs-lookup"><span data-stu-id="09f08-144">Program variables should be large enough to hold data transferred in from a column, except for **text**, **ntext**, and **image** data.</span></span> <span data-ttu-id="09f08-145">Si una aplicación intenta recuperar datos del conjunto de resultados y colocarlos en una variable que es demasiado pequeña para contenerlos, el controlador genera una advertencia.</span><span class="sxs-lookup"><span data-stu-id="09f08-145">If an application attempts to retrieve result set data and place it into a variable that is too small to hold it, the driver generates a warning.</span></span> <span data-ttu-id="09f08-146">Esto obliga al controlador a asignar memoria para el mensaje y los dos, el controlador y la aplicación, tienen que utilizar ciclos de CPU para procesar el mensaje y realizar el tratamiento de errores.</span><span class="sxs-lookup"><span data-stu-id="09f08-146">This forces the driver to allocate memory for the message, and the driver and application both have to spend CPU cycles processing the message and doing error handling.</span></span> <span data-ttu-id="09f08-147">La aplicación debe asignar una variable bastante grande para contener los datos que se van a recuperar o usar la función SUBSTRING de la lista de selección para reducir el tamaño de la columna del conjunto de resultados.</span><span class="sxs-lookup"><span data-stu-id="09f08-147">The application should either allocate a variable large enough to hold the data being retrieved or use the SUBSTRING function in the select list to reduce the size of the column in the result set.</span></span>  
  
 <span data-ttu-id="09f08-148">Se deben extremar las precauciones al utilizar SQL_C_DEFAULT para especificar el tipo de la variable C.</span><span class="sxs-lookup"><span data-stu-id="09f08-148">Care must be taken when using SQL_C_DEFAULT to specify the type of the C variable.</span></span> <span data-ttu-id="09f08-149">SQL_C_DEFAULT especifica que el tipo de la variable C coincide con el tipo de datos SQL de la columna o parámetro.</span><span class="sxs-lookup"><span data-stu-id="09f08-149">SQL_C_DEFAULT specifies that the type of the C variable matches the SQL data type of the column or parameter.</span></span> <span data-ttu-id="09f08-150">Si se especifica SQL_C_DEFAULT para una columna **ntext**, **nchar**o **nvarchar** , los datos Unicode se devuelven a la aplicación.</span><span class="sxs-lookup"><span data-stu-id="09f08-150">If SQL_C_DEFAULT is specified for an **ntext**, **nchar**, or **nvarchar** column, Unicode data is returned to the application.</span></span> <span data-ttu-id="09f08-151">Esto puede producir varios problemas si la aplicación no ha estado codificada para administrar los datos Unicode.</span><span class="sxs-lookup"><span data-stu-id="09f08-151">This can cause various problems if the application has not been coded to handle Unicode data.</span></span> <span data-ttu-id="09f08-152">Se pueden producir los mismos tipos de problemas con el tipo de datos **uniqueidentifier** (SQL_GUID).</span><span class="sxs-lookup"><span data-stu-id="09f08-152">The same types of problems can occur with the **uniqueidentifier** (SQL_GUID) data type.</span></span>  
  
 <span data-ttu-id="09f08-153">los datos **Text**, **ntext**e **Image** suelen ser demasiado grandes para caber en una sola variable de programa y normalmente se procesan con **SQLGetData** en lugar de **SQLBindCol**.</span><span class="sxs-lookup"><span data-stu-id="09f08-153">**text**, **ntext**, and **image** data is typically too large to fit into a single program variable, and is usually processed with **SQLGetData** instead of **SQLBindCol**.</span></span> <span data-ttu-id="09f08-154">Cuando se utilizan cursores de servidor, el [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] controlador ODBC de Native Client está optimizado para no transmitir los datos de las columnas **Text**, **ntext**o **Image** sin enlazar en el momento en que se captura la fila.</span><span class="sxs-lookup"><span data-stu-id="09f08-154">When using server cursors, the [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Native Client ODBC driver is optimized to not transmit the data for unbound **text**, **ntext**, or **image** columns at the time the row is fetched.</span></span> <span data-ttu-id="09f08-155">Los datos **Text**, **ntext**o **Image** no se recuperan realmente del servidor hasta que la aplicación emite **SQLGetData** para la columna.</span><span class="sxs-lookup"><span data-stu-id="09f08-155">The **text**, **ntext**, or **image** data is not actually retrieved from the server until the application issues **SQLGetData** for the column.</span></span>  
  
 <span data-ttu-id="09f08-156">Esta optimización se puede aplicar a las aplicaciones para que no se muestre ningún dato **Text**, **ntext**o **Image** mientras un usuario se desplaza hacia arriba y hacia abajo un cursor.</span><span class="sxs-lookup"><span data-stu-id="09f08-156">This optimization can be applied to applications so that no **text**, **ntext**, or **image** data is displayed while a user is scrolling up and down a cursor.</span></span> <span data-ttu-id="09f08-157">Una vez que el usuario selecciona una fila, la aplicación puede llamar a **SQLGetData** para recuperar los datos **Text**, **ntext**o **Image** .</span><span class="sxs-lookup"><span data-stu-id="09f08-157">After the user selects a row, the application can call **SQLGetData** to retrieve the **text**, **ntext**, or **image** data.</span></span> <span data-ttu-id="09f08-158">Esto guarda la transmisión de los datos **Text**, **ntext**o **Image** para cualquiera de las filas que el usuario no selecciona y puede ahorrar la transmisión de cantidades muy grandes de datos.</span><span class="sxs-lookup"><span data-stu-id="09f08-158">This saves transmitting the **text**, **ntext**, or **image** data for any of the rows the user does not select and can save the transmission of very large amounts of data.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="09f08-159">Consulte también</span><span class="sxs-lookup"><span data-stu-id="09f08-159">See Also</span></span>  
 [<span data-ttu-id="09f08-160">Procesar los resultados &#40;ODBC&#41;</span><span class="sxs-lookup"><span data-stu-id="09f08-160">Processing Results &#40;ODBC&#41;</span></span>](processing-results-odbc.md)  
  
  
