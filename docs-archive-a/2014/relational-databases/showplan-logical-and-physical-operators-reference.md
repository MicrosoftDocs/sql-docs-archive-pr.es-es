---
title: Referencia de operadores lógicos y físicos del plan de presentación | Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: ''
ms.topic: conceptual
f1_keywords:
- sql12.swb.showplan.nestedloops.f1
- sql12.swb.showplan.dynamic.f1
- sql12.swb.showplan.tableinsert.f1
- sql12.swb.showplan.remoteinsert.f1
- sql12.swb.showplan.lazyspool.f1
- sql12.swb.showplan.RIDLookup
- sql12.swb.showplan.hashmatchteam.f1
- sql12.swb.showplan.tablespool.f1
- sql12.swb.showplan.print.f1
- sql12.swb.showplan.clusteredindexupdate.f1
- sql12.swb.showplan.assert.f1
- sql12.swb.showplan.columnstoreindexscan.f1
- sql12.swb.showplan.tablevaluedfunction.f1
- sql12.swb.showplan.split.f1
- sql12.swb.showplan.union.f1
- sql12.swb.showplan.clusteredindexseek.f1
- sql12.swb.showplan.indexspool.f1
- sql12.swb.showplan.indexinsert.f1
- sql12.swb.showplan.clusteredindexscan.f1
- sql12.swb.showplan.buildhash.f1
- sql12.swb.showplan.clusteredindexmerge.f1
- sql12.swb.showplan.sequence.f1
- sql12.swb.showplan.hashmatchroot.f1
- sql12.swb.showplan.columnstoreindexupdate.f1
- sql12.swb.showplan.rightsemijoin.f1
- sql12.swb.showplan.fetchquery.f1
- sql12.swb.showplan.distinct.f1
- sql12.swb.showplan.hashmatch.f1
- sql12.swb.showplan.segment.f1
- sql12.swb.showplan.top.f1
- sql12.swb.showplan.columnstoreindexdelete.f1
- sql12.swb.showplan.gatherstreams.f1
- sql12.swb.showplan.remotedelete.f1
- sql12.swb.showplan.insert.f1
- sql12.swb.showplan.declare.f1
- sql12.swb.showplan.snapshot.f1
- sql12.swb.showplan.assign.f1
- sql12.swb.showplan.intrinsic.f1
- sql12.swb.showplan.mergejoin.f1
- sql12.swb.showplan.concatenation.f1
- sql12.swb.showplan.rowcountspool.f1
- sql12.swb.showplan.parametertablescan.f1
- sql12.swb.showplan.indexscan.f1
- sql12.swb.showplan.while.f1
- sql12.swb.showplan.columnstoreindexinsert.f1
- sql12.swb.showplan.tablemerge.f1
- sql12.swb.showplan.spool.f1
- sql12.swb.showplan.streamaggregate.f1
- sql12.swb.showplan.update.f1
- sql12.swb.showplan.innerjoin.f1
- sql12.swb.showplan.flowdistinct.f1
- sql12.swb.showplan.tableupdate.f1
- sql12.swb.showplan.result.f1
- sql12.swb.showplan.bitmap.f1
- sql12.swb.showplan.remoteindexseek.f1
- sql12.swb.showplan.populationquery.f1
- sql12.swb.showplan.rightouterjoin.f1
- sql12.swb.showplan.columnstoreindexmerge.f1
- sql12.swb.showplan.remotescan.f1
- sql12.swb.showplan.remoteupdate.f1
- sql12.swb.showplan.keyset.f1
- sql12.swb.showplan.collapse.f1
- sql12.swb.showplan.arithmeticexpression.f1
- sql12.swb.showplan.clusteredindexinsert.f1
- sql12.swb.showplan.computescalar
- sql12.swb.showplan.sort.f1
- sql12.swb.showplan.locate.f1
- sql12.swb.showplan.constantscan.f1
- sql12.swb.showplan.computescalar.f1
- sql12.swb.showplan.indexseek.f1
- sql12.swb.showplan.leftsemijoin.f1
- sql12.swb.showplan.leftantisemijoin.f1
- sql12.swb.showplan.fullouterjoin.f1
- sql12.swb.showplan.filter.f1
- sql12.swb.showplan.indexdelete.f1
- sql12.swb.showplan.repartitionstreams.f1
- sql12.swb.showplan.crossjoin.f1
- sql12.swb.showplan.mergeinterval.f1
- sql12.swb.showplan.bookmarklookup.f1
- sql12.swb.showplan.convert.f1
- sql12.swb.showplan.refreshquery.f1
- sql12.swb.showplan.distinctsort.f1
- sql12.swb.showplan.leftouterjoin.f1
- sql12.swb.showplan.rightantisemijoin.f1
- sql12.swb.showplan.deletedscan.f1
- sql12.swb.showplan.udx.f1
- sql12.swb.showplan.broadcast.f1
- sql12.swb.showplan.delete.f1
- sql12.swb.showplan.aggregate.f1
- sql12.swb.showplan.setfunction.f1
- sql12.swb.showplan.switch.f1
- sql12.swb.showplan.remoteindexscan.f1
- sql12.swb.showplan.eagerspool.f1
- sql12.swb.showplan.indexupdate.f1
- sql12.swb.showplan.keylookup.f1
- sql12.swb.showplan.branchrepartition.f1
- sql12.swb.showplan.rank.f1
- sql12.swb.showplan.tablescan.f1
- sql12.swb.showplan.distributestreams.f1
- sql12.swb.showplan.logrowscan.f1
- sql12.swb.showplan.parallelism.f1
- sql12.swb.showplan.bitmapcreate.f1
- sql12.swb.showplan.insertedscan.f1
- sql12.swb.showplan.tabledelete.f1
- sql12.swb.showplan.clusteredindexdelete.f1
- sql12.swb.showplan.remotequery.f1
- sql12.swb.showplan.if.f1
- sql12.swb.showplan.cache.f1
- sql12.swb.showplan.partialaggregate.f1
- sql12.swb.showplan.sql.f1
helpviewer_keywords:
- execution plans [SQL Server], operators
- ActualRows attribute
- reading execution plan output
- ActualRewinds attribute
- ActualEndOfScans attribute
- query tuning [SQL Server]
- mapping operators [SQL Server]
- operators [Database Engine query tuning]
- logical operators [SQL Server], execution plans
- logical operators [SQL Server], listed
- physical operators [SQL Server]
- ActualRebinds attribute
- execution plans [SQL Server], reading output
ms.assetid: e43fd0fe-5ea7-4ffe-8d52-759ef6a7c361
author: rothja
ms.author: jroth
ms.openlocfilehash: bc45a5fa14785294093385e6f90b47a8bdb6dff3
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 08/04/2020
ms.locfileid: "87746842"
---
# <a name="showplan-logical-and-physical-operators-reference"></a>Referencia de operadores lógicos y físicos del plan de presentación
  Los operadores describen cómo [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] ejecuta una consulta o una instrucción DML (Lenguaje de manipulación de datos). El optimizador de consultas usa operadores para generar un plan de consulta con el fin de crear el resultado especificado en la consulta o para realizar la operación especificada en la instrucción DML. El plan de consulta es un árbol que consta de operadores físicos. Puede ver el plan de consulta mediante las instrucciones SET SHOWPLAN, las opciones gráficas del plan de ejecución de [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)]o las clases de eventos Showplan de SQL Server Profiler.  
  
 Los operadores se clasifican como lógicos y físicos.  
  
 **Operadores lógicos**  
 Los operadores lógicos describen la operación algebraica relacional usada para procesar una instrucción. En otras palabras, los operadores lógicos describen conceptualmente la operación que se debe realizar.  
  
 **Operadores físicos**  
 Los operadores físicos implementan la operación descrita por los operadores lógicos. Cada operador físico es un objeto o rutina que realiza una operación. Por ejemplo, algunos operadores físicos obtienen acceso a columnas o filas desde una tabla, índice o vista. Otros operadores físicos realizan otras operaciones como cálculos, agregaciones, comprobaciones de integridad de datos o combinaciones. Los operadores físicos tienen costos asociados.  
  
 Los operadores físicos se inicializan, recopilan datos y se cierran. Específicamente, el operador físico puede responder a las llamadas de los tres métodos siguientes:  
  
-   **Init()** : el método **Init()** hace que un operador físico se inicialice y configure las estructuras de datos necesarias. El operador físico puede recibir numerosas llamadas **Init()** , aunque suele recibir solo una.  
  
-   **GetNext()** : el método **GetNext()** hace que un operador físico obtenga la primera fila de datos o la siguiente. El operador físico puede recibir ninguna o numerosas llamadas **GetNext()** .  
  
-   **Close()** : el método **Close()** hace que un operador físico realice algunas operaciones de limpieza y se cierre. Un operador físico recibe únicamente una llamada de **Close()** .  
  
 El método **GetNext()** devuelve una fila de datos, mientras que el número de veces que se llama aparece como **ActualRows** en los resultados del plan de presentación generado mediante SET STATISTICS PROFILE ON o SET STATISTICS XML ON. Para obtener más información sobre estas opciones de SET, vea [SET STATISTICS PROFILE &#40;Transact-SQL&#41;](/sql/t-sql/statements/set-statistics-profile-transact-sql) y [SET STATISTICS XML &#40;Transact-SQL&#41;](/sql/t-sql/statements/set-statistics-xml-transact-sql).  
  
 Los recuentos **ActualRebinds** y **ActualRewinds** que aparecen en los resultados del plan de presentación hacen referencia al número de veces que se llama al método **Init()** . A menos que haya un operador en la parte interna de una combinación de bucles, **ActualRebinds** es igual a uno y **ActualRewinds** es igual a cero. Si hay un operador en la parte interna de una combinación de bucles, la suma del número de reenlaces y rebobinados es igual al número de filas procesadas en la parte externa de la combinación. Un reenlace significa que uno o más de los parámetros correlativos de la combinación han cambiado y es necesario volver a evaluar la parte interna. Un rebobinado significa que ninguno de los parámetros correlativos ha cambiado y aún se puede volver a utilizar el conjunto de resultados interno anterior.  
  
 **ActualRebinds** y **ActualRewinds** aparecen en los resultados del plan de presentación XML generado mediante SET STATISTICS XML ON. Solo se rellenan para los operadores **Nonclustered Index spool**, `Remote Query` , **Row Count spool**, `Sort` , **TABLE spool**y **función con valores de tabla** . **ActualRebinds** y **ActualRewinds** también se pueden rellenar para los `Assert` operadores de **filtro** y cuando el atributo **StartupExpression** está establecido en true.  
  
 Cuando **ActualRebinds** y **ActualRewinds** aparecen en un plan de presentación XML, son comparables a **EstimateRebinds** y **EstimateRewinds**. Si no aparecen, el número estimado de filas (**EstimateRows**) es comparable al número real de filas (**ActualRows**). Tenga en cuenta que si no aparecen, los resultados reales del plan de presentación gráfico muestran ceros para los reenlaces y rebobinados reales.  
  
 Hay un contador relacionado disponible, **ActualEndOfScans**, únicamente cuando se generan los resultados del plan de presentación mediante SET STATISTICS XML ON. Siempre que un operador físico alcanza el final de su flujo de datos, este contador se incrementa en uno. Un operador físico puede alcanzar el final de su flujo de datos cero, una o varias veces. Al igual que los reenlaces y rebobinados, el número de finales de recorrido puede ser superior a uno únicamente si el operador se encuentra en la parte interna de una combinación de bucles. El número de finales de recorrido debería ser inferior o igual a la suma del número de reenlaces y rebobinados.  
  
## <a name="mapping-physical-and-logical-operators"></a>Asignar operadores físicos y lógicos  
 El optimizador de consultas crea un plan de consulta con forma de árbol que consta de operadores lógicos. Una vez que el optimizador de consultas ha creado el plan, elige el operador físico más eficaz para cada operador lógico. El optimizador de consultas utiliza un método basado en el costo para determinar el operador físico que implementará un operador lógico.  
  
 Normalmente, varios operadores físicos pueden implementar una operación lógica. Sin embargo, en pocas ocasiones un operador físico puede implementar varias operaciones lógicas también.  
  
## <a name="operator-descriptions"></a>Descripción del operador  
 Esta sección contiene las descripciones de los operadores lógicos y físicos.  
  
|Icono del plan de ejecución gráfico|Operador de plan de presentación|Descripción|  
|-----------------------------------|-----------------------|-----------------|  
|None|`Aggregate`|El operador `Aggregate` calcula una expresión que contiene MIN, MAX, SUM, COUNT o AVG. El operador `Aggregate` puede ser un operador lógico o físico.|  
|![Icono del operador de expresión aritmética](../../2014/database-engine/media/arithmetic-expression-32x-2.gif "Icono del operador de expresión aritmética")|`Arithmetic Expression`|El operador `Arithmetic Expression` calcula un nuevo valor a partir de los valores de una fila. `Arithmetic Expression` no se usa en [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].|  
|![Icono del operador Assert](../../2014/database-engine/media/assert-32x.gif "Icono del operador Assert")|`Assert`|El operador `Assert` comprueba una condición. Por ejemplo, valida la integridad referencial o se asegura de que una subconsulta escalar devuelve una fila. Para cada fila de entrada, el `Assert` operador evalúa la expresión en la `Argument` columna del plan de ejecución. Si la expresión da como resultado NULL, la fila se pasa a través del operador `Assert` y continúa la ejecución de la consulta. Si la expresión da como resultado un valor distinto a NULL, se generará el error apropiado. El `Assert` operador es un operador físico.|  
|![Icono del elemento del lenguaje Assign](../../2014/database-engine/media/assign-32.gif "Icono del elemento del lenguaje Assign")|`Assign`|El operador `Assign` asigna el valor de una expresión o una constante a una variable. `Assign` es un elemento del lenguaje.|  
|None|`Asnyc Concat`|El operador `Asnyc Concat` solo se usa en consultas remotas (consultas distribuidas). Tiene *n* nodos secundarios y un nodo primario. Algunos de los nodos secundarios suelen ser equipos remotos que participan en una consulta distribuida. `Asnyc Concat` emite llamadas `open()` a todos los nodos secundarios a la vez y, a continuación, asigna un mapa de bits a cada uno de estos nodos. Por cada bit que sea un 1, `Async Concat` envía las filas de salida a petición al nodo primario.|  
|![Icono del operador Bitmap](../../2014/database-engine/media/bitmap-32x.gif "Icono del operador Bitmap")|`Bitmap`|[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]utiliza el `Bitmap` operador para implementar el filtrado de mapas de bits en planes de consulta paralelos. El filtrado de mapas de bits agiliza la ejecución de la consulta al eliminar las filas con valores de clave que no pueden generar ningún registro de combinación antes de pasar las filas a través de otro operador, como el `Parallelism` operador. Un filtro de mapas de bits usa una representación compacta de un conjunto de valores de una tabla en una parte del árbol de operadores para filtrar filas de una segunda tabla en otra parte del árbol. Si se quitan las filas innecesarias de la consulta en una fase temprana, los operadores subsiguientes tienen menos filas con las que trabajar y el rendimiento global de la consulta mejora. El optimizador determina cuando un mapa de bits es suficientemente selectivo para resultar útil y en qué operadores se aplica el filtro. `Bitmap` es un operador físico.|  
|![Icono del operador Bitmap](../../2014/database-engine/media/bitmap-32x.gif "Icono del operador Bitmap")|`Bitmap Create`|El operador `Bitmap Create` aparece en el resultado del plan de presentación en la que se generan los mapas de bits. `Bitmap Create` es un operador lógico.|  
|![Icono del operador Bookmark Lookup](../../2014/database-engine/media/bookmark-lookup-32x.gif "Icono del operador Bookmark Lookup")|`Bookmark Lookup`|El operador `Bookmark Lookup` usa un marcador (identificador de fila o clave de agrupación en clústeres) para buscar la fila correspondiente en la tabla o índice clúster. La `Argument` columna contiene la etiqueta de marcador utilizada para buscar la fila en la tabla o el índice clúster. La `Argument` columna también contiene el nombre de la tabla o el índice clúster en el que se busca la fila. Si la cláusula WITH Prefetch aparece en la `Argument` columna, el procesador de consultas ha determinado que es óptimo usar la captura previa asincrónica (lectura anticipada) al buscar marcadores en la tabla o el índice clúster.<br /><br /> `Bookmark Lookup` no se usa en [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)]. En su lugar, `Clustered Index Seek` y `RID Lookup` proporcionan la funcionalidad de búsqueda de marcadores. El operador `Key Lookup` también proporciona esta funcionalidad.|  
|None|`Branch Repartition`|En un plan de consulta paralelo, a veces hay regiones conceptuales de iteradores. Todos los iteradores de una región así se pueden ejecutar mediante subprocesos paralelos. Las regiones en sí deben ejecutarse en serie. Algunos de los iteradores `Parallelism` de una región individual se denominan `Branch Repartition`. El iterador `Parallelism` situado en el límite de dos de estas regiones se denomina `Segment Repartition`. `Branch Repartition` y `Segment Repartition` son operadores lógicos.|  
|None|`Broadcast`|`Broadcast`tiene un nodo secundario y *n* nodos primarios. `Broadcast` envía las filas de entrada a varios consumidores a petición. Cada consumidor recibe todas las filas. Por ejemplo, si todos los consumidores son lados de creación de una combinación hash, se crearán *n* copias de las tablas hash.|  
|![Icono del operador Build Hash](../../2014/database-engine/media/build-hash.gif "Icono del operador Build Hash")|`Build Hash`|Indica la compilación de una tabla hash del lote para un índice optimizado memoria de columnstore de xVelocity.|  
|None|`Cache`|`Cache`es una versión especializada del operador **spool** . Almacena solo una fila de datos. `Cache` es un operador lógico. `Cache` no se usa en [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].|  
|![Icono del operador Clustered Index Delete](../../2014/database-engine/media/clustered-index-delete-32x.gif "Icono del operador Clustered Index Delete")|`Clustered Index Delete`|El operador `Clustered Index Delete` elimina filas del índice clúster especificado en la columna Argument del plan de ejecución de consulta. Si hay un predicado WHERE:() en la columna Argument, solo se eliminan las filas que cumplen el predicado.`Clustered Index Delete`  es un operador físico.|  
|![Icono del operador Clustered Index Insert](../../2014/database-engine/media/clustered-index-insert-32x.gif "Icono del operador Clustered Index Insert")|`Clustered Index Insert`|El operador de Showplan `Clustered Index Insert` inserta filas desde su entrada en el índice clúster especificado en la columna Argument. La columna Argument también contiene un predicado SET:(), que indica el valor en el que se establece cada columna. Si `Clustered Index Insert` no tiene elementos secundarios para los valores de inserción, la fila insertada se toma del `Insert` propio operador.`Clustered Index Insert`  es un operador físico.|  
|![Operador Clustered Index Merge](../../2014/database-engine/media/clustered-index-merge-32x.gif "Operador Clustered Index Merge")|**Clustered Index Merge**|El operador **Clustered Index Merge** aplica un flujo de datos de mezcla a un índice clúster. El operador elimina, actualiza o inserta filas del índice clúster especificado en la `Argument` columna del operador. La operación real realizada depende del valor en tiempo de ejecución de la columna **Action** especificada en la `Argument` columna del operador. **Clustered Index Merge** es un operador físico.|  
|![Icono del operador Clustered Index Scan](../../2014/database-engine/media/clustered-index-scan-32x.gif "Icono del operador Clustered Index Scan")|`Clustered Index Scan`|El operador `Clustered Index Scan` examina el índice clúster especificado en la columna Argument del plan de ejecución de consulta. Si hay un predicado WHERE:() opcional, solo se devuelven las filas que lo cumplen. Si la columna Argument contiene la cláusula ORDERED, el procesador de consultas ha solicitado que la salida de las filas se devuelva en el orden en que las haya ordenado el índice clúster. Si no hay una cláusula ORDERED, el motor de almacenamiento recorre el índice de la forma óptima (sin tener que ordenar el resultado). `Clustered Index Scan` es un operador lógico y físico.|  
|![Icono del operador Clustered Index Seek](../../2014/database-engine/media/clustered-index-seek-32x.gif "Icono del operador Clustered Index Seek")|`Clustered Index Seek`|El operador `Clustered Index Seek` utiliza la capacidad de búsqueda de los índices para recuperar filas de un índice clúster. La `Argument` columna contiene el nombre del índice clúster que se está usando y el predicado Seek:(). El motor de almacenamiento utiliza el índice para procesar solamente las filas que cumplen el predicado SEEK:(). También puede incluir un predicado WHERE:() en el que el motor de almacenamiento determine todas las filas que cumplan el predicado SEEK:(), aunque este predicado es opcional y no utiliza índices para completar el proceso.<br /><br /> Si la `Argument` columna contiene la cláusula ordered, el procesador de consultas ha determinado que las filas deben devolverse en el orden en el que el índice clúster las haya clasificado. Si no hay una cláusula ORDERED, el motor de almacenamiento busca el índice de la forma óptima (sin tener que ordenar el resultado). Permitir que el resultado conserve su ordenación puede ser menos eficiente que generar un resultado no ordenado. Si aparece la palabra clave LOOKUP, significa que se está realizando una búsqueda de marcadores. En [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] y versiones posteriores, el `Key Lookup` operador proporciona la funcionalidad de búsqueda de marcadores. `Clustered Index Seek` es un operador lógico y físico.|  
|![Icono del operador Clustered Index Update](../../2014/database-engine/media/clustered-index-update-32x.gif "Icono del operador Clustered Index Update")|`Clustered Index Update`|El `Clustered Index Update` operador actualiza las filas de entrada en el índice clúster especificado en la `Argument` columna. Si hay un predicado WHERE:(), solo se actualizan las filas que cumplen este predicado. Si hay un predicado SET:(), se asigna este valor a todas las filas actualizadas. Si hay un predicado DEFINE:(), se muestran los valores que define este operador. Se puede hacer referencia a estos valores en la cláusula SET o en cualquier parte del operador, y en cualquier parte de esta consulta. `Clustered Index Update` es un operador lógico y físico.|  
|![Icono del operador Collapse](../../2014/database-engine/media/collapse-32x.gif "Icono del operador Collapse")|`Collapse`|El operador `Collapse` optimiza el proceso de actualización. Cuando se realiza una actualización, esta se puede dividir (con el operador `Split`) en una eliminación y una inserción. La `Argument` columna contiene una cláusula Group by:() que especifica una lista de columnas de clave. Si el procesador de consultas encuentra filas adyacentes que eliminan e insertan los mismos valores clave, reemplazará estas operaciones independientes por una única operación de actualización más eficaz. `Collapse` es un operador lógico y físico.|  
|![Exploración de índice de almacén de columnas](../../2014/database-engine/media/columnstoreindexscan.gif "Exploración de índice de almacén de columnas")|`Columnstore Index Scan`|El `Columnstore Index Scan` operador recorre el índice de almacén de columnas especificado en la `Argument` columna del plan de ejecución de la consulta.|  
|![Icono del operador Compute Scalar](../../2014/database-engine/media/compute-scalar-32x.gif "Icono del operador Compute Scalar")|`Compute Scalar`|El `Compute Scalar` operador evalúa una expresión para generar un valor escalar calculado. que se puede devolver al usuario, hacer referencia a él en cualquier otra parte de la consulta, o ambas cosas a la vez, por ejemplo, en un predicado de filtro o de combinación. `Compute Scalar` es un operador lógico y físico.<br /><br /> `Compute Scalar`es posible que los operadores que aparecen en planes generados por SET STATISTICs XML no contengan el `RunTimeInformation` elemento. En planes de presentación gráficos, es posible que las opciones **Número de filas real**, **Reenlaces reales**y **Rebobinados reales** no aparezcan en la ventana **Propiedades** cuando la opción **Incluir plan de ejecucion real** está seleccionada en [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)]. Si esto ocurre, significa que, aunque estos operadores se han utilizado en el plan de consulta compilado, otros operadores han realizado su trabajo en el plan de consulta en tiempo de ejecución. Tenga en cuenta también que el número de ejecuciones en el resultado del plan de presentación generado por SET STATISTICS PROFILE es equivalente a la suma de reenlaces y rebobinados de planes de presentación generados por SET STATISTICS XML.|  
|![Icono del operador Concatenation](../../2014/database-engine/media/concatenation-32x.gif "Icono del operador Concatenation")|**Concatenation**|El operador **Concatenation** explora varias entradas y devuelve cada fila explorada. Normalmente,**Concatenation** se utiliza para implementar la construcción UNION ALL de [!INCLUDE[tsql](../includes/tsql-md.md)] . El operador físico **Concatenation** tiene dos o más entradas y una salida. Concatenation copia filas del primer flujo de entrada en el flujo de salida y, a continuación, repite esta operación con cada flujo de entrada adicional. **Concatenation** es un operador lógico y físico.|  
|![Icono del operador Constant Scan](../../2014/database-engine/media/constant-scan-32x.gif "Icono del operador Constant Scan")|`Constant Scan`|El `Constant Scan` operador introduce una o varias filas de constantes en una consulta. A `Compute Scalar` menudo, se usa un operador después de `Constant Scan` para agregar columnas a una fila generada por el `Constant Scan` operador.|  
|![Icono del elemento del lenguaje Convert (motor de base de datos)](../../2014/database-engine/media/convert-32x.gif "Icono del elemento del lenguaje Convert (motor de base de datos)")|`Convert`|El operador `Convert` convierte un tipo de datos escalar en otro. `Convert` es un elemento del lenguaje.|  
|None|`Cross Join`|El operador `Cross Join` combina cada fila de la primera entrada (superior) con cada fila de la segunda entrada (inferior). `Cross Join` es un operador lógico.|  
|![Icono del operador de cursor de selección de cursor (catchall)](../../2014/database-engine/media/cursor-catch-all.gif "Icono del operador de cursor de selección de cursor (catchall)")|`catchall`|El icono de selección (catchall) se muestra cuando la lógica que genera planes de presentación gráficos no puede encontrar un icono adecuado para el iterador. Este icono no indica necesariamente una condición de error. Hay tres iconos de selección (catchall): azul (para iteradores), naranja (para cursores) y verde (para elementos del lenguaje [!INCLUDE[tsql](../includes/tsql-md.md)] ).|  
|None|**Cursor**|Los operadores lógicos y físicos **Cursor** se usan para describir cómo se ha ejecutado una consulta o una actualización que implican la ejecución de operaciones con cursores. Los operadores físicos describen el algoritmo físico de implementación utilizado para procesar el cursor, por ejemplo, con un cursor dinámico. Cada paso de la ejecución de un cursor implica un operador físico. Los operadores lógicos describen una propiedad del cursor, como, por ejemplo, si el cursor es de solo lectura.<br /><br /> Los operadores lógicos incluyen asincrónico, optimista, principal, solo lectura, bloqueos de desplazamiento, y secundario y sincrónico.<br /><br /> Los operadores físicos incluyen Dynamic, Fetch Query, Keyset, Population Query, Refresh Query y Snapshot.|  
|![Icono del elemento del lenguaje Declare](../../2014/database-engine/media/declare-32x.gif "Icono del elemento del lenguaje Declare")|`Declare`|El `Declare` operador asigna una variable local en el plan de consulta. `Declare` es un elemento del lenguaje.|  
|![Icono del operador Delete (motor de base de datos)](../../2014/database-engine/media/delete-32x.gif "Icono del operador Delete (motor de base de datos)")|`Delete`|El `Delete` operador elimina de una fila de objeto que satisface el predicado opcional de `Argument` la columna.|  
|![Icono del operador Delete Scan](../../2014/database-engine/media/delete-scan-32x.gif "Icono del operador Delete Scan")|`Deleted Scan`|El operador `Deleted Scan` recorre la tabla eliminada en un desencadenador.|  
|None|`Distinct`|El operador `Distinct` quita los duplicados de un conjunto de filas o de una colección de valores. `Distinct` es un operador lógico.|  
|None|`Distinct Sort`|El `Distinct Sort` operador lógico recorre la entrada, quita los duplicados y ordena por las columnas especificadas en el predicado DISTINCT order by:() de la `Argument` columna. `Distinct Sort` es un operador lógico.|  
|![Icono del operador de paralelismo Distribute Streams](../../2014/database-engine/media/parallelism-distribute-stream.gif "Icono del operador de paralelismo Distribute Streams")|**Distribute Streams**|El operador **Distribute Streams** solo se usa en los planes de consulta paralelos. El operador **Distribute Streams** utiliza una solo flujo de entrada de registros y genera varios flujos de salida. No se cambia el contenido de los registros ni su formato. Cada registro del flujo de entrada aparece en uno de los flujos de salida. Este operador conserva automáticamente el orden relativo de los registros de entrada en los flujos de salida. Normalmente, se utilizan algoritmos hash para decidir a qué flujo de salida pertenece un determinado registro de entrada.<br /><br /> Si la salida tiene particiones, la `Argument` columna contiene un predicado Partition Columns:() y las columnas de partición. **Distribute Streams** es un operador lógico|  
|![Icono del operador de cursor Dynamic](../../2014/database-engine/media/dynamic-32x.gif "Icono del operador de cursor Dynamic")|`Dynamic`|El operador `Dynamic` usa un cursor que puede ver todos los cambios que han realizado otros usuarios.|  
|![Icono del operador Spool](../../2014/database-engine/media/spool-32x.gif "Icono del operador Spool")|**Eager Spool**|El operador de **cola diligente** toma toda la entrada y almacena cada fila en un objeto temporal oculto almacenado en la `tempdb` base de datos. Si el operador se está rebobinando (por ejemplo, por un `Nested Loops` operador) pero no se necesita ningún reenlace, se usan los datos de la cola en lugar de volver a examinar la entrada. Si es necesario volver a enlazar, se descartan los datos y se vuelve a generar el objeto de la cola; para ello se vuelve a recorrer la entrada (se vuelve a enlazar). El operador **Eager Spool** crea su archivo de cola de forma "ansiosa": cuando el operador primario de la cola solicita la primera fila, el operador de cola consume todas las filas de su operador de entrada y las almacena en la cola. **Eager Spool** es un operador lógico.|  
|![Icono del operador de cursor Fetch Query](../../2014/database-engine/media/fetch-query-32x.gif "Icono del operador de cursor Fetch Query")|`Fetch Query`|El operador `Fetch Query` recupera filas cuando se emite una captura en un cursor.|  
|![Icono del operador Filter (motor de base de datos)](../../2014/database-engine/media/filter-32x.gif "Icono del operador Filter (motor de base de datos)")|**Filter**|El operador **Filter** recorre la entrada y solo devuelve las filas que cumplen la expresión de filtro (predicado) que aparece en la `Argument` columna.|  
|None|`Flow Distinct`|El operador lógico `Flow Distinct` recorre la entrada y quita los duplicados. Mientras que el `Distinct` operador consume toda la entrada antes de generar cualquier salida, el operador **FlowDistinct** devuelve cada fila a medida que se obtiene de la entrada (a menos que la fila esté duplicada, en cuyo caso se descarta).|  
|None|`Full Outer Join`|El operador lógico `Full Outer Join` devuelve cada fila que cumple el predicado de combinación de la primera entrada (superior) combinada con cada fila de la segunda entrada (inferior). También devuelve filas de:<br /><br /> -La primera entrada que no tenga coincidencias en la segunda entrada.<br /><br /> -La segunda entrada que no tenga coincidencias en la primera entrada.<br /><br /> <br /><br /> La entrada que no contiene valores coincidentes se devuelve como un valor nulo. `Full Outer Join` es un operador lógico.|  
|![Icono del operador de paralelismo Gather Streams](../../2014/database-engine/media/parallelism-32x.gif "Icono del operador de paralelismo Gather Streams")|**Gather Streams**|El operador **Gather Streams** solo se usa en planes de consulta paralelos. El operador **Gather Streams** procesa varios flujos de entrada y produce un único flujo de salida de registros combinando los flujos de entrada. No se cambia el contenido de los registros ni su formato. Si este operador conserva el orden, todos los flujos de entrada deben estar ordenados. Si el resultado está ordenado, la `Argument` columna contiene un predicado order by:() y los nombres de las columnas que se están ordenando. **Gather Streams** es un operador lógico.|  
|![Icono del operador Hash Match](../../2014/database-engine/media/hash-match-32x.gif "Icono del operador Hash Match")|`Hash Match`|El operador `Hash Match` genera una tabla hash y calcula un valor hash para cada fila de su entrada de compilación. En la columna aparece un predicado HASH:() con una lista de columnas que se usa para crear un valor hash `Argument` . A continuación, por cada fila de sondeo (como corresponda), calcula un valor hash (con la misma función hash) y busca las coincidencias en la tabla hash. Si hay un predicado residual (identificado por el RESIDUAL del predicado en la `Argument` columna), también se debe cumplir ese predicado para que las filas se consideren una coincidencia. El comportamiento depende de la operación lógica que se esté realizando:<br /><br /> Para cualquier combinación, utilice la primera entrada (superior) para generar la tabla hash y la segunda entrada (inferior) para sondear la tabla hash. Obtendrá como resultado las coincidencias (o las no coincidencias) que indique el tipo de combinación. Si varias combinaciones utilizan la misma columna de combinación, estas operaciones se agrupan en un equipo hash.<br /><br /> Para los operadores Distinct o Aggregate, utilice la entrada para generar la tabla hash (para ello, quite los duplicados y calcule las expresiones de agregado). Cuando se haya generado la tabla hash, recorra la tabla y presente todas las entradas.<br /><br /> En el caso del operador Union, utilice la primera entrada para generar la tabla hash (para ello, quite los duplicados). Use la segunda entrada (que no debe tener duplicados) para sondear la tabla hash, devolver todas las filas que no tengan coincidencias y, a continuación, recorrer la tabla hash para devolver todas las entradas.<br /><br /> <br /><br /> `Hash Match` es un operador físico.|  
|![Icono del elemento del lenguaje If](../../2014/database-engine/media/if-32x.gif "Icono del elemento del lenguaje If")|`If`|El operador `If` lleva a cabo el procesamiento condicional basado en una expresión. `If` es un elemento del lenguaje.|  
|None|`Inner Join`|El operador lógico `Inner Join` devuelve todas las filas que cumplen la combinación de la primera entrada (superior) con la segunda entrada (inferior).|  
|![Icono del operador Insert (motor de base de datos)](../../2014/database-engine/media/insert-32x.gif "Icono del operador Insert (motor de base de datos)")|`Insert`|El `Insert` operador lógico inserta cada fila de su entrada en el objeto especificado en la `Argument` columna. El operador físico es `Table Insert`, `Index Insert` o `Clustered Index Insert`|  
|![Icono del operador Inserted Scan](../../2014/database-engine/media/inserted-scan-32x.gif "Icono del operador Inserted Scan")|**Inserted Scan**|El operador **Inserted Scan** recorre la tabla **insertada** . **Inserted Scan** es un operador lógico y físico.|  
|![Icono del elemento del lenguaje Intrinsic](../../2014/database-engine/media/intrinsic-32x.gif "Icono del elemento del lenguaje Intrinsic")|`Intrinsic`|El operador `Intrinsic` invoca una función [!INCLUDE[tsql](../includes/tsql-md.md)] interna. `Intrinsic` es un elemento del lenguaje.|  
|![Icono del operador de selección (catchall) de iterador](../../2014/database-engine/media/iterator-catch-all.gif "Icono del operador de selección (catchall) de iterador")|`Iterator`|El icono de selección (catchall) `Iterator` se muestra cuando la lógica que genera planes de presentación gráficos no puede encontrar un icono adecuado para el iterador. Este icono no indica necesariamente una condición de error. Hay tres iconos de selección (catchall): azul (para iteradores), naranja (para cursores) y verde (para construcciones del lenguaje [!INCLUDE[tsql](../includes/tsql-md.md)] ).|  
|![Icono del operador Bookmark Lookup](../../2014/database-engine/media/bookmark-lookup-32x.gif "Icono del operador Bookmark Lookup")|`Key Lookup`|El `Key Lookup` operador es una búsqueda de marcadores en una tabla con un índice clúster. La `Argument` columna contiene el nombre del índice clúster y la clave de agrupación en clústeres utilizada para buscar la fila en el índice clúster. `Key Lookup`siempre está acompañado por un `Nested Loops` operador. Si la cláusula WITH Prefetch aparece en la `Argument` columna, el procesador de consultas ha determinado que es óptimo usar la captura previa asincrónica (lectura anticipada) al buscar marcadores en el índice clúster.<br /><br /> El uso de un `Key Lookup` operador en un plan de consulta indica que la consulta puede beneficiarse del ajuste del rendimiento. Por ejemplo, el rendimiento de las consultas se puede mejorar al agregar un índice de cobertura.|  
|![Icono del operador de cursor Keyset](../../2014/database-engine/media/keyset-32x.gif "Icono del operador de cursor Keyset")|`Keyset`|El operador `Keyset` usa un cursor que puede ver las actualizaciones, pero no las inserciones que realizan los demás.|  
|![Icono de selección (catchall) de elementos de lenguaje](../../2014/database-engine/media/language-construct-catch-all.gif "Icono de selección (catchall) de elementos de lenguaje")|`Language Element`|El icono de selección (catchall) `Language Element` se muestra cuando la lógica que genera planes de presentación gráficos no puede encontrar un icono adecuado para el iterador. Este icono no indica necesariamente una condición de error. Hay tres iconos de selección (catchall): azul (para iteradores), naranja (para cursores) y verde (para construcciones del lenguaje [!INCLUDE[tsql](../includes/tsql-md.md)] ).|  
|![Icono del operador Spool](../../2014/database-engine/media/spool-32x.gif "Icono del operador Spool")|**Lazy Spool**|El operador lógico **Lazy spool** almacena cada fila de su entrada en un objeto temporal oculto almacenado en la `tempdb` base de datos. Si el operador se está rebobinando (por ejemplo, por un `Nested Loops` operador) pero no se necesita ningún reenlace, se usan los datos de la cola en lugar de volver a examinar la entrada. Si es necesario volver a enlazar, se descartan los datos y se vuelve a generar el objeto de la cola; para ello se vuelve a recorrer la entrada (se vuelve a enlazar). El operador **Lazy Spool** crea su archivo de cola de un modo "perezoso", es decir, cada vez que el operador principal de la cola pide una fila, el operador de cola obtiene una fila de su operador de entrada y la almacena en la cola, en lugar de consumir todas las filas de una vez. Lazy Spool es un operador lógico.|  
|None|`Left Anti Semi Join`|El operador `Left Anti Semi Join` devuelve todas las filas de la primera entrada (superior) cuando no hay ninguna fila coincidente en la segunda entrada (inferior). Si no existe ningún predicado de combinación en la `Argument` columna, cada fila es una fila coincidente. `Left Anti Semi Join` es un operador lógico.|  
|None|`Left Outer Join`|El operador `Left Outer Join` devuelve cada fila que cumple la combinación de la primera entrada (superior) con la segunda entrada (inferior). También devuelve las filas de la primera entrada que no tienen filas coincidentes en la segunda entrada. Las filas que no coinciden en la segunda entrada se devuelven como valores NULL. Si no existe ningún predicado de combinación en la `Argument` columna, cada fila es una fila coincidente. `Left Outer Join` es un operador lógico.|  
|None|`Left Semi Join`|El operador `Left Semi Join` devuelve todas las filas de la primera entrada (superior) cuando hay una fila coincidente en la segunda entrada (inferior). Si no existe ningún predicado de combinación en la `Argument` columna, cada fila es una fila coincidente. `Left Semi Join` es un operador lógico.|  
|![Icono del operador Log Row Scan](../../2014/database-engine/media/log-row-scan-32x.gif "Icono del operador Log Row Scan")|`Log Row Scan`|El operador `Log Row Scan` recorre el registro de transacciones. `Log Row Scan` es un operador lógico y físico.|  
|![Icono del operador Merge Interval](../../2014/database-engine/media/merge-interval-32x.gif "Icono del operador Merge Interval")|`Merge Interval`|El operador `Merge Interval` combina varios intervalos (que pueden superponerse) para producir intervalos mínimos que no se superponen y que se usan para buscar entradas de índice. Este operador aparece normalmente sobre uno o más `Compute Scalar` operadores sobre `Constant Scan` operadores, que construyen los intervalos (representados como columnas de una fila) que este operador combina. `Merge Interval` es un operador lógico y físico.|  
|![Icono del operador Merge Join](../../2014/database-engine/media/merge-join-32x.gif "Icono del operador Merge Join")|**Merge Join**|El operador **Merge Join** realiza las siguientes operaciones lógicas de combinación interna (inner join), combinación externa izquierda (left outer join), semicombinación izquierda (left semi join), antisemicombinación izquierda (left anti semi join), combinación externa derecha (right outer join), semicombinación derecha (right semi join), antisemicombinación derecha (right anti semi join) y unión (union).<br /><br /> En la `Argument` columna, el operador **Merge join** contiene un predicado Merge:() si la operación realiza una combinación uno a varios, o un predicado de combinación de varios a varios, si la operación realiza una combinación de varios a varios. La `Argument` columna también incluye una lista separada por comas de las columnas utilizadas para realizar la operación. El operador **Merge Join** requiere dos entradas ordenadas por sus respectivas columnas, que se pueden realizar mediante la inserción de operaciones de ordenación explícitas en el plan de consulta. El operador Merge Join es especialmente eficaz si no se necesita un orden explícito, por ejemplo, si hay un índice idóneo de árbol b en la base de datos o si el orden se puede aprovechar en varias operaciones, como en una combinación de mezcla y una agrupación con acumulación. **Merge Join** es un operador físico.|  
|![Icono del operador Nested Loops](../../2014/database-engine/media/nested-loops-32x.gif "Icono del operador Nested Loops")|`Nested Loops`|El operador `Nested Loops` realiza las operaciones lógicas de combinación interna, combinación externa izquierda, semicombinación izquierda y anti semicombinación. Las combinaciones de bucles anidados realizan una búsqueda en la tabla interna por cada fila de la tabla externa, normalmente mediante un índice. El procesador de consultas decide, en función de los costos anticipados, si debe ordenar o no la entrada externa para mejorar la ubicación de las búsquedas en el índice sobre la entrada interna. Todas las filas que cumplen el predicado (opcional) en la `Argument` columna se devuelven como corresponda, en función de la operación lógica que se realiza. `Nested Loops` es un operador físico.|  
|![Icono del operador Nonclustered Index Delete](../../2014/database-engine/media/nonclust-index-delete-32x.gif "Icono del operador Nonclustered Index Delete")|`Nonclustered Index Delete`|El `Nonclustered Index Delete` operador elimina las filas de entrada del índice no clúster especificado en la `Argument` columna. `Nonclustered Index Delete` es un operador físico.|  
|![Icono del operador Nonclustered Index Insert](../../2014/database-engine/media/nonclust-index-insert-32x.gif "Icono del operador Nonclustered Index Insert")|`Index Insert`|El `Index Insert` operador inserta filas de su entrada en el índice no clúster especificado en la `Argument` columna. La columna `Argument` contiene también un predicado SET:(), que indica el valor en el que se establece cada columna. `Index Insert` es un operador físico.|  
|![Icono del operador Nonclustered Index Scan](../../2014/database-engine/media/nonclustered-index-scan-32x.gif "Icono del operador Nonclustered Index Scan")|`Index Scan`|El `Index Scan` operador recupera todas las filas del índice no clúster especificado en la `Argument` columna. Si aparece un predicado WHERE:() opcional en la `Argument` columna, solo se devuelven las filas que cumplen el predicado. `Index Scan` es un operador lógico y físico.|  
|![Icono del operador Nonclustered Index Seek](../../2014/database-engine/media/index-seek-32x.gif "Icono del operador Nonclustered Index Seek")|`Index Seek`|El operador `Index Seek` usa la capacidad de búsqueda de los índices para recuperar filas de un índice no clúster. La `Argument` columna contiene el nombre del índice no clúster que se está usando. También contiene el predicado SEEK:(). El motor de almacenamiento utiliza el índice para procesar solamente las filas que cumplen el predicado SEEK:(). También se puede incluir un predicado WHERE:(), predicado que evaluará el motor de almacenamiento respecto a todas las filas que cumplan el predicado SEEK:() (no se utilizan los índices para esta comprobación). Si la `Argument` columna contiene la cláusula ordered, el procesador de consultas ha determinado que las filas deben devolverse en el orden en el que el índice no clúster las haya clasificado. Si no hay una cláusula ORDERED, el motor de almacenamiento busca el índice de la forma óptima (que no garantiza que el resultado se ordene). Permitir que el resultado mantenga su ordenación puede ser menos eficiente que generar un resultado no ordenado. `Index Seek` es un operador lógico y físico.|  
|![Icono del operador Nonclustered Index Spool](../../2014/database-engine/media/index-spool-32x.gif "Icono del operador Nonclustered Index Spool")|**Index Spool**|El operador físico **index spool** contiene un predicado Seek:() en la `Argument` columna. El operador **index spool** recorre sus filas de entrada, coloca una copia de cada fila en un archivo de cola oculto (almacenado en la `tempdb` base de datos y que solo existe durante la duración de la consulta) y genera un índice no clúster en las filas. Esto permite utilizar la capacidad de búsqueda de los índices para presentar solo las filas que cumplan el predicado SEEK:(). Si el operador se está rebobinando (por ejemplo, por un `Nested Loops` operador) pero no se necesita ningún reenlace, se usan los datos de la cola en lugar de volver a examinar la entrada.|  
|![Icono del operador Nonclustered Index Update](../../2014/database-engine/media/nonclust-index-update-32x.gif "Icono del operador Nonclustered Index Update")|`Nonclustered Index Update`|El `Nonclustered Index Update` operador físico actualiza las filas de su entrada en el índice no clúster especificado en la `Argument` columna. Si hay un predicado SET:(), se asigna este valor a todas las filas actualizadas. `Nonclustered Index Update` es un operador físico.|  
|![Icono del operador Online Index Insert](../../2014/database-engine/media/online-index-32x.gif "Icono del operador Online Index Insert")|**Online Index Insert**|El operador físico **Online Index Insert** indica que una operación de crear, modificar o colocar índice se realiza en línea. Es decir, los datos de la tabla subyacente permanecen disponible para los usuarios durante la operación de índice.|  
|None|`Parallelism`|El `Parallelism` operador realiza las operaciones lógicas distribute streams, Gather streams y Repartition streams. Las `Argument` columnas pueden contener un predicado Partition Columns:() con una lista separada por comas de las columnas en las que se van a crear particiones. Las `Argument` columnas también pueden contener un predicado order by:(), con una lista de las columnas para conservar el criterio de ordenación durante la creación de particiones. `Parallelism` es un operador físico.<br /><br /> Nota: si se ha compilado una consulta como consulta paralela, pero en tiempo de ejecución se ejecuta como consulta en serie, la salida del plan de presentación generada por SET STATISTICs XML o mediante la opción **incluir plan de ejecución real** de [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)] no contendrá el `RunTimeInformation` elemento del `Parallelism` operador. En la salida de SET STATISTICs PROFILE, el recuento de filas real y el número real de ejecuciones mostrará ceros para el `Parallelism` operador. Cuando se produce cualquiera de las condiciones, significa que el `Parallelism` operador solo se utilizó durante la compilación de la consulta y no en el plan de consulta en tiempo de ejecución. Tenga en cuenta que a veces los planes de consulta paralelos se ejecutan en serie si existe una elevada carga simultánea en el servidor.|  
|![Icono del operador Parameter Table Scan](../../2014/database-engine/media/parameter-table-scan-32x.gif "Icono del operador Parameter Table Scan")|`Parameter Table Scan`|El operador `Parameter Table Scan` recorre una tabla que actúa como parámetro en la consulta actual. Normalmente, se usa para consultas INSERT en un procedimiento almacenado. `Parameter Table Scan` es un operador lógico y físico.|  
|None|**Partial Aggregate**|**Partial Aggregate** se usa en planes paralelos. Aplica una función de agregación a tantas filas de entrada como sea posible para que la escritura en el disco (también denominada "volcado") no sea necesaria. `Hash Match`es el único operador físico (iterador) que implementa la agregación de la partición. **Partial Aggregate** es un operador lógico.|  
|![Icono del operador de cursor Population Query](../../2014/database-engine/media/poulation-query-32x.gif "Icono del operador de cursor Population Query")|`Population Query`|El operador `Population Query` rellena la tabla de trabajo de un cursor cuando se abre el cursor.|  
|![Icono del operador de cursor Refresh Query](../../2014/database-engine/media/refresh-query-32x.gif "Icono del operador de cursor Refresh Query")|`Refresh Query`|El operador `Refresh Query` captura los datos actuales de las filas del búfer de lectura.|  
|![Icono del operador Remote Delete](../../2014/database-engine/media/remote-delete-32x.gif "Icono del operador Remote Delete")|`Remote Delete`|El operador `Remote Delete` elimina las filas de entrada de un objeto remoto. `Remote Delete` es un operador lógico y físico.|  
|![Remote Index Seek (operador de SHOWPLAN)](../../2014/database-engine/media/remote-index-scan-32x.gif "Operador de plan de presentación Remote Index Seek")|**Remote Index Scan**|El operador **Remote Index Scan** digitaliza el índice remoto especificado en la columna Argument. **Remote Index Scan** es un operador lógico y físico.|  
|![Remote Index Seek (operador de SHOWPLAN)](../../2014/database-engine/media/remote-index-seek-32x.gif "Operador de plan de presentación Remote Index Seek")|**Remote Index Seek**|El operador **Remote Index Seek** usa la capacidad de búsqueda de un objeto de índice remoto para recuperar filas. La `Argument` columna contiene el nombre del índice remoto que se está usando y el predicado Seek:(). **Remote Index Seek** es un operador lógico y físico.|  
|![Icono del operador Remote Insert](../../2014/database-engine/media/remote-insert-32x.gif "Icono del operador Remote Insert")|**Remote Insert**|El operador **Remote Insert** inserta las filas de entrada en un objeto remoto. **Remote Insert** es un operador lógico y físico.|  
|![Icono del operador Remote Query](../../2014/database-engine/media/remote-query-32x.gif "Icono del operador Remote Query")|`Remote Query`|El operador `Remote Query` envía una consulta a un origen remoto. El texto de la consulta enviada al servidor remoto aparece en la `Argument` columna. `Remote Query` es un operador lógico y físico.|  
|![Icono del operador Remote Scan](../../2014/database-engine/media/remote-scan-32x.gif "Icono del operador Remote Scan")|`Remote Scan`|El operador `Remote Scan` recorre un objeto remoto. El nombre del objeto remoto aparece en la `Argument` columna. `Remote Scan` es un operador lógico y físico.|  
|![Icono del operador Remote Update](../../2014/database-engine/media/remote-update-32x.gif "Icono del operador Remote Update")|`Remote Update`|El operador `Remote Update` actualiza las filas de entrada en un objeto remoto. `Remote Update` es un operador lógico y físico.|  
|![Icono del operador de paralelismo Repartition Streams](../../2014/database-engine/media/parallelism-repartition-stream.gif "Icono del operador de paralelismo Repartition Streams")|**Repartition Streams**|El operador **Repartition Streams** usa varios flujos y produce varios flujos de registros. No se cambia el contenido de los registros ni su formato. Si el optimizador de consultas usa un filtro de mapas de bits, se reduce el número de filas del flujo de salida. Cada registro de un flujo de entrada se coloca en un flujo de salida. Si el operador conserva el orden, se deben ordenar y mezclar todos los flujos de entrada en varios flujos de salida ordenados. Si la salida tiene particiones, la `Argument` columna contiene un predicado Partition Columns:() y las columnas de partición. Si el resultado está ordenado, la `Argument` columna contiene un predicado order by:() y las columnas que se están ordenando. **Repartition Streams** es un operador lógico. Este operador solo se usa en los planes de consulta paralelos.|  
|![Icono del elemento del lenguaje Result](../../2014/database-engine/media/result-32x.gif "Icono del elemento del lenguaje Result")|`Result`|El operador `Result` incluye los datos devueltos al final de un plan de consulta. Suele ser el elemento raíz de un plan de presentación. `Result` es un elemento del lenguaje.|  
|![Icono del operador RID Lookup](../../2014/database-engine/media/rid-nonclust-locate-32x.gif "Icono del operador RID Lookup")|`RID Lookup`|`RID Lookup` es una búsqueda de marcadores en un montón que usa un identificador de fila suministrado (RID). La `Argument` columna contiene la etiqueta de marcador utilizada para buscar la fila en la tabla y el nombre de la tabla en la que se busca la fila. `RID Lookup` siempre va acompañado de NESTED LOOP JOIN. `RID Lookup` es un operador físico. Para obtener más información sobre las búsquedas por marcador, vea "[Bookmark Lookup](https://go.microsoft.com/fwlink/?LinkId=132568)" (en inglés) en el blog de SQL Server en MSDN.|  
|None|`Right Anti Semi Join`|El operador `Right Anti Semi Join` muestra todas las filas de la segunda entrada (inferior) para las que no hay una fila coincidente en la primera entrada (superior). Una fila coincidente se define como una fila que satisface el predicado de la `Argument` columna (si no existe ningún predicado, cada fila es una fila coincidente). `Right Anti Semi Join` es un operador lógico.|  
|None|`Right Outer Join`|El operador `Right Outer Join` devuelve cada fila que cumple la combinación de la segunda entrada (inferior) con cada fila coincidente de la primera entrada (superior). También devolverá las filas de la segunda entrada que no tengan filas coincidentes en la primera entrada, combinadas con NULL (nulo). Si no existe ningún predicado de combinación en la `Argument` columna, cada fila es una fila coincidente. `Right Outer Join` es un operador lógico.|  
|None|`Right Semi Join`|El operador `Right Semi Join` devuelve todas las filas de la segunda entrada (inferior) para las que haya una fila coincidente en la primera entrada (superior). Si no existe ningún predicado de combinación en la `Argument` columna, cada fila es una fila coincidente. `Right Semi Join` es un operador lógico.|  
|![Icono del operador Row Count Spool](../../2014/database-engine/media/remote-count-spool-32x.gif "Icono del operador Row Count Spool")|**Row Count Spool**|El operador **Row Count Spool** recorre la entrada, cuenta el número de filas que hay y devuelve ese número de filas sin datos. Este operador se utiliza cuando es importante comprobar la existencia de las filas, en lugar de los datos que éstas contienen. Por ejemplo, si un `Nested Loops` operador realiza una operación de semicombinación izquierda y el predicado de combinación se aplica a la entrada interna, se puede colocar una cola de recuento de filas en la parte superior de la entrada interna del `Nested Loops` operador. A continuación, el `Nested Loops` operador puede determinar el número de filas que genera la cola de recuento de filas (dado que los datos reales del lado interno no son necesarios) para determinar si se debe devolver la fila externa. **Row Count Spool** es un operador físico.|  
|![Icono del operador Segment](../../2014/database-engine/media/segment-32x.gif "Icono del operador Segment")|**Segmento**|**Segment** es un operador físico y lógico. Divide el conjunto de entrada en segmentos basados en el valor de una o varias columnas. Estas columnas se muestran como argumentos en el operador **Segment** . A continuación, muestra un segmento cada vez.|  
|None|`Segment Repartition`|En un plan de consulta paralelo, a veces hay regiones conceptuales de iteradores. Todos los iteradores de una región así se pueden ejecutar mediante subprocesos paralelos. Las regiones en sí deben ejecutarse en serie. Algunos de los iteradores `Parallelism` de una región individual se denominan `Branch Repartition`. El iterador `Parallelism` situado en el límite de dos de estas regiones se denomina `Segment Repartition`. `Branch Repartition` y `Segment Repartition` son operadores lógicos.|  
|![Icono del operador Sequence](../../2014/database-engine/media/sequence-32x.gif "Icono del operador Sequence")|`Sequence`|El operador `Sequence` controla los planes de actualización grandes. Funcionalmente, ejecuta cada entrada en secuencia (de principio a fin). Normalmente, cada entrada es una actualización de un objeto diferente. Solo devuelve las filas que proceden de su última entrada (inferior). `Sequence` es un operador lógico y físico.|  
|![Icono del operador Sequence Project](../../2014/database-engine/media/sequence-project-32x.gif "Icono del operador Sequence Project")|`Sequence Project`|El operador `Sequence Project` agrega columnas para realizar cálculos sobre un conjunto ordenado. Divide el conjunto de entrada en segmentos basados en el valor de una o varias columnas. A continuación, muestra un segmento cada vez. En el operador `Sequence Project`, las columnas se muestran como argumentos. `Sequence Project` es un operador lógico y físico.|  
|![Icono del operador de cursor Snapshot](../../2014/database-engine/media/snapshot-32x.gif "Icono del operador de cursor Snapshot")|**Instantánea**|El operador **Snapshot** crea un cursor que no detecta las modificaciones realizadas por otros.|  
|![Icono del operador Sort](../../2014/database-engine/media/sort-32x.gif "Icono del operador Sort")|`Sort`|El `Sort` operador ordena todas las filas entrantes. La `Argument` columna contiene un predicado DISTINCT order by:() si esta operación quita los duplicados, o un predicado order by:() con una lista separada por comas de las columnas que se están ordenando. Las columnas llevan como prefijo el valor ASC, si el orden de las columnas es ascendente, o el valor DESC, si es descendente. `Sort` es un operador lógico y físico.|  
|![Icono del operador Split](../../2014/database-engine/media/split-32x.gif "Icono del operador Split")|`Split`|El `Split` operador se usa para optimizar el procesamiento de actualizaciones. Divide cada operación de actualización en una operación de eliminación y una operación de inserción. `Split` es un operador lógico y físico.|  
|![Icono del operador Spool](../../2014/database-engine/media/spool-32x.gif "Icono del operador Spool")|**Spool**|El operador **spool** guarda un resultado de consulta intermedio en la `tempdb` base de datos.|  
|![Icono del operador Stream Aggregate](../../2014/database-engine/media/stream-aggregate-32x.gif "Icono del operador Stream Aggregate")|`Stream Aggregate`|El operador `Stream Aggregate` agrupa las filas por una o varias columnas y, a continuación, calcula una o varias expresiones agregadas devueltas por la consulta. El resultado de este operador puedes ser utilizado por operadores posteriores de la consulta, devuelto al cliente, o ambas cosas. El operador `Stream Aggregate` requiere una entrada ordenada por las columnas dentro de sus grupos. El optimizador usará un operador `Sort` antes de este operador si un operador `Sort` anterior no ha ordenado ya los datos o debido a una búsqueda o recorrido de índice ordenado. En la instrucción SHOWPLAN_ALL o en el plan de ejecución gráfico de [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)] , las columnas del predicado Group by se enumeran en la `Argument` columna y las expresiones de agregado se enumeran en la columna **valores definidos** . `Stream Aggregate` es un operador físico.|  
|![Icono del operador Switch](../../2014/database-engine/media/switch-32x.gif "Icono del operador Switch")|**Switch**|**Switch** es un tipo especial de iterador de concatenación que tiene *n* entradas. A cada operador **Switch** se asocia una expresión. Dependiendo del valor devuelto de la expresión (entre 0 y *n*-1), **Switch** copia el flujo de entrada correspondiente en el flujo de salida. Un uso de **Switch** consiste en implementar planes de consulta en los que participan cursores de avance rápido con determinados operadores, como el operador **TOP** . **Switch** es un operador lógico y físico.|  
|![Icono del operador Table Delete](../../2014/database-engine/media/table-delete-32x.gif "Icono del operador Table Delete")|`Table Delete`|El `Table Delete` operador físico elimina las filas de la tabla especificada en la `Argument` columna del plan de ejecución de la consulta.|  
|![Icono del operador Table Insert](../../2014/database-engine/media/table-insert-32x.gif "Icono del operador Table Insert")|`Table Insert`|El `Table Insert` operador inserta filas de su entrada en la tabla especificada en la `Argument` columna del plan de ejecución de la consulta. La columna `Argument` contiene también un predicado SET:(), que indica el valor en el que se establece cada columna. Si `Table Insert` no tiene elementos secundarios para los valores de inserción, se obtendrá la fila insertada del propio operador Insert. `Table Insert` es un operador físico.|  
|![Operador Table Merge](../../2014/database-engine/media/table-merge-32x.gif "Operador Table Merge")|**Table Merge**|El operador **Table Merge** aplica un flujo de datos de mezcla a un montón. El operador elimina, actualiza o inserta filas en la tabla especificada en la `Argument` columna del operador. La operación real realizada depende del valor en tiempo de ejecución de la columna **Action** especificada en la `Argument` columna del operador. **Table Merge** es un operador físico.|  
|![Icono del operador Table Scan](../../2014/database-engine/media/table-scan-32x.gif "Icono del operador Table Scan")|`Table Scan`|El `Table Scan` operador recupera todas las filas de la tabla especificada en la `Argument` columna del plan de ejecución de la consulta. Si aparece un predicado WHERE:() en la `Argument` columna, solo se devuelven las filas que cumplen el predicado. `Table Scan` es un operador lógico y físico.|  
|![Icono del operador Table Spool](../../2014/database-engine/media/table-spool-32x.gif "Icono del operador Table Spool")|**Table Spool**|El operador **Table Spool** recorre la entrada y coloca una copia de cada fila en una tabla de cola oculta almacenada en la base de datos [tempdb](../relational-databases/databases/tempdb-database.md) y que solo existe durante la duración de la consulta. Si el operador se está rebobinando (por ejemplo, por un `Nested Loops` operador) pero no se necesita ningún reenlace, se usan los datos de la cola en lugar de volver a examinar la entrada. **Table Spool** es un operador físico.|  
|![Icono del operador Table Update](../../2014/database-engine/media/table-update-32x.gif "Icono del operador Table Update")|`Table Update`|El `Table Update` operador físico actualiza las filas de entrada en la tabla especificada en la `Argument` columna del plan de ejecución de la consulta. El predicado SET:() determina el valor de cada columna actualizada. Se puede hacer referencia a estos valores en la cláusula SET o en cualquier parte del operador, y en cualquier parte de esta consulta.|  
|![Icono del operador Table-valued Function](../../2014/database-engine/media/table-valued-function-32x.gif "Icono del operador Table-valued Function")|**Table-valued Function**|El operador **Table-valued Function** evalúa una función con valores de tabla ( [!INCLUDE[tsql](../includes/tsql-md.md)] o CLR) y almacena las filas resultantes en la base de datos [tempdb](../relational-databases/databases/tempdb-database.md) . Cuando los iteradores principales solicitan las filas, la **función con valores de tabla** devuelve las filas de `tempdb` .<br /><br /> Las consultas con llamadas a funciones con valores de tablas generan planes de consultas con el iterador de la **Table-valued Function** . **Table-valued Function** se puede evaluar con valores de parámetro diferentes:<br /><br /> **Table-valued Function XML Reader** escribe un BLOB XML como parámetro y genera un conjunto de filas que representa los nodos XML en el orden del documento XML. Otros parámetros de entrada pueden restringir los nodos XML devueltos a un subconjunto del documento XML.<br /><br /> **Table Valued Function XML Reader with XPath filter** es un tipo especial de **XML Reader Table-valued Function** que restringe la salida a los nodos XML que satisfacen una expresión XPath.<br /><br /> <br /><br /> **Table-valued Function** es un operador lógico y físico.|  
|![Icono del operador Top](../../2014/database-engine/media/top-32x.gif "Icono del operador Top")|**Top** (Principales)|El operador **Top** recorre la entrada y solo devuelve el primer número o porcentaje especificado de filas, basándose en un criterio de ordenación si es posible. La `Argument` columna puede contener una lista de las columnas en las que se comprueban los vínculos. En los planes de actualización, se usa el operador **Top** para aplicar límites de recuento de filas. **Top** es un operador lógico y físico. **Top** es un operador lógico y físico.|  
|None|**Top N Sort**|El **orden Top N** es similar al `Sort` iterador, excepto en que solo se necesitan las primeras *N* filas y no en el conjunto de resultados completo. Para valores pequeños de *N*, el motor de ejecución de consultas de [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] intenta realizar toda la operación de ordenación en memoria. Para valores grandes de *N*, el motor de ejecución de consultas recurre al método más genérico de ordenación, en el que *N* no es un parámetro.|  
|![Icono del operador extendido (UDX)](../../2014/database-engine/media/udx-32x.gif "Icono del operador extendido (UDX)")|`UDX`|Los operadores extendidos (UDX) implementan una de las múltiples operaciones XQuery y XPath de [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]. Todos los operadores UDX son operadores lógicos y físicos.<br /><br /> El operador extendido (UDX) `FOR XML` se utiliza para serializar el conjunto de filas relacional que introduce en la representación XML en una única columna BLOB de una única fila de salida. Es un operador de agregado XML que depende del orden.<br /><br /> El operador extendido (UDX) `XML SERIALIZER` es un operador de agregado XML que depende del orden. Especifica filas que representan nodos XML o valores escalares de XQuery en el orden del documento XML y produce un objeto BLOB XML serializado en una única columna XML de una única fila de salida.<br /><br /> El operador extendido (UDX) `XML FRAGMENT SERIALIZER` es un tipo especial de `XML SERIALIZER` que se utiliza para procesar filas de entrada que representan fragmentos XML que se insertan en la extensión de modificación de datos de inserción XQuery.<br /><br /> El operador extendido (UDX) `XQUERY STRING` evalúa el valor de cadena XQuery de las filas de entrada que representan nodos XML. Es un operador de agregado de cadena que depende del orden. Produce una fila con columnas que representa el valor escalar de XQuery que contiene el valor de cadena de la entrada.<br /><br /> El operador extendido (UDX) `XQUERY LIST DECOMPOSER` es un operador de descomposición de lista XQuery. Para cada fila de entrada que representa un nodo XML, produce una o varias filas, cada una de las cuales representa un valor escalar de XQuery que contiene un valor de elemento de lista si la entrada es de tipo lista XSD.<br /><br /> El operador extendido (UDX) `XQUERY DATA` evalúa la función XQuery fn:data() en la entrada que representa nodos XML. Es un operador de agregado de cadena que depende del orden. Genera una fila con columnas que representa el valor escalar de XQuery que contiene el resultado de **fn:data()** .<br /><br /> El operador extendido `XQUERY CONTAINS` evalúa la función XQuery fn:contains() en la entrada que representa nodos XML. Es un operador de agregado de cadena que depende del orden. Genera una fila con columnas que representa el valor escalar de XQuery que contiene el resultado de **fn:contains()** .<br /><br /> El operador extendido `UPDATE XML NODE` actualiza el nodo XML en la extensión de modificación de datos de reemplazo de XQuery en el método **Modify ()** en el tipo XML.|  
|None|**Unión**|El operador **Union** recorre varias entradas, obtiene cada fila recorrida y quita los duplicados. **Union** es un operador lógico.|  
|![Icono del operador Update (motor de base de datos)](../../2014/database-engine/media/update-32x.gif "Icono del operador Update (motor de base de datos)")|`Update`|El `Update` operador actualiza cada fila de su entrada en el objeto especificado en la `Argument` columna del plan de ejecución de la consulta. `Update` es un operador lógico. El operador físico es `Table Update`, `Index Update` o `Clustered Index Update`.|  
|![Icono del elemento del lenguaje While](../../2014/database-engine/media/while-32x.gif "Icono del elemento del lenguaje While")|`While`|El operador `While` implementa el bucle while de [!INCLUDE[tsql](../includes/tsql-md.md)]. `While` es un elemento del lenguaje|  
|![Icono del operador Table Spool](../../2014/database-engine/media/table-spool-32x.gif "Icono del operador Table Spool")|`Window Spool`|El operador `Window Spool` expande cada fila del conjunto de filas que representa la ventana asociada con él. En una consulta, la cláusula OVER define la ventana de un conjunto de resultados de la consulta y, a continuación, una función de ventana calcula un valor para cada fila de la ventana. `Window Spool` es un operador lógico y físico.|  
  
  
