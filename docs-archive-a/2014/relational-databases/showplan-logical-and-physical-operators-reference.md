---
title: Referencia de operadores lógicos y físicos del plan de presentación | Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: ''
ms.topic: conceptual
f1_keywords:
- sql12.swb.showplan.nestedloops.f1
- sql12.swb.showplan.dynamic.f1
- sql12.swb.showplan.tableinsert.f1
- sql12.swb.showplan.remoteinsert.f1
- sql12.swb.showplan.lazyspool.f1
- sql12.swb.showplan.RIDLookup
- sql12.swb.showplan.hashmatchteam.f1
- sql12.swb.showplan.tablespool.f1
- sql12.swb.showplan.print.f1
- sql12.swb.showplan.clusteredindexupdate.f1
- sql12.swb.showplan.assert.f1
- sql12.swb.showplan.columnstoreindexscan.f1
- sql12.swb.showplan.tablevaluedfunction.f1
- sql12.swb.showplan.split.f1
- sql12.swb.showplan.union.f1
- sql12.swb.showplan.clusteredindexseek.f1
- sql12.swb.showplan.indexspool.f1
- sql12.swb.showplan.indexinsert.f1
- sql12.swb.showplan.clusteredindexscan.f1
- sql12.swb.showplan.buildhash.f1
- sql12.swb.showplan.clusteredindexmerge.f1
- sql12.swb.showplan.sequence.f1
- sql12.swb.showplan.hashmatchroot.f1
- sql12.swb.showplan.columnstoreindexupdate.f1
- sql12.swb.showplan.rightsemijoin.f1
- sql12.swb.showplan.fetchquery.f1
- sql12.swb.showplan.distinct.f1
- sql12.swb.showplan.hashmatch.f1
- sql12.swb.showplan.segment.f1
- sql12.swb.showplan.top.f1
- sql12.swb.showplan.columnstoreindexdelete.f1
- sql12.swb.showplan.gatherstreams.f1
- sql12.swb.showplan.remotedelete.f1
- sql12.swb.showplan.insert.f1
- sql12.swb.showplan.declare.f1
- sql12.swb.showplan.snapshot.f1
- sql12.swb.showplan.assign.f1
- sql12.swb.showplan.intrinsic.f1
- sql12.swb.showplan.mergejoin.f1
- sql12.swb.showplan.concatenation.f1
- sql12.swb.showplan.rowcountspool.f1
- sql12.swb.showplan.parametertablescan.f1
- sql12.swb.showplan.indexscan.f1
- sql12.swb.showplan.while.f1
- sql12.swb.showplan.columnstoreindexinsert.f1
- sql12.swb.showplan.tablemerge.f1
- sql12.swb.showplan.spool.f1
- sql12.swb.showplan.streamaggregate.f1
- sql12.swb.showplan.update.f1
- sql12.swb.showplan.innerjoin.f1
- sql12.swb.showplan.flowdistinct.f1
- sql12.swb.showplan.tableupdate.f1
- sql12.swb.showplan.result.f1
- sql12.swb.showplan.bitmap.f1
- sql12.swb.showplan.remoteindexseek.f1
- sql12.swb.showplan.populationquery.f1
- sql12.swb.showplan.rightouterjoin.f1
- sql12.swb.showplan.columnstoreindexmerge.f1
- sql12.swb.showplan.remotescan.f1
- sql12.swb.showplan.remoteupdate.f1
- sql12.swb.showplan.keyset.f1
- sql12.swb.showplan.collapse.f1
- sql12.swb.showplan.arithmeticexpression.f1
- sql12.swb.showplan.clusteredindexinsert.f1
- sql12.swb.showplan.computescalar
- sql12.swb.showplan.sort.f1
- sql12.swb.showplan.locate.f1
- sql12.swb.showplan.constantscan.f1
- sql12.swb.showplan.computescalar.f1
- sql12.swb.showplan.indexseek.f1
- sql12.swb.showplan.leftsemijoin.f1
- sql12.swb.showplan.leftantisemijoin.f1
- sql12.swb.showplan.fullouterjoin.f1
- sql12.swb.showplan.filter.f1
- sql12.swb.showplan.indexdelete.f1
- sql12.swb.showplan.repartitionstreams.f1
- sql12.swb.showplan.crossjoin.f1
- sql12.swb.showplan.mergeinterval.f1
- sql12.swb.showplan.bookmarklookup.f1
- sql12.swb.showplan.convert.f1
- sql12.swb.showplan.refreshquery.f1
- sql12.swb.showplan.distinctsort.f1
- sql12.swb.showplan.leftouterjoin.f1
- sql12.swb.showplan.rightantisemijoin.f1
- sql12.swb.showplan.deletedscan.f1
- sql12.swb.showplan.udx.f1
- sql12.swb.showplan.broadcast.f1
- sql12.swb.showplan.delete.f1
- sql12.swb.showplan.aggregate.f1
- sql12.swb.showplan.setfunction.f1
- sql12.swb.showplan.switch.f1
- sql12.swb.showplan.remoteindexscan.f1
- sql12.swb.showplan.eagerspool.f1
- sql12.swb.showplan.indexupdate.f1
- sql12.swb.showplan.keylookup.f1
- sql12.swb.showplan.branchrepartition.f1
- sql12.swb.showplan.rank.f1
- sql12.swb.showplan.tablescan.f1
- sql12.swb.showplan.distributestreams.f1
- sql12.swb.showplan.logrowscan.f1
- sql12.swb.showplan.parallelism.f1
- sql12.swb.showplan.bitmapcreate.f1
- sql12.swb.showplan.insertedscan.f1
- sql12.swb.showplan.tabledelete.f1
- sql12.swb.showplan.clusteredindexdelete.f1
- sql12.swb.showplan.remotequery.f1
- sql12.swb.showplan.if.f1
- sql12.swb.showplan.cache.f1
- sql12.swb.showplan.partialaggregate.f1
- sql12.swb.showplan.sql.f1
helpviewer_keywords:
- execution plans [SQL Server], operators
- ActualRows attribute
- reading execution plan output
- ActualRewinds attribute
- ActualEndOfScans attribute
- query tuning [SQL Server]
- mapping operators [SQL Server]
- operators [Database Engine query tuning]
- logical operators [SQL Server], execution plans
- logical operators [SQL Server], listed
- physical operators [SQL Server]
- ActualRebinds attribute
- execution plans [SQL Server], reading output
ms.assetid: e43fd0fe-5ea7-4ffe-8d52-759ef6a7c361
author: rothja
ms.author: jroth
ms.openlocfilehash: bc45a5fa14785294093385e6f90b47a8bdb6dff3
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 08/04/2020
ms.locfileid: "87746842"
---
# <a name="showplan-logical-and-physical-operators-reference"></a><span data-ttu-id="8023e-102">Referencia de operadores lógicos y físicos del plan de presentación</span><span class="sxs-lookup"><span data-stu-id="8023e-102">Showplan Logical and Physical Operators Reference</span></span>
  <span data-ttu-id="8023e-103">Los operadores describen cómo [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] ejecuta una consulta o una instrucción DML (Lenguaje de manipulación de datos).</span><span class="sxs-lookup"><span data-stu-id="8023e-103">Operators describe how [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] executes a query or a Data Manipulation Language (DML) statement.</span></span> <span data-ttu-id="8023e-104">El optimizador de consultas usa operadores para generar un plan de consulta con el fin de crear el resultado especificado en la consulta o para realizar la operación especificada en la instrucción DML.</span><span class="sxs-lookup"><span data-stu-id="8023e-104">The query optimizer uses operators to build a query plan to create the result specified in the query, or to perform the operation specified in the DML statement.</span></span> <span data-ttu-id="8023e-105">El plan de consulta es un árbol que consta de operadores físicos.</span><span class="sxs-lookup"><span data-stu-id="8023e-105">The query plan is a tree consisting of physical operators.</span></span> <span data-ttu-id="8023e-106">Puede ver el plan de consulta mediante las instrucciones SET SHOWPLAN, las opciones gráficas del plan de ejecución de [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)]o las clases de eventos Showplan de SQL Server Profiler.</span><span class="sxs-lookup"><span data-stu-id="8023e-106">You can view the query plan by using the SET SHOWPLAN statements, the graphical execution plan options in [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)], or the SQL Server Profiler Showplan event classes.</span></span>  
  
 <span data-ttu-id="8023e-107">Los operadores se clasifican como lógicos y físicos.</span><span class="sxs-lookup"><span data-stu-id="8023e-107">Operators are classified as logical and physical operators.</span></span>  
  
 <span data-ttu-id="8023e-108">**Operadores lógicos**</span><span class="sxs-lookup"><span data-stu-id="8023e-108">**Logical Operators**</span></span>  
 <span data-ttu-id="8023e-109">Los operadores lógicos describen la operación algebraica relacional usada para procesar una instrucción.</span><span class="sxs-lookup"><span data-stu-id="8023e-109">Logical operators describe the relational algebraic operation used to process a statement.</span></span> <span data-ttu-id="8023e-110">En otras palabras, los operadores lógicos describen conceptualmente la operación que se debe realizar.</span><span class="sxs-lookup"><span data-stu-id="8023e-110">In other words, logical operators describe conceptually what operation needs to be performed.</span></span>  
  
 <span data-ttu-id="8023e-111">**Operadores físicos**</span><span class="sxs-lookup"><span data-stu-id="8023e-111">**Physical Operators**</span></span>  
 <span data-ttu-id="8023e-112">Los operadores físicos implementan la operación descrita por los operadores lógicos.</span><span class="sxs-lookup"><span data-stu-id="8023e-112">Physical operators implement the operation described by logical operators.</span></span> <span data-ttu-id="8023e-113">Cada operador físico es un objeto o rutina que realiza una operación.</span><span class="sxs-lookup"><span data-stu-id="8023e-113">Each physical operator is an object or routine that performs an operation.</span></span> <span data-ttu-id="8023e-114">Por ejemplo, algunos operadores físicos obtienen acceso a columnas o filas desde una tabla, índice o vista.</span><span class="sxs-lookup"><span data-stu-id="8023e-114">For example, some physical operators access columns or rows from a table, index or view.</span></span> <span data-ttu-id="8023e-115">Otros operadores físicos realizan otras operaciones como cálculos, agregaciones, comprobaciones de integridad de datos o combinaciones.</span><span class="sxs-lookup"><span data-stu-id="8023e-115">Other physical operators perform other operations such as calculations, aggregations, data integrity checks or joins.</span></span> <span data-ttu-id="8023e-116">Los operadores físicos tienen costos asociados.</span><span class="sxs-lookup"><span data-stu-id="8023e-116">Physical operators have costs associated with them.</span></span>  
  
 <span data-ttu-id="8023e-117">Los operadores físicos se inicializan, recopilan datos y se cierran.</span><span class="sxs-lookup"><span data-stu-id="8023e-117">The physical operators initialize, collect data, and close.</span></span> <span data-ttu-id="8023e-118">Específicamente, el operador físico puede responder a las llamadas de los tres métodos siguientes:</span><span class="sxs-lookup"><span data-stu-id="8023e-118">Specifically, the physical operator can answer the following three method calls:</span></span>  
  
-   <span data-ttu-id="8023e-119">**Init()** : el método **Init()** hace que un operador físico se inicialice y configure las estructuras de datos necesarias.</span><span class="sxs-lookup"><span data-stu-id="8023e-119">**Init()**: The **Init()** method causes a physical operator to initialize itself and set up any required data structures.</span></span> <span data-ttu-id="8023e-120">El operador físico puede recibir numerosas llamadas **Init()** , aunque suele recibir solo una.</span><span class="sxs-lookup"><span data-stu-id="8023e-120">The physical operator may receive many **Init()** calls, though typically a physical operator receives only one.</span></span>  
  
-   <span data-ttu-id="8023e-121">**GetNext()** : el método **GetNext()** hace que un operador físico obtenga la primera fila de datos o la siguiente.</span><span class="sxs-lookup"><span data-stu-id="8023e-121">**GetNext()**: The **GetNext()** method causes a physical operator to get the first, or subsequent row of data.</span></span> <span data-ttu-id="8023e-122">El operador físico puede recibir ninguna o numerosas llamadas **GetNext()** .</span><span class="sxs-lookup"><span data-stu-id="8023e-122">The physical operator may receive zero or many **GetNext()** calls.</span></span>  
  
-   <span data-ttu-id="8023e-123">**Close()** : el método **Close()** hace que un operador físico realice algunas operaciones de limpieza y se cierre.</span><span class="sxs-lookup"><span data-stu-id="8023e-123">**Close()**: The **Close()** method causes a physical operator to perform some clean-up operations and shut itself down.</span></span> <span data-ttu-id="8023e-124">Un operador físico recibe únicamente una llamada de **Close()** .</span><span class="sxs-lookup"><span data-stu-id="8023e-124">A physical operator only receives one **Close()** call.</span></span>  
  
 <span data-ttu-id="8023e-125">El método **GetNext()** devuelve una fila de datos, mientras que el número de veces que se llama aparece como **ActualRows** en los resultados del plan de presentación generado mediante SET STATISTICS PROFILE ON o SET STATISTICS XML ON.</span><span class="sxs-lookup"><span data-stu-id="8023e-125">The **GetNext()** method returns one row of data, and the number of times it is called appears as **ActualRows** in the Showplan output that is produced by using SET STATISTICS PROFILE ON or SET STATISTICS XML ON.</span></span> <span data-ttu-id="8023e-126">Para obtener más información sobre estas opciones de SET, vea [SET STATISTICS PROFILE &#40;Transact-SQL&#41;](/sql/t-sql/statements/set-statistics-profile-transact-sql) y [SET STATISTICS XML &#40;Transact-SQL&#41;](/sql/t-sql/statements/set-statistics-xml-transact-sql).</span><span class="sxs-lookup"><span data-stu-id="8023e-126">For more information about these SET options, see [SET STATISTICS PROFILE &#40;Transact-SQL&#41;](/sql/t-sql/statements/set-statistics-profile-transact-sql) and [SET STATISTICS XML &#40;Transact-SQL&#41;](/sql/t-sql/statements/set-statistics-xml-transact-sql).</span></span>  
  
 <span data-ttu-id="8023e-127">Los recuentos **ActualRebinds** y **ActualRewinds** que aparecen en los resultados del plan de presentación hacen referencia al número de veces que se llama al método **Init()** .</span><span class="sxs-lookup"><span data-stu-id="8023e-127">The **ActualRebinds** and **ActualRewinds** counts that appear in Showplan output refer to the number of times that the **Init()** method is called.</span></span> <span data-ttu-id="8023e-128">A menos que haya un operador en la parte interna de una combinación de bucles, **ActualRebinds** es igual a uno y **ActualRewinds** es igual a cero.</span><span class="sxs-lookup"><span data-stu-id="8023e-128">Unless an operator is on the inner side of a loop join, **ActualRebinds** equals one and **ActualRewinds** equals zero.</span></span> <span data-ttu-id="8023e-129">Si hay un operador en la parte interna de una combinación de bucles, la suma del número de reenlaces y rebobinados es igual al número de filas procesadas en la parte externa de la combinación.</span><span class="sxs-lookup"><span data-stu-id="8023e-129">If an operator is on the inner side of a loop join, the sum of the number of rebinds and rewinds should equal the number of rows processed on the outer side of the join.</span></span> <span data-ttu-id="8023e-130">Un reenlace significa que uno o más de los parámetros correlativos de la combinación han cambiado y es necesario volver a evaluar la parte interna.</span><span class="sxs-lookup"><span data-stu-id="8023e-130">A rebind means that one or more of the correlated parameters of the join changed and the inner side must be reevaluated.</span></span> <span data-ttu-id="8023e-131">Un rebobinado significa que ninguno de los parámetros correlativos ha cambiado y aún se puede volver a utilizar el conjunto de resultados interno anterior.</span><span class="sxs-lookup"><span data-stu-id="8023e-131">A rewind means that none of the correlated parameters changed and the prior inner result set may be reused.</span></span>  
  
 <span data-ttu-id="8023e-132">**ActualRebinds** y **ActualRewinds** aparecen en los resultados del plan de presentación XML generado mediante SET STATISTICS XML ON.</span><span class="sxs-lookup"><span data-stu-id="8023e-132">**ActualRebinds** and **ActualRewinds** are present in XML Showplan output produced by using SET STATISTICS XML ON.</span></span> <span data-ttu-id="8023e-133">Solo se rellenan para los operadores **Nonclustered Index spool**, `Remote Query` , **Row Count spool**, `Sort` , **TABLE spool**y **función con valores de tabla** .</span><span class="sxs-lookup"><span data-stu-id="8023e-133">They are only populated for the **Nonclustered Index Spool**, `Remote Query`, **Row Count Spool**, `Sort`, **Table Spool**, and **Table-valued Function** operators.</span></span> <span data-ttu-id="8023e-134">**ActualRebinds** y **ActualRewinds** también se pueden rellenar para los `Assert` operadores de **filtro** y cuando el atributo **StartupExpression** está establecido en true.</span><span class="sxs-lookup"><span data-stu-id="8023e-134">**ActualRebinds** and **ActualRewinds** may also be populated for the `Assert` and **Filter** operators when the **StartupExpression** attribute is set to TRUE.</span></span>  
  
 <span data-ttu-id="8023e-135">Cuando **ActualRebinds** y **ActualRewinds** aparecen en un plan de presentación XML, son comparables a **EstimateRebinds** y **EstimateRewinds**.</span><span class="sxs-lookup"><span data-stu-id="8023e-135">When **ActualRebinds** and **ActualRewinds** are present in an XML Showplan, they are comparable to **EstimateRebinds** and **EstimateRewinds**.</span></span> <span data-ttu-id="8023e-136">Si no aparecen, el número estimado de filas (**EstimateRows**) es comparable al número real de filas (**ActualRows**).</span><span class="sxs-lookup"><span data-stu-id="8023e-136">When they are absent, the estimated number of rows (**EstimateRows**) is comparable to the actual number of rows (**ActualRows**).</span></span> <span data-ttu-id="8023e-137">Tenga en cuenta que si no aparecen, los resultados reales del plan de presentación gráfico muestran ceros para los reenlaces y rebobinados reales.</span><span class="sxs-lookup"><span data-stu-id="8023e-137">Note that actual graphical Showplan output displays zeros for the actual rebinds and actual rewinds when they are absent.</span></span>  
  
 <span data-ttu-id="8023e-138">Hay un contador relacionado disponible, **ActualEndOfScans**, únicamente cuando se generan los resultados del plan de presentación mediante SET STATISTICS XML ON.</span><span class="sxs-lookup"><span data-stu-id="8023e-138">A related counter, **ActualEndOfScans**, is available only when Showplan output is produced by using SET STATISTICS XML ON.</span></span> <span data-ttu-id="8023e-139">Siempre que un operador físico alcanza el final de su flujo de datos, este contador se incrementa en uno.</span><span class="sxs-lookup"><span data-stu-id="8023e-139">Whenever a physical operator reaches the end of its data stream, this counter is incremented by one.</span></span> <span data-ttu-id="8023e-140">Un operador físico puede alcanzar el final de su flujo de datos cero, una o varias veces.</span><span class="sxs-lookup"><span data-stu-id="8023e-140">A physical operator can reach the end of its data stream zero, one, or multiple times.</span></span> <span data-ttu-id="8023e-141">Al igual que los reenlaces y rebobinados, el número de finales de recorrido puede ser superior a uno únicamente si el operador se encuentra en la parte interna de una combinación de bucles.</span><span class="sxs-lookup"><span data-stu-id="8023e-141">As with rebinds and rewinds, the number of end of scans can be more than one only if the operator is on the inner side of a loop join.</span></span> <span data-ttu-id="8023e-142">El número de finales de recorrido debería ser inferior o igual a la suma del número de reenlaces y rebobinados.</span><span class="sxs-lookup"><span data-stu-id="8023e-142">The number of end of scans should be less than or equal to the sum of the number of rebinds and rewinds.</span></span>  
  
## <a name="mapping-physical-and-logical-operators"></a><span data-ttu-id="8023e-143">Asignar operadores físicos y lógicos</span><span class="sxs-lookup"><span data-stu-id="8023e-143">Mapping Physical and Logical Operators</span></span>  
 <span data-ttu-id="8023e-144">El optimizador de consultas crea un plan de consulta con forma de árbol que consta de operadores lógicos.</span><span class="sxs-lookup"><span data-stu-id="8023e-144">The query optimizer creates a query plan as a tree consisting of logical operators.</span></span> <span data-ttu-id="8023e-145">Una vez que el optimizador de consultas ha creado el plan, elige el operador físico más eficaz para cada operador lógico.</span><span class="sxs-lookup"><span data-stu-id="8023e-145">After the query optimizer creates the plan, the query optimizer chooses the most efficient physical operator for each logical operator.</span></span> <span data-ttu-id="8023e-146">El optimizador de consultas utiliza un método basado en el costo para determinar el operador físico que implementará un operador lógico.</span><span class="sxs-lookup"><span data-stu-id="8023e-146">The query optimizer uses a cost-based approach to determine which physical operator will implement a logical operator.</span></span>  
  
 <span data-ttu-id="8023e-147">Normalmente, varios operadores físicos pueden implementar una operación lógica.</span><span class="sxs-lookup"><span data-stu-id="8023e-147">Usually, a logical operation can be implemented by multiple physical operators.</span></span> <span data-ttu-id="8023e-148">Sin embargo, en pocas ocasiones un operador físico puede implementar varias operaciones lógicas también.</span><span class="sxs-lookup"><span data-stu-id="8023e-148">However, in rare cases, a physical operator can implement multiple logical operations as well.</span></span>  
  
## <a name="operator-descriptions"></a><span data-ttu-id="8023e-149">Descripción del operador</span><span class="sxs-lookup"><span data-stu-id="8023e-149">Operator Descriptions</span></span>  
 <span data-ttu-id="8023e-150">Esta sección contiene las descripciones de los operadores lógicos y físicos.</span><span class="sxs-lookup"><span data-stu-id="8023e-150">This section contains descriptions of the logical and physical operators.</span></span>  
  
|<span data-ttu-id="8023e-151">Icono del plan de ejecución gráfico</span><span class="sxs-lookup"><span data-stu-id="8023e-151">Graphical Execution Plan Icon</span></span>|<span data-ttu-id="8023e-152">Operador de plan de presentación</span><span class="sxs-lookup"><span data-stu-id="8023e-152">Showplan Operator</span></span>|<span data-ttu-id="8023e-153">Descripción</span><span class="sxs-lookup"><span data-stu-id="8023e-153">Description</span></span>|  
|-----------------------------------|-----------------------|-----------------|  
|<span data-ttu-id="8023e-154">None</span><span class="sxs-lookup"><span data-stu-id="8023e-154">None</span></span>|`Aggregate`|<span data-ttu-id="8023e-155">El operador `Aggregate` calcula una expresión que contiene MIN, MAX, SUM, COUNT o AVG.</span><span class="sxs-lookup"><span data-stu-id="8023e-155">The `Aggregate` operator calculates an expression containing MIN, MAX, SUM, COUNT or AVG.</span></span> <span data-ttu-id="8023e-156">El operador `Aggregate` puede ser un operador lógico o físico.</span><span class="sxs-lookup"><span data-stu-id="8023e-156">The `Aggregate` operator can be a logical operator or a physical operator.</span></span>|  
|<span data-ttu-id="8023e-157">![Icono del operador de expresión aritmética](../../2014/database-engine/media/arithmetic-expression-32x-2.gif "Icono del operador de expresión aritmética")</span><span class="sxs-lookup"><span data-stu-id="8023e-157">![Arithmetic expression operator icon](../../2014/database-engine/media/arithmetic-expression-32x-2.gif "Arithmetic expression operator icon")</span></span>|`Arithmetic Expression`|<span data-ttu-id="8023e-158">El operador `Arithmetic Expression` calcula un nuevo valor a partir de los valores de una fila.</span><span class="sxs-lookup"><span data-stu-id="8023e-158">The `Arithmetic Expression` operator computes a new value from existing values in a row.</span></span> <span data-ttu-id="8023e-159">`Arithmetic Expression` no se usa en [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].</span><span class="sxs-lookup"><span data-stu-id="8023e-159">`Arithmetic Expression` is not used in [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].</span></span>|  
|<span data-ttu-id="8023e-160">![Icono del operador Assert](../../2014/database-engine/media/assert-32x.gif "Icono del operador Assert")</span><span class="sxs-lookup"><span data-stu-id="8023e-160">![Assert operator icon](../../2014/database-engine/media/assert-32x.gif "Assert operator icon")</span></span>|`Assert`|<span data-ttu-id="8023e-161">El operador `Assert` comprueba una condición.</span><span class="sxs-lookup"><span data-stu-id="8023e-161">The `Assert` operator verifies a condition.</span></span> <span data-ttu-id="8023e-162">Por ejemplo, valida la integridad referencial o se asegura de que una subconsulta escalar devuelve una fila.</span><span class="sxs-lookup"><span data-stu-id="8023e-162">For example, it validates referential integrity or ensures that a scalar subquery returns one row.</span></span> <span data-ttu-id="8023e-163">Para cada fila de entrada, el `Assert` operador evalúa la expresión en la `Argument` columna del plan de ejecución.</span><span class="sxs-lookup"><span data-stu-id="8023e-163">For each input row, the `Assert` operator evaluates the expression in the `Argument` column of the execution plan.</span></span> <span data-ttu-id="8023e-164">Si la expresión da como resultado NULL, la fila se pasa a través del operador `Assert` y continúa la ejecución de la consulta.</span><span class="sxs-lookup"><span data-stu-id="8023e-164">If this expression evaluates to NULL, the row is passed through the `Assert` operator and the query execution continues.</span></span> <span data-ttu-id="8023e-165">Si la expresión da como resultado un valor distinto a NULL, se generará el error apropiado.</span><span class="sxs-lookup"><span data-stu-id="8023e-165">If this expression evaluates to a nonnull value, the appropriate error will be raised.</span></span> <span data-ttu-id="8023e-166">El `Assert` operador es un operador físico.</span><span class="sxs-lookup"><span data-stu-id="8023e-166">The `Assert` operator is a physical operator.</span></span>|  
|<span data-ttu-id="8023e-167">![Icono del elemento del lenguaje Assign](../../2014/database-engine/media/assign-32.gif "Icono del elemento del lenguaje Assign")</span><span class="sxs-lookup"><span data-stu-id="8023e-167">![Assign language element icon](../../2014/database-engine/media/assign-32.gif "Assign language element icon")</span></span>|`Assign`|<span data-ttu-id="8023e-168">El operador `Assign` asigna el valor de una expresión o una constante a una variable.</span><span class="sxs-lookup"><span data-stu-id="8023e-168">The `Assign` operator assigns the value of an expression or a constant to a variable.</span></span> <span data-ttu-id="8023e-169">`Assign` es un elemento del lenguaje.</span><span class="sxs-lookup"><span data-stu-id="8023e-169">`Assign` is a language element.</span></span>|  
|<span data-ttu-id="8023e-170">None</span><span class="sxs-lookup"><span data-stu-id="8023e-170">None</span></span>|`Asnyc Concat`|<span data-ttu-id="8023e-171">El operador `Asnyc Concat` solo se usa en consultas remotas (consultas distribuidas).</span><span class="sxs-lookup"><span data-stu-id="8023e-171">The `Asnyc Concat` operator is used only in remote queries (distributed queries).</span></span> <span data-ttu-id="8023e-172">Tiene *n* nodos secundarios y un nodo primario.</span><span class="sxs-lookup"><span data-stu-id="8023e-172">It has *n* children and one parent node.</span></span> <span data-ttu-id="8023e-173">Algunos de los nodos secundarios suelen ser equipos remotos que participan en una consulta distribuida.</span><span class="sxs-lookup"><span data-stu-id="8023e-173">Usually, some of the children are remote computers that participate in a distributed query.</span></span> <span data-ttu-id="8023e-174">`Asnyc Concat` emite llamadas `open()` a todos los nodos secundarios a la vez y, a continuación, asigna un mapa de bits a cada uno de estos nodos.</span><span class="sxs-lookup"><span data-stu-id="8023e-174">`Asnyc Concat` issues `open()` calls to all of the children simultaneously and then applies a bitmap to each child.</span></span> <span data-ttu-id="8023e-175">Por cada bit que sea un 1, `Async Concat` envía las filas de salida a petición al nodo primario.</span><span class="sxs-lookup"><span data-stu-id="8023e-175">For each bit that is a 1, `Async Concat` sends the output rows to the parent node on demand.</span></span>|  
|<span data-ttu-id="8023e-176">![Icono del operador Bitmap](../../2014/database-engine/media/bitmap-32x.gif "Icono del operador Bitmap")</span><span class="sxs-lookup"><span data-stu-id="8023e-176">![Bitmap operator icon](../../2014/database-engine/media/bitmap-32x.gif "Bitmap operator icon")</span></span>|`Bitmap`|[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]<span data-ttu-id="8023e-177">utiliza el `Bitmap` operador para implementar el filtrado de mapas de bits en planes de consulta paralelos.</span><span class="sxs-lookup"><span data-stu-id="8023e-177">uses the `Bitmap` operator to implement bitmap filtering in parallel query plans.</span></span> <span data-ttu-id="8023e-178">El filtrado de mapas de bits agiliza la ejecución de la consulta al eliminar las filas con valores de clave que no pueden generar ningún registro de combinación antes de pasar las filas a través de otro operador, como el `Parallelism` operador.</span><span class="sxs-lookup"><span data-stu-id="8023e-178">Bitmap filtering speeds up query execution by eliminating rows with key values that cannot produce any join records before passing rows through another operator such as the `Parallelism` operator.</span></span> <span data-ttu-id="8023e-179">Un filtro de mapas de bits usa una representación compacta de un conjunto de valores de una tabla en una parte del árbol de operadores para filtrar filas de una segunda tabla en otra parte del árbol.</span><span class="sxs-lookup"><span data-stu-id="8023e-179">A bitmap filter uses a compact representation of a set of values from a table in one part of the operator tree to filter rows from a second table in another part of the tree.</span></span> <span data-ttu-id="8023e-180">Si se quitan las filas innecesarias de la consulta en una fase temprana, los operadores subsiguientes tienen menos filas con las que trabajar y el rendimiento global de la consulta mejora.</span><span class="sxs-lookup"><span data-stu-id="8023e-180">By removing unnecessary rows early in the query, subsequent operators have fewer rows to work with, and the overall performance of the query improves.</span></span> <span data-ttu-id="8023e-181">El optimizador determina cuando un mapa de bits es suficientemente selectivo para resultar útil y en qué operadores se aplica el filtro.</span><span class="sxs-lookup"><span data-stu-id="8023e-181">The optimizer determines when a bitmap is selective enough to be useful and in which operators to apply the filter.</span></span> <span data-ttu-id="8023e-182">`Bitmap` es un operador físico.</span><span class="sxs-lookup"><span data-stu-id="8023e-182">`Bitmap` is a physical operator.</span></span>|  
|<span data-ttu-id="8023e-183">![Icono del operador Bitmap](../../2014/database-engine/media/bitmap-32x.gif "Icono del operador Bitmap")</span><span class="sxs-lookup"><span data-stu-id="8023e-183">![Bitmap operator icon](../../2014/database-engine/media/bitmap-32x.gif "Bitmap operator icon")</span></span>|`Bitmap Create`|<span data-ttu-id="8023e-184">El operador `Bitmap Create` aparece en el resultado del plan de presentación en la que se generan los mapas de bits.</span><span class="sxs-lookup"><span data-stu-id="8023e-184">The `Bitmap Create` operator appears in the Showplan output where bitmaps are built.</span></span> <span data-ttu-id="8023e-185">`Bitmap Create` es un operador lógico.</span><span class="sxs-lookup"><span data-stu-id="8023e-185">`Bitmap Create` is a logical operator.</span></span>|  
|<span data-ttu-id="8023e-186">![Icono del operador Bookmark Lookup](../../2014/database-engine/media/bookmark-lookup-32x.gif "Icono del operador Bookmark Lookup")</span><span class="sxs-lookup"><span data-stu-id="8023e-186">![Bookmark lookup operator icon](../../2014/database-engine/media/bookmark-lookup-32x.gif "Bookmark lookup operator icon")</span></span>|`Bookmark Lookup`|<span data-ttu-id="8023e-187">El operador `Bookmark Lookup` usa un marcador (identificador de fila o clave de agrupación en clústeres) para buscar la fila correspondiente en la tabla o índice clúster.</span><span class="sxs-lookup"><span data-stu-id="8023e-187">The `Bookmark Lookup` operator uses a bookmark (row ID or clustering key) to look up the corresponding row in the table or clustered index.</span></span> <span data-ttu-id="8023e-188">La `Argument` columna contiene la etiqueta de marcador utilizada para buscar la fila en la tabla o el índice clúster.</span><span class="sxs-lookup"><span data-stu-id="8023e-188">The `Argument` column contains the bookmark label used to look up the row in the table or clustered index.</span></span> <span data-ttu-id="8023e-189">La `Argument` columna también contiene el nombre de la tabla o el índice clúster en el que se busca la fila.</span><span class="sxs-lookup"><span data-stu-id="8023e-189">The `Argument` column also contains the name of the table or clustered index in which the row is looked up.</span></span> <span data-ttu-id="8023e-190">Si la cláusula WITH Prefetch aparece en la `Argument` columna, el procesador de consultas ha determinado que es óptimo usar la captura previa asincrónica (lectura anticipada) al buscar marcadores en la tabla o el índice clúster.</span><span class="sxs-lookup"><span data-stu-id="8023e-190">If the WITH PREFETCH clause appears in the `Argument` column, the query processor has determined that it is optimal to use asynchronous prefetching (read-ahead) when looking up bookmarks in the table or clustered index.</span></span><br /><br /> <span data-ttu-id="8023e-191">`Bookmark Lookup` no se usa en [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].</span><span class="sxs-lookup"><span data-stu-id="8023e-191">`Bookmark Lookup` is not used in [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].</span></span> <span data-ttu-id="8023e-192">En su lugar, `Clustered Index Seek` y `RID Lookup` proporcionan la funcionalidad de búsqueda de marcadores.</span><span class="sxs-lookup"><span data-stu-id="8023e-192">Instead, `Clustered Index Seek` and `RID Lookup` provide bookmark lookup functionality.</span></span> <span data-ttu-id="8023e-193">El operador `Key Lookup` también proporciona esta funcionalidad.</span><span class="sxs-lookup"><span data-stu-id="8023e-193">The `Key Lookup` operator also provides this functionality.</span></span>|  
|<span data-ttu-id="8023e-194">None</span><span class="sxs-lookup"><span data-stu-id="8023e-194">None</span></span>|`Branch Repartition`|<span data-ttu-id="8023e-195">En un plan de consulta paralelo, a veces hay regiones conceptuales de iteradores.</span><span class="sxs-lookup"><span data-stu-id="8023e-195">In a parallel query plan, sometimes there are conceptual regions of iterators.</span></span> <span data-ttu-id="8023e-196">Todos los iteradores de una región así se pueden ejecutar mediante subprocesos paralelos.</span><span class="sxs-lookup"><span data-stu-id="8023e-196">All of the iterators within such a region can be executed by parallel threads.</span></span> <span data-ttu-id="8023e-197">Las regiones en sí deben ejecutarse en serie.</span><span class="sxs-lookup"><span data-stu-id="8023e-197">The regions themselves must be executed serially.</span></span> <span data-ttu-id="8023e-198">Algunos de los iteradores `Parallelism` de una región individual se denominan `Branch Repartition`.</span><span class="sxs-lookup"><span data-stu-id="8023e-198">Some of the `Parallelism` iterators within an individual region are called `Branch Repartition`.</span></span> <span data-ttu-id="8023e-199">El iterador `Parallelism` situado en el límite de dos de estas regiones se denomina `Segment Repartition`.</span><span class="sxs-lookup"><span data-stu-id="8023e-199">The `Parallelism` iterator at the boundary of two such regions is called `Segment Repartition`.</span></span> <span data-ttu-id="8023e-200">`Branch Repartition` y `Segment Repartition` son operadores lógicos.</span><span class="sxs-lookup"><span data-stu-id="8023e-200">`Branch Repartition` and `Segment Repartition` are logical operators.</span></span>|  
|<span data-ttu-id="8023e-201">None</span><span class="sxs-lookup"><span data-stu-id="8023e-201">None</span></span>|`Broadcast`|<span data-ttu-id="8023e-202">`Broadcast`tiene un nodo secundario y *n* nodos primarios.</span><span class="sxs-lookup"><span data-stu-id="8023e-202">`Broadcast` has one child node and *n* parent nodes.</span></span> <span data-ttu-id="8023e-203">`Broadcast` envía las filas de entrada a varios consumidores a petición.</span><span class="sxs-lookup"><span data-stu-id="8023e-203">`Broadcast` sends its input rows to multiple consumers on demand.</span></span> <span data-ttu-id="8023e-204">Cada consumidor recibe todas las filas.</span><span class="sxs-lookup"><span data-stu-id="8023e-204">Each consumer gets all of the rows.</span></span> <span data-ttu-id="8023e-205">Por ejemplo, si todos los consumidores son lados de creación de una combinación hash, se crearán *n* copias de las tablas hash.</span><span class="sxs-lookup"><span data-stu-id="8023e-205">For example, if all of the consumers are build sides of a hash join, then *n* copies of the hash tables will be built.</span></span>|  
|<span data-ttu-id="8023e-206">![Icono del operador Build Hash](../../2014/database-engine/media/build-hash.gif "Icono del operador Build Hash")</span><span class="sxs-lookup"><span data-stu-id="8023e-206">![Build hash operator icon](../../2014/database-engine/media/build-hash.gif "Build hash operator icon")</span></span>|`Build Hash`|<span data-ttu-id="8023e-207">Indica la compilación de una tabla hash del lote para un índice optimizado memoria de columnstore de xVelocity.</span><span class="sxs-lookup"><span data-stu-id="8023e-207">Indicates the build of a batch hash table for an xVelocity memory optimized columnstore index.</span></span>|  
|<span data-ttu-id="8023e-208">None</span><span class="sxs-lookup"><span data-stu-id="8023e-208">None</span></span>|`Cache`|<span data-ttu-id="8023e-209">`Cache`es una versión especializada del operador **spool** .</span><span class="sxs-lookup"><span data-stu-id="8023e-209">`Cache` is a specialized version of the **Spool** operator.</span></span> <span data-ttu-id="8023e-210">Almacena solo una fila de datos.</span><span class="sxs-lookup"><span data-stu-id="8023e-210">It stores only one row of data.</span></span> <span data-ttu-id="8023e-211">`Cache` es un operador lógico.</span><span class="sxs-lookup"><span data-stu-id="8023e-211">`Cache` is a logical operator.</span></span> <span data-ttu-id="8023e-212">`Cache` no se usa en [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].</span><span class="sxs-lookup"><span data-stu-id="8023e-212">`Cache` is not used in [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].</span></span>|  
|<span data-ttu-id="8023e-213">![Icono del operador Clustered Index Delete](../../2014/database-engine/media/clustered-index-delete-32x.gif "Icono del operador Clustered Index Delete")</span><span class="sxs-lookup"><span data-stu-id="8023e-213">![Clustered index delete operator icon](../../2014/database-engine/media/clustered-index-delete-32x.gif "Clustered index delete operator icon")</span></span>|`Clustered Index Delete`|<span data-ttu-id="8023e-214">El operador `Clustered Index Delete` elimina filas del índice clúster especificado en la columna Argument del plan de ejecución de consulta.</span><span class="sxs-lookup"><span data-stu-id="8023e-214">The `Clustered Index Delete` operator deletes rows from the clustered index specified in the Argument column of the query execution plan.</span></span> <span data-ttu-id="8023e-215">Si hay un predicado WHERE:() en la columna Argument, solo se eliminan las filas que cumplen el predicado.`Clustered Index Delete`</span><span class="sxs-lookup"><span data-stu-id="8023e-215">If a WHERE:() predicate is present in the Argument column, then only those rows that satisfy the predicate are deleted.`Clustered Index Delete`</span></span> <span data-ttu-id="8023e-216"> es un operador físico.</span><span class="sxs-lookup"><span data-stu-id="8023e-216">is a physical operator.</span></span>|  
|<span data-ttu-id="8023e-217">![Icono del operador Clustered Index Insert](../../2014/database-engine/media/clustered-index-insert-32x.gif "Icono del operador Clustered Index Insert")</span><span class="sxs-lookup"><span data-stu-id="8023e-217">![Clustered index insert operator icon](../../2014/database-engine/media/clustered-index-insert-32x.gif "Clustered index insert operator icon")</span></span>|`Clustered Index Insert`|<span data-ttu-id="8023e-218">El operador de Showplan `Clustered Index Insert` inserta filas desde su entrada en el índice clúster especificado en la columna Argument.</span><span class="sxs-lookup"><span data-stu-id="8023e-218">The `Clustered Index Insert` Showplan operator inserts rows from its input into the clustered index specified in the Argument column.</span></span> <span data-ttu-id="8023e-219">La columna Argument también contiene un predicado SET:(), que indica el valor en el que se establece cada columna.</span><span class="sxs-lookup"><span data-stu-id="8023e-219">The Argument column also contains a SET:() predicate, which indicates the value to which each column is set.</span></span> <span data-ttu-id="8023e-220">Si `Clustered Index Insert` no tiene elementos secundarios para los valores de inserción, la fila insertada se toma del `Insert` propio operador.`Clustered Index Insert`</span><span class="sxs-lookup"><span data-stu-id="8023e-220">If `Clustered Index Insert` has no children for insert values, the row inserted is taken from the `Insert` operator itself.`Clustered Index Insert`</span></span> <span data-ttu-id="8023e-221"> es un operador físico.</span><span class="sxs-lookup"><span data-stu-id="8023e-221">is a physical operator.</span></span>|  
|<span data-ttu-id="8023e-222">![Operador Clustered Index Merge](../../2014/database-engine/media/clustered-index-merge-32x.gif "Operador Clustered Index Merge")</span><span class="sxs-lookup"><span data-stu-id="8023e-222">![Clustered index merge operator](../../2014/database-engine/media/clustered-index-merge-32x.gif "Clustered index merge operator")</span></span>|<span data-ttu-id="8023e-223">**Clustered Index Merge**</span><span class="sxs-lookup"><span data-stu-id="8023e-223">**Clustered Index Merge**</span></span>|<span data-ttu-id="8023e-224">El operador **Clustered Index Merge** aplica un flujo de datos de mezcla a un índice clúster.</span><span class="sxs-lookup"><span data-stu-id="8023e-224">The **Clustered Index Merge** operator applies a merge data stream to a clustered index.</span></span> <span data-ttu-id="8023e-225">El operador elimina, actualiza o inserta filas del índice clúster especificado en la `Argument` columna del operador.</span><span class="sxs-lookup"><span data-stu-id="8023e-225">The operator deletes, updates, or inserts rows from the clustered index specified in the `Argument` column of the operator.</span></span> <span data-ttu-id="8023e-226">La operación real realizada depende del valor en tiempo de ejecución de la columna **Action** especificada en la `Argument` columna del operador.</span><span class="sxs-lookup"><span data-stu-id="8023e-226">The actual operation performed depends on the runtime value of the **ACTION** column specified in the `Argument` column of the operator.</span></span> <span data-ttu-id="8023e-227">**Clustered Index Merge** es un operador físico.</span><span class="sxs-lookup"><span data-stu-id="8023e-227">**Clustered Index Merge** is a physical operator.</span></span>|  
|<span data-ttu-id="8023e-228">![Icono del operador Clustered Index Scan](../../2014/database-engine/media/clustered-index-scan-32x.gif "Icono del operador Clustered Index Scan")</span><span class="sxs-lookup"><span data-stu-id="8023e-228">![Clustered index scan operator icon](../../2014/database-engine/media/clustered-index-scan-32x.gif "Clustered index scan operator icon")</span></span>|`Clustered Index Scan`|<span data-ttu-id="8023e-229">El operador `Clustered Index Scan` examina el índice clúster especificado en la columna Argument del plan de ejecución de consulta.</span><span class="sxs-lookup"><span data-stu-id="8023e-229">The `Clustered Index Scan` operator scans the clustered index specified in the Argument column of the query execution plan.</span></span> <span data-ttu-id="8023e-230">Si hay un predicado WHERE:() opcional, solo se devuelven las filas que lo cumplen.</span><span class="sxs-lookup"><span data-stu-id="8023e-230">When an optional WHERE:() predicate is present, only those rows that satisfy the predicate are returned.</span></span> <span data-ttu-id="8023e-231">Si la columna Argument contiene la cláusula ORDERED, el procesador de consultas ha solicitado que la salida de las filas se devuelva en el orden en que las haya ordenado el índice clúster.</span><span class="sxs-lookup"><span data-stu-id="8023e-231">If the Argument column contains the ORDERED clause, the query processor has requested that the output of the rows be returned in the order in which the clustered index has sorted it.</span></span> <span data-ttu-id="8023e-232">Si no hay una cláusula ORDERED, el motor de almacenamiento recorre el índice de la forma óptima (sin tener que ordenar el resultado).</span><span class="sxs-lookup"><span data-stu-id="8023e-232">If the ORDERED clause is not present, the storage engine scans the index in the optimal way, without necessarily sorting the output.</span></span> <span data-ttu-id="8023e-233">`Clustered Index Scan` es un operador lógico y físico.</span><span class="sxs-lookup"><span data-stu-id="8023e-233">`Clustered Index Scan` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="8023e-234">![Icono del operador Clustered Index Seek](../../2014/database-engine/media/clustered-index-seek-32x.gif "Icono del operador Clustered Index Seek")</span><span class="sxs-lookup"><span data-stu-id="8023e-234">![Clustered index seek operator icon](../../2014/database-engine/media/clustered-index-seek-32x.gif "Clustered index seek operator icon")</span></span>|`Clustered Index Seek`|<span data-ttu-id="8023e-235">El operador `Clustered Index Seek` utiliza la capacidad de búsqueda de los índices para recuperar filas de un índice clúster.</span><span class="sxs-lookup"><span data-stu-id="8023e-235">The `Clustered Index Seek` operator uses the seeking ability of indexes to retrieve rows from a clustered index.</span></span> <span data-ttu-id="8023e-236">La `Argument` columna contiene el nombre del índice clúster que se está usando y el predicado Seek:().</span><span class="sxs-lookup"><span data-stu-id="8023e-236">The `Argument` column contains the name of the clustered index being used and the SEEK:() predicate.</span></span> <span data-ttu-id="8023e-237">El motor de almacenamiento utiliza el índice para procesar solamente las filas que cumplen el predicado SEEK:().</span><span class="sxs-lookup"><span data-stu-id="8023e-237">The storage engine uses the index to process only those rows that satisfy this SEEK:() predicate.</span></span> <span data-ttu-id="8023e-238">También puede incluir un predicado WHERE:() en el que el motor de almacenamiento determine todas las filas que cumplan el predicado SEEK:(), aunque este predicado es opcional y no utiliza índices para completar el proceso.</span><span class="sxs-lookup"><span data-stu-id="8023e-238">It can also include a WHERE:() predicate where the storage engine evaluates against all rows that satisfy the SEEK:() predicate, but this is optional and does not use indexes to complete this process.</span></span><br /><br /> <span data-ttu-id="8023e-239">Si la `Argument` columna contiene la cláusula ordered, el procesador de consultas ha determinado que las filas deben devolverse en el orden en el que el índice clúster las haya clasificado.</span><span class="sxs-lookup"><span data-stu-id="8023e-239">If the `Argument` column contains the ORDERED clause, the query processor has determined that the rows must be returned in the order in which the clustered index has sorted them.</span></span> <span data-ttu-id="8023e-240">Si no hay una cláusula ORDERED, el motor de almacenamiento busca el índice de la forma óptima (sin tener que ordenar el resultado).</span><span class="sxs-lookup"><span data-stu-id="8023e-240">If the ORDERED clause is not present, the storage engine searches the index in the optimal way, without necessarily sorting the output.</span></span> <span data-ttu-id="8023e-241">Permitir que el resultado conserve su ordenación puede ser menos eficiente que generar un resultado no ordenado.</span><span class="sxs-lookup"><span data-stu-id="8023e-241">Allowing the output to retain its ordering can be less efficient than producing nonsorted output.</span></span> <span data-ttu-id="8023e-242">Si aparece la palabra clave LOOKUP, significa que se está realizando una búsqueda de marcadores.</span><span class="sxs-lookup"><span data-stu-id="8023e-242">When the keyword LOOKUP appears, then a bookmark lookup is being performed.</span></span> <span data-ttu-id="8023e-243">En [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] y versiones posteriores, el `Key Lookup` operador proporciona la funcionalidad de búsqueda de marcadores.</span><span class="sxs-lookup"><span data-stu-id="8023e-243">In [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] and later versions, the `Key Lookup` operator provides bookmark lookup functionality.</span></span> <span data-ttu-id="8023e-244">`Clustered Index Seek` es un operador lógico y físico.</span><span class="sxs-lookup"><span data-stu-id="8023e-244">`Clustered Index Seek` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="8023e-245">![Icono del operador Clustered Index Update](../../2014/database-engine/media/clustered-index-update-32x.gif "Icono del operador Clustered Index Update")</span><span class="sxs-lookup"><span data-stu-id="8023e-245">![Clustered index update operator icon](../../2014/database-engine/media/clustered-index-update-32x.gif "Clustered index update operator icon")</span></span>|`Clustered Index Update`|<span data-ttu-id="8023e-246">El `Clustered Index Update` operador actualiza las filas de entrada en el índice clúster especificado en la `Argument` columna. Si hay un predicado WHERE:(), solo se actualizan las filas que cumplen este predicado.</span><span class="sxs-lookup"><span data-stu-id="8023e-246">The `Clustered Index Update` operator updates input rows in the clustered index specified in the `Argument` column.If a WHERE:() predicate is present, only those rows that satisfy this predicate are updated.</span></span> <span data-ttu-id="8023e-247">Si hay un predicado SET:(), se asigna este valor a todas las filas actualizadas.</span><span class="sxs-lookup"><span data-stu-id="8023e-247">If a SET:() predicate is present, each updated column is set to this value.</span></span> <span data-ttu-id="8023e-248">Si hay un predicado DEFINE:(), se muestran los valores que define este operador.</span><span class="sxs-lookup"><span data-stu-id="8023e-248">If a DEFINE:() predicate is present, the values that this operator defines are listed.</span></span> <span data-ttu-id="8023e-249">Se puede hacer referencia a estos valores en la cláusula SET o en cualquier parte del operador, y en cualquier parte de esta consulta.</span><span class="sxs-lookup"><span data-stu-id="8023e-249">These values may be referenced in the SET clause or elsewhere within this operator and elsewhere within this query.</span></span> <span data-ttu-id="8023e-250">`Clustered Index Update` es un operador lógico y físico.</span><span class="sxs-lookup"><span data-stu-id="8023e-250">`Clustered Index Update` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="8023e-251">![Icono del operador Collapse](../../2014/database-engine/media/collapse-32x.gif "Icono del operador Collapse")</span><span class="sxs-lookup"><span data-stu-id="8023e-251">![Collapse operator icon](../../2014/database-engine/media/collapse-32x.gif "Collapse operator icon")</span></span>|`Collapse`|<span data-ttu-id="8023e-252">El operador `Collapse` optimiza el proceso de actualización.</span><span class="sxs-lookup"><span data-stu-id="8023e-252">The `Collapse` operator optimizes update processing.</span></span> <span data-ttu-id="8023e-253">Cuando se realiza una actualización, esta se puede dividir (con el operador `Split`) en una eliminación y una inserción.</span><span class="sxs-lookup"><span data-stu-id="8023e-253">When an update is performed, it can be split (using the `Split` operator) into a delete and an insert.</span></span> <span data-ttu-id="8023e-254">La `Argument` columna contiene una cláusula Group by:() que especifica una lista de columnas de clave.</span><span class="sxs-lookup"><span data-stu-id="8023e-254">The `Argument` column contains a GROUP BY:() clause that specifies a list of key columns.</span></span> <span data-ttu-id="8023e-255">Si el procesador de consultas encuentra filas adyacentes que eliminan e insertan los mismos valores clave, reemplazará estas operaciones independientes por una única operación de actualización más eficaz.</span><span class="sxs-lookup"><span data-stu-id="8023e-255">If the query processor encounters adjacent rows that delete and insert the same key values, it replaces these separate operations with a single more efficient update operation.</span></span> <span data-ttu-id="8023e-256">`Collapse` es un operador lógico y físico.</span><span class="sxs-lookup"><span data-stu-id="8023e-256">`Collapse` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="8023e-257">![Exploración de índice de almacén de columnas](../../2014/database-engine/media/columnstoreindexscan.gif "Exploración de índice de almacén de columnas")</span><span class="sxs-lookup"><span data-stu-id="8023e-257">![Columnstore Index Scan](../../2014/database-engine/media/columnstoreindexscan.gif "Columnstore Index Scan")</span></span>|`Columnstore Index Scan`|<span data-ttu-id="8023e-258">El `Columnstore Index Scan` operador recorre el índice de almacén de columnas especificado en la `Argument` columna del plan de ejecución de la consulta.</span><span class="sxs-lookup"><span data-stu-id="8023e-258">The `Columnstore Index Scan` operator scans the columnstore index specified in the `Argument` column of the query execution plan.</span></span>|  
|<span data-ttu-id="8023e-259">![Icono del operador Compute Scalar](../../2014/database-engine/media/compute-scalar-32x.gif "Icono del operador Compute Scalar")</span><span class="sxs-lookup"><span data-stu-id="8023e-259">![Compute scalar operator icon](../../2014/database-engine/media/compute-scalar-32x.gif "Compute scalar operator icon")</span></span>|`Compute Scalar`|<span data-ttu-id="8023e-260">El `Compute Scalar` operador evalúa una expresión para generar un valor escalar calculado.</span><span class="sxs-lookup"><span data-stu-id="8023e-260">The `Compute Scalar` operator evaluates an expression to produce a computed scalar value.</span></span> <span data-ttu-id="8023e-261">que se puede devolver al usuario, hacer referencia a él en cualquier otra parte de la consulta, o ambas cosas a la vez, por ejemplo,</span><span class="sxs-lookup"><span data-stu-id="8023e-261">This may then be returned to the user, referenced elsewhere in the query, or both.</span></span> <span data-ttu-id="8023e-262">en un predicado de filtro o de combinación.</span><span class="sxs-lookup"><span data-stu-id="8023e-262">An example of both is in a filter predicate or join predicate.</span></span> <span data-ttu-id="8023e-263">`Compute Scalar` es un operador lógico y físico.</span><span class="sxs-lookup"><span data-stu-id="8023e-263">`Compute Scalar` is a logical and physical operator.</span></span><br /><br /> <span data-ttu-id="8023e-264">`Compute Scalar`es posible que los operadores que aparecen en planes generados por SET STATISTICs XML no contengan el `RunTimeInformation` elemento.</span><span class="sxs-lookup"><span data-stu-id="8023e-264">`Compute Scalar` operators that appear in Showplans generated by SET STATISTICS XML might not contain the `RunTimeInformation` element.</span></span> <span data-ttu-id="8023e-265">En planes de presentación gráficos, es posible que las opciones **Número de filas real**, **Reenlaces reales**y **Rebobinados reales** no aparezcan en la ventana **Propiedades** cuando la opción **Incluir plan de ejecucion real** está seleccionada en [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)].</span><span class="sxs-lookup"><span data-stu-id="8023e-265">In graphical Showplans, **Actual Rows**, **Actual Rebinds**, and **Actual Rewinds** might be absent from the **Properties** window when the **Include Actual Execution Plan** option is selected in [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)].</span></span> <span data-ttu-id="8023e-266">Si esto ocurre, significa que, aunque estos operadores se han utilizado en el plan de consulta compilado, otros operadores han realizado su trabajo en el plan de consulta en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="8023e-266">When this occurs, it means that although these operators were used in the compiled query plan, their work was performed by other operators in the run-time query plan.</span></span> <span data-ttu-id="8023e-267">Tenga en cuenta también que el número de ejecuciones en el resultado del plan de presentación generado por SET STATISTICS PROFILE es equivalente a la suma de reenlaces y rebobinados de planes de presentación generados por SET STATISTICS XML.</span><span class="sxs-lookup"><span data-stu-id="8023e-267">Also note that the number of executes in Showplan output generated by SET STATISTICS PROFILE is equivalent to the sum of rebinds and rewinds in Showplans generated by SET STATISTICS XML.</span></span>|  
|<span data-ttu-id="8023e-268">![Icono del operador Concatenation](../../2014/database-engine/media/concatenation-32x.gif "Icono del operador Concatenation")</span><span class="sxs-lookup"><span data-stu-id="8023e-268">![Concatenation operator icon](../../2014/database-engine/media/concatenation-32x.gif "Concatenation operator icon")</span></span>|<span data-ttu-id="8023e-269">**Concatenation**</span><span class="sxs-lookup"><span data-stu-id="8023e-269">**Concatenation**</span></span>|<span data-ttu-id="8023e-270">El operador **Concatenation** explora varias entradas y devuelve cada fila explorada.</span><span class="sxs-lookup"><span data-stu-id="8023e-270">The **Concatenation** operator scans multiple inputs, returning each row scanned.</span></span> <span data-ttu-id="8023e-271">Normalmente,**Concatenation** se utiliza para implementar la construcción UNION ALL de [!INCLUDE[tsql](../includes/tsql-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="8023e-271">**Concatenation** is typically used to implement the [!INCLUDE[tsql](../includes/tsql-md.md)] UNION ALL construct.</span></span> <span data-ttu-id="8023e-272">El operador físico **Concatenation** tiene dos o más entradas y una salida.</span><span class="sxs-lookup"><span data-stu-id="8023e-272">The **Concatenation** physical operator has two or more inputs and one output.</span></span> <span data-ttu-id="8023e-273">Concatenation copia filas del primer flujo de entrada en el flujo de salida y, a continuación, repite esta operación con cada flujo de entrada adicional.</span><span class="sxs-lookup"><span data-stu-id="8023e-273">Concatenation copies rows from the first input stream to the output stream, then repeats this operation for each additional input stream.</span></span> <span data-ttu-id="8023e-274">**Concatenation** es un operador lógico y físico.</span><span class="sxs-lookup"><span data-stu-id="8023e-274">**Concatenation** is a logical and physical operator.</span></span>|  
|<span data-ttu-id="8023e-275">![Icono del operador Constant Scan](../../2014/database-engine/media/constant-scan-32x.gif "Icono del operador Constant Scan")</span><span class="sxs-lookup"><span data-stu-id="8023e-275">![Constant scan operator icon](../../2014/database-engine/media/constant-scan-32x.gif "Constant scan operator icon")</span></span>|`Constant Scan`|<span data-ttu-id="8023e-276">El `Constant Scan` operador introduce una o varias filas de constantes en una consulta.</span><span class="sxs-lookup"><span data-stu-id="8023e-276">The `Constant Scan` operator introduces one or more constant rows into a query.</span></span> <span data-ttu-id="8023e-277">A `Compute Scalar` menudo, se usa un operador después de `Constant Scan` para agregar columnas a una fila generada por el `Constant Scan` operador.</span><span class="sxs-lookup"><span data-stu-id="8023e-277">A `Compute Scalar` operator is often used after a `Constant Scan` to add columns to a row produced by the `Constant Scan` operator.</span></span>|  
|<span data-ttu-id="8023e-278">![Icono del elemento del lenguaje Convert (motor de base de datos)](../../2014/database-engine/media/convert-32x.gif "Icono del elemento del lenguaje Convert (motor de base de datos)")</span><span class="sxs-lookup"><span data-stu-id="8023e-278">![Convert (Database Engine) language element icon](../../2014/database-engine/media/convert-32x.gif "Convert (Database Engine) language element icon")</span></span>|`Convert`|<span data-ttu-id="8023e-279">El operador `Convert` convierte un tipo de datos escalar en otro.</span><span class="sxs-lookup"><span data-stu-id="8023e-279">The `Convert` operator converts one scalar data type to another.</span></span> <span data-ttu-id="8023e-280">`Convert` es un elemento del lenguaje.</span><span class="sxs-lookup"><span data-stu-id="8023e-280">`Convert` is a language element.</span></span>|  
|<span data-ttu-id="8023e-281">None</span><span class="sxs-lookup"><span data-stu-id="8023e-281">None</span></span>|`Cross Join`|<span data-ttu-id="8023e-282">El operador `Cross Join` combina cada fila de la primera entrada (superior) con cada fila de la segunda entrada (inferior).</span><span class="sxs-lookup"><span data-stu-id="8023e-282">The `Cross Join` operator joins each row from the first (top) input with each row from the second (bottom) input.</span></span> <span data-ttu-id="8023e-283">`Cross Join` es un operador lógico.</span><span class="sxs-lookup"><span data-stu-id="8023e-283">`Cross Join` is a logical operator.</span></span>|  
|<span data-ttu-id="8023e-284">![Icono del operador de cursor de selección de cursor (catchall)](../../2014/database-engine/media/cursor-catch-all.gif "Icono del operador de cursor de selección de cursor (catchall)")</span><span class="sxs-lookup"><span data-stu-id="8023e-284">![Cursor catchall cursor operator icon](../../2014/database-engine/media/cursor-catch-all.gif "Cursor catchall cursor operator icon")</span></span>|`catchall`|<span data-ttu-id="8023e-285">El icono de selección (catchall) se muestra cuando la lógica que genera planes de presentación gráficos no puede encontrar un icono adecuado para el iterador.</span><span class="sxs-lookup"><span data-stu-id="8023e-285">The catchall icon is displayed when a suitable icon for the iterator cannot be found by the logic that produces graphical showplans.</span></span> <span data-ttu-id="8023e-286">Este icono no indica necesariamente una condición de error.</span><span class="sxs-lookup"><span data-stu-id="8023e-286">The catchall icon does not necessarily indicate an error condition.</span></span> <span data-ttu-id="8023e-287">Hay tres iconos de selección (catchall): azul (para iteradores), naranja (para cursores) y verde (para elementos del lenguaje [!INCLUDE[tsql](../includes/tsql-md.md)] ).</span><span class="sxs-lookup"><span data-stu-id="8023e-287">There are three catchall icons: blue (for iterators), orange (for cursors), and green (for [!INCLUDE[tsql](../includes/tsql-md.md)] language elements).</span></span>|  
|<span data-ttu-id="8023e-288">None</span><span class="sxs-lookup"><span data-stu-id="8023e-288">None</span></span>|<span data-ttu-id="8023e-289">**Cursor**</span><span class="sxs-lookup"><span data-stu-id="8023e-289">**Cursor**</span></span>|<span data-ttu-id="8023e-290">Los operadores lógicos y físicos **Cursor** se usan para describir cómo se ha ejecutado una consulta o una actualización que implican la ejecución de operaciones con cursores.</span><span class="sxs-lookup"><span data-stu-id="8023e-290">The **Cursor** logical and physical operators are used to describe how a query or update involving cursor operations is executed.</span></span> <span data-ttu-id="8023e-291">Los operadores físicos describen el algoritmo físico de implementación utilizado para procesar el cursor, por ejemplo, con un cursor dinámico.</span><span class="sxs-lookup"><span data-stu-id="8023e-291">The physical operators describe the physical implementation algorithm used to process the cursor; for example, using a keyset-driven cursor.</span></span> <span data-ttu-id="8023e-292">Cada paso de la ejecución de un cursor implica un operador físico.</span><span class="sxs-lookup"><span data-stu-id="8023e-292">Each step in the execution of a cursor involves a physical operator.</span></span> <span data-ttu-id="8023e-293">Los operadores lógicos describen una propiedad del cursor, como, por ejemplo, si el cursor es de solo lectura.</span><span class="sxs-lookup"><span data-stu-id="8023e-293">The logical operators describe a property of the cursor, such as the cursor is read only.</span></span><br /><br /> <span data-ttu-id="8023e-294">Los operadores lógicos incluyen asincrónico, optimista, principal, solo lectura, bloqueos de desplazamiento, y secundario y sincrónico.</span><span class="sxs-lookup"><span data-stu-id="8023e-294">Logical operators include Asynchronous, Optimistic, Primary, Read Only, Scroll Locks, and Secondary and Synchronous.</span></span><br /><br /> <span data-ttu-id="8023e-295">Los operadores físicos incluyen Dynamic, Fetch Query, Keyset, Population Query, Refresh Query y Snapshot.</span><span class="sxs-lookup"><span data-stu-id="8023e-295">Physical operators include Dynamic, Fetch Query, Keyset, Population Query, Refresh Query and Snapshot.</span></span>|  
|<span data-ttu-id="8023e-296">![Icono del elemento del lenguaje Declare](../../2014/database-engine/media/declare-32x.gif "Icono del elemento del lenguaje Declare")</span><span class="sxs-lookup"><span data-stu-id="8023e-296">![Declare language element icon](../../2014/database-engine/media/declare-32x.gif "Declare language element icon")</span></span>|`Declare`|<span data-ttu-id="8023e-297">El `Declare` operador asigna una variable local en el plan de consulta.</span><span class="sxs-lookup"><span data-stu-id="8023e-297">The `Declare`  operator allocates a local variable in the query plan.</span></span> <span data-ttu-id="8023e-298">`Declare` es un elemento del lenguaje.</span><span class="sxs-lookup"><span data-stu-id="8023e-298">`Declare` is a language element.</span></span>|  
|<span data-ttu-id="8023e-299">![Icono del operador Delete (motor de base de datos)](../../2014/database-engine/media/delete-32x.gif "Icono del operador Delete (motor de base de datos)")</span><span class="sxs-lookup"><span data-stu-id="8023e-299">![Delete (Database Engine) operator icon](../../2014/database-engine/media/delete-32x.gif "Delete (Database Engine) operator icon")</span></span>|`Delete`|<span data-ttu-id="8023e-300">El `Delete` operador elimina de una fila de objeto que satisface el predicado opcional de `Argument` la columna.</span><span class="sxs-lookup"><span data-stu-id="8023e-300">The `Delete` operator deletes from an object rows that satisfy the optional predicate in the `Argument` column.</span></span>|  
|<span data-ttu-id="8023e-301">![Icono del operador Delete Scan](../../2014/database-engine/media/delete-scan-32x.gif "Icono del operador Delete Scan")</span><span class="sxs-lookup"><span data-stu-id="8023e-301">![Delete scan operator icon](../../2014/database-engine/media/delete-scan-32x.gif "Delete scan operator icon")</span></span>|`Deleted Scan`|<span data-ttu-id="8023e-302">El operador `Deleted Scan` recorre la tabla eliminada en un desencadenador.</span><span class="sxs-lookup"><span data-stu-id="8023e-302">The `Deleted Scan` operator scans the deleted table within a trigger.</span></span>|  
|<span data-ttu-id="8023e-303">None</span><span class="sxs-lookup"><span data-stu-id="8023e-303">None</span></span>|`Distinct`|<span data-ttu-id="8023e-304">El operador `Distinct` quita los duplicados de un conjunto de filas o de una colección de valores.</span><span class="sxs-lookup"><span data-stu-id="8023e-304">The `Distinct` operator removes duplicates from a rowset or from a collection of values.</span></span> <span data-ttu-id="8023e-305">`Distinct` es un operador lógico.</span><span class="sxs-lookup"><span data-stu-id="8023e-305">`Distinct` is a logical operator.</span></span>|  
|<span data-ttu-id="8023e-306">None</span><span class="sxs-lookup"><span data-stu-id="8023e-306">None</span></span>|`Distinct Sort`|<span data-ttu-id="8023e-307">El `Distinct Sort` operador lógico recorre la entrada, quita los duplicados y ordena por las columnas especificadas en el predicado DISTINCT order by:() de la `Argument` columna.</span><span class="sxs-lookup"><span data-stu-id="8023e-307">The `Distinct Sort` logical operator scans the input, removing duplicates and sorting by the columns specified in the DISTINCT ORDER BY:() predicate of the `Argument` column.</span></span> <span data-ttu-id="8023e-308">`Distinct Sort` es un operador lógico.</span><span class="sxs-lookup"><span data-stu-id="8023e-308">`Distinct Sort` is a logical operator.</span></span>|  
|<span data-ttu-id="8023e-309">![Icono del operador de paralelismo Distribute Streams](../../2014/database-engine/media/parallelism-distribute-stream.gif "Icono del operador de paralelismo Distribute Streams")</span><span class="sxs-lookup"><span data-stu-id="8023e-309">![Distribute streams parallelism operator icon](../../2014/database-engine/media/parallelism-distribute-stream.gif "Distribute streams parallelism operator icon")</span></span>|<span data-ttu-id="8023e-310">**Distribute Streams**</span><span class="sxs-lookup"><span data-stu-id="8023e-310">**Distribute Streams**</span></span>|<span data-ttu-id="8023e-311">El operador **Distribute Streams** solo se usa en los planes de consulta paralelos.</span><span class="sxs-lookup"><span data-stu-id="8023e-311">The **Distribute Streams** operator is used only in parallel query plans.</span></span> <span data-ttu-id="8023e-312">El operador **Distribute Streams** utiliza una solo flujo de entrada de registros y genera varios flujos de salida.</span><span class="sxs-lookup"><span data-stu-id="8023e-312">The **Distribute Streams** operator takes a single input stream of records and produces multiple output streams.</span></span> <span data-ttu-id="8023e-313">No se cambia el contenido de los registros ni su formato.</span><span class="sxs-lookup"><span data-stu-id="8023e-313">The record contents and format are not changed.</span></span> <span data-ttu-id="8023e-314">Cada registro del flujo de entrada aparece en uno de los flujos de salida.</span><span class="sxs-lookup"><span data-stu-id="8023e-314">Each record from the input stream appears in one of the output streams.</span></span> <span data-ttu-id="8023e-315">Este operador conserva automáticamente el orden relativo de los registros de entrada en los flujos de salida.</span><span class="sxs-lookup"><span data-stu-id="8023e-315">This operator automatically preserves the relative order of the input records in the output streams.</span></span> <span data-ttu-id="8023e-316">Normalmente, se utilizan algoritmos hash para decidir a qué flujo de salida pertenece un determinado registro de entrada.</span><span class="sxs-lookup"><span data-stu-id="8023e-316">Usually, hashing is used to decide to which output stream a particular input record belongs.</span></span><br /><br /> <span data-ttu-id="8023e-317">Si la salida tiene particiones, la `Argument` columna contiene un predicado Partition Columns:() y las columnas de partición.</span><span class="sxs-lookup"><span data-stu-id="8023e-317">If the output is partitioned, then the `Argument` column contains a PARTITION COLUMNS:() predicate and the partitioning columns.</span></span> <span data-ttu-id="8023e-318">**Distribute Streams** es un operador lógico</span><span class="sxs-lookup"><span data-stu-id="8023e-318">**Distribute Streams** is a logical operator</span></span>|  
|<span data-ttu-id="8023e-319">![Icono del operador de cursor Dynamic](../../2014/database-engine/media/dynamic-32x.gif "Icono del operador de cursor Dynamic")</span><span class="sxs-lookup"><span data-stu-id="8023e-319">![Dynamic cursor operator icon](../../2014/database-engine/media/dynamic-32x.gif "Dynamic cursor operator icon")</span></span>|`Dynamic`|<span data-ttu-id="8023e-320">El operador `Dynamic` usa un cursor que puede ver todos los cambios que han realizado otros usuarios.</span><span class="sxs-lookup"><span data-stu-id="8023e-320">The `Dynamic` operator uses a cursor that can see all changes made by others.</span></span>|  
|<span data-ttu-id="8023e-321">![Icono del operador Spool](../../2014/database-engine/media/spool-32x.gif "Icono del operador Spool")</span><span class="sxs-lookup"><span data-stu-id="8023e-321">![Spool operator icon](../../2014/database-engine/media/spool-32x.gif "Spool operator icon")</span></span>|<span data-ttu-id="8023e-322">**Eager Spool**</span><span class="sxs-lookup"><span data-stu-id="8023e-322">**Eager Spool**</span></span>|<span data-ttu-id="8023e-323">El operador de **cola diligente** toma toda la entrada y almacena cada fila en un objeto temporal oculto almacenado en la `tempdb` base de datos.</span><span class="sxs-lookup"><span data-stu-id="8023e-323">The **Eager Spool** operator takes the entire input, storing each row in a hidden temporary object stored in the `tempdb` database.</span></span> <span data-ttu-id="8023e-324">Si el operador se está rebobinando (por ejemplo, por un `Nested Loops` operador) pero no se necesita ningún reenlace, se usan los datos de la cola en lugar de volver a examinar la entrada.</span><span class="sxs-lookup"><span data-stu-id="8023e-324">If the operator is rewound (for example, by a `Nested Loops` operator) but no rebinding is needed, the spooled data is used instead of rescanning the input.</span></span> <span data-ttu-id="8023e-325">Si es necesario volver a enlazar, se descartan los datos y se vuelve a generar el objeto de la cola; para ello se vuelve a recorrer la entrada (se vuelve a enlazar).</span><span class="sxs-lookup"><span data-stu-id="8023e-325">If rebinding is needed, the spooled data is discarded and the spool object is rebuilt by rescanning the (rebound) input.</span></span> <span data-ttu-id="8023e-326">El operador **Eager Spool** crea su archivo de cola de forma "ansiosa": cuando el operador primario de la cola solicita la primera fila, el operador de cola consume todas las filas de su operador de entrada y las almacena en la cola.</span><span class="sxs-lookup"><span data-stu-id="8023e-326">The **Eager Spool** operator builds its spool file in an "eager" manner: when the spool's parent operator asks for the first row, the spool operator consumes all rows from its input operator and stores them in the spool.</span></span> <span data-ttu-id="8023e-327">**Eager Spool** es un operador lógico.</span><span class="sxs-lookup"><span data-stu-id="8023e-327">**Eager Spool** is a logical operator.</span></span>|  
|<span data-ttu-id="8023e-328">![Icono del operador de cursor Fetch Query](../../2014/database-engine/media/fetch-query-32x.gif "Icono del operador de cursor Fetch Query")</span><span class="sxs-lookup"><span data-stu-id="8023e-328">![Fetch query cursor operator icon](../../2014/database-engine/media/fetch-query-32x.gif "Fetch query cursor operator icon")</span></span>|`Fetch Query`|<span data-ttu-id="8023e-329">El operador `Fetch Query` recupera filas cuando se emite una captura en un cursor.</span><span class="sxs-lookup"><span data-stu-id="8023e-329">The `Fetch Query` operator retrieves rows when a fetch is issued against a cursor.</span></span>|  
|<span data-ttu-id="8023e-330">![Icono del operador Filter (motor de base de datos)](../../2014/database-engine/media/filter-32x.gif "Icono del operador Filter (motor de base de datos)")</span><span class="sxs-lookup"><span data-stu-id="8023e-330">![Filter (Database Engine) operator icon](../../2014/database-engine/media/filter-32x.gif "Filter (Database Engine) operator icon")</span></span>|<span data-ttu-id="8023e-331">**Filter**</span><span class="sxs-lookup"><span data-stu-id="8023e-331">**Filter**</span></span>|<span data-ttu-id="8023e-332">El operador **Filter** recorre la entrada y solo devuelve las filas que cumplen la expresión de filtro (predicado) que aparece en la `Argument` columna.</span><span class="sxs-lookup"><span data-stu-id="8023e-332">The **Filter** operator scans the input, returning only those rows that satisfy the filter expression (predicate) that appears in the `Argument` column.</span></span>|  
|<span data-ttu-id="8023e-333">None</span><span class="sxs-lookup"><span data-stu-id="8023e-333">None</span></span>|`Flow Distinct`|<span data-ttu-id="8023e-334">El operador lógico `Flow Distinct` recorre la entrada y quita los duplicados.</span><span class="sxs-lookup"><span data-stu-id="8023e-334">The `Flow Distinct` logical operator scans the input, removing duplicates.</span></span> <span data-ttu-id="8023e-335">Mientras que el `Distinct` operador consume toda la entrada antes de generar cualquier salida, el operador **FlowDistinct** devuelve cada fila a medida que se obtiene de la entrada (a menos que la fila esté duplicada, en cuyo caso se descarta).</span><span class="sxs-lookup"><span data-stu-id="8023e-335">Whereas the `Distinct` operator consumes all input before producing any output, the **FlowDistinct** operator returns each row as it is obtained from the input (unless that row is a duplicate, in which case it is discarded).</span></span>|  
|<span data-ttu-id="8023e-336">None</span><span class="sxs-lookup"><span data-stu-id="8023e-336">None</span></span>|`Full Outer Join`|<span data-ttu-id="8023e-337">El operador lógico `Full Outer Join` devuelve cada fila que cumple el predicado de combinación de la primera entrada (superior) combinada con cada fila de la segunda entrada (inferior).</span><span class="sxs-lookup"><span data-stu-id="8023e-337">The `Full Outer Join` logical operator returns each row satisfying the join predicate from the first (top) input joined with each row from the second (bottom) input.</span></span> <span data-ttu-id="8023e-338">También devuelve filas de:</span><span class="sxs-lookup"><span data-stu-id="8023e-338">It also returns rows from:</span></span><br /><br /> <span data-ttu-id="8023e-339">-La primera entrada que no tenga coincidencias en la segunda entrada.</span><span class="sxs-lookup"><span data-stu-id="8023e-339">-The first input that had no matches in the second input.</span></span><br /><br /> <span data-ttu-id="8023e-340">-La segunda entrada que no tenga coincidencias en la primera entrada.</span><span class="sxs-lookup"><span data-stu-id="8023e-340">-The second input that had no matches in the first input.</span></span><br /><br /> <br /><br /> <span data-ttu-id="8023e-341">La entrada que no contiene valores coincidentes se devuelve como un valor nulo.</span><span class="sxs-lookup"><span data-stu-id="8023e-341">The input that does not contain the matching values is returned as a null value.</span></span> <span data-ttu-id="8023e-342">`Full Outer Join` es un operador lógico.</span><span class="sxs-lookup"><span data-stu-id="8023e-342">`Full Outer Join` is a logical operator.</span></span>|  
|<span data-ttu-id="8023e-343">![Icono del operador de paralelismo Gather Streams](../../2014/database-engine/media/parallelism-32x.gif "Icono del operador de paralelismo Gather Streams")</span><span class="sxs-lookup"><span data-stu-id="8023e-343">![Gather streams parallelism operator icon](../../2014/database-engine/media/parallelism-32x.gif "Gather streams parallelism operator icon")</span></span>|<span data-ttu-id="8023e-344">**Gather Streams**</span><span class="sxs-lookup"><span data-stu-id="8023e-344">**Gather Streams**</span></span>|<span data-ttu-id="8023e-345">El operador **Gather Streams** solo se usa en planes de consulta paralelos.</span><span class="sxs-lookup"><span data-stu-id="8023e-345">The **Gather Streams** operator is only used in parallel query plans.</span></span> <span data-ttu-id="8023e-346">El operador **Gather Streams** procesa varios flujos de entrada y produce un único flujo de salida de registros combinando los flujos de entrada.</span><span class="sxs-lookup"><span data-stu-id="8023e-346">The **Gather Streams** operator consumes several input streams and produces a single output stream of records by combining the input streams.</span></span> <span data-ttu-id="8023e-347">No se cambia el contenido de los registros ni su formato.</span><span class="sxs-lookup"><span data-stu-id="8023e-347">The record contents and format are not changed.</span></span> <span data-ttu-id="8023e-348">Si este operador conserva el orden, todos los flujos de entrada deben estar ordenados.</span><span class="sxs-lookup"><span data-stu-id="8023e-348">If this operator is order preserving, all input streams must be ordered.</span></span> <span data-ttu-id="8023e-349">Si el resultado está ordenado, la `Argument` columna contiene un predicado order by:() y los nombres de las columnas que se están ordenando.</span><span class="sxs-lookup"><span data-stu-id="8023e-349">If the output is ordered, the `Argument` column contains an ORDER BY:() predicate and the names of columns being ordered.</span></span> <span data-ttu-id="8023e-350">**Gather Streams** es un operador lógico.</span><span class="sxs-lookup"><span data-stu-id="8023e-350">**Gather Streams** is a logical operator.</span></span>|  
|<span data-ttu-id="8023e-351">![Icono del operador Hash Match](../../2014/database-engine/media/hash-match-32x.gif "Icono del operador Hash Match")</span><span class="sxs-lookup"><span data-stu-id="8023e-351">![Hash match operator icon](../../2014/database-engine/media/hash-match-32x.gif "Hash match operator icon")</span></span>|`Hash Match`|<span data-ttu-id="8023e-352">El operador `Hash Match` genera una tabla hash y calcula un valor hash para cada fila de su entrada de compilación.</span><span class="sxs-lookup"><span data-stu-id="8023e-352">The `Hash Match` operator builds a hash table by computing a hash value for each row from its build input.</span></span> <span data-ttu-id="8023e-353">En la columna aparece un predicado HASH:() con una lista de columnas que se usa para crear un valor hash `Argument` .</span><span class="sxs-lookup"><span data-stu-id="8023e-353">A HASH:() predicate with a list of columns used to create a hash value appears in the `Argument` column.</span></span> <span data-ttu-id="8023e-354">A continuación, por cada fila de sondeo (como corresponda), calcula un valor hash (con la misma función hash) y busca las coincidencias en la tabla hash.</span><span class="sxs-lookup"><span data-stu-id="8023e-354">Then, for each probe row (as applicable), it computes a hash value (using the same hash function) and looks in the hash table for matches.</span></span> <span data-ttu-id="8023e-355">Si hay un predicado residual (identificado por el RESIDUAL del predicado en la `Argument` columna), también se debe cumplir ese predicado para que las filas se consideren una coincidencia.</span><span class="sxs-lookup"><span data-stu-id="8023e-355">If a residual predicate is present (identified by RESIDUAL:() in the `Argument` column), that predicate must also be satisfied for rows to be considered a match.</span></span> <span data-ttu-id="8023e-356">El comportamiento depende de la operación lógica que se esté realizando:</span><span class="sxs-lookup"><span data-stu-id="8023e-356">Behavior depends on the logical operation being performed:</span></span><br /><br /> <span data-ttu-id="8023e-357">Para cualquier combinación, utilice la primera entrada (superior) para generar la tabla hash y la segunda entrada (inferior) para sondear la tabla hash.</span><span class="sxs-lookup"><span data-stu-id="8023e-357">For any joins, use the first (top) input to build the hash table and the second (bottom) input to probe the hash table.</span></span> <span data-ttu-id="8023e-358">Obtendrá como resultado las coincidencias (o las no coincidencias) que indique el tipo de combinación.</span><span class="sxs-lookup"><span data-stu-id="8023e-358">Output matches (or nonmatches) as dictated by the join type.</span></span> <span data-ttu-id="8023e-359">Si varias combinaciones utilizan la misma columna de combinación, estas operaciones se agrupan en un equipo hash.</span><span class="sxs-lookup"><span data-stu-id="8023e-359">If multiple joins use the same join column, these operations are grouped into a hash team.</span></span><br /><br /> <span data-ttu-id="8023e-360">Para los operadores Distinct o Aggregate, utilice la entrada para generar la tabla hash (para ello, quite los duplicados y calcule las expresiones de agregado).</span><span class="sxs-lookup"><span data-stu-id="8023e-360">For the distinct or aggregate operators, use the input to build the hash table (removing duplicates and computing any aggregate expressions).</span></span> <span data-ttu-id="8023e-361">Cuando se haya generado la tabla hash, recorra la tabla y presente todas las entradas.</span><span class="sxs-lookup"><span data-stu-id="8023e-361">When the hash table is built, scan the table and output all entries.</span></span><br /><br /> <span data-ttu-id="8023e-362">En el caso del operador Union, utilice la primera entrada para generar la tabla hash (para ello, quite los duplicados).</span><span class="sxs-lookup"><span data-stu-id="8023e-362">For the union operator, use the first input to build the hash table (removing duplicates).</span></span> <span data-ttu-id="8023e-363">Use la segunda entrada (que no debe tener duplicados) para sondear la tabla hash, devolver todas las filas que no tengan coincidencias y, a continuación, recorrer la tabla hash para devolver todas las entradas.</span><span class="sxs-lookup"><span data-stu-id="8023e-363">Use the second input (which must have no duplicates) to probe the hash table, returning all rows that have no matches, then scan the hash table and return all entries.</span></span><br /><br /> <br /><br /> <span data-ttu-id="8023e-364">`Hash Match` es un operador físico.</span><span class="sxs-lookup"><span data-stu-id="8023e-364">`Hash Match` is a physical operator.</span></span>|  
|<span data-ttu-id="8023e-365">![Icono del elemento del lenguaje If](../../2014/database-engine/media/if-32x.gif "Icono del elemento del lenguaje If")</span><span class="sxs-lookup"><span data-stu-id="8023e-365">![If language element icon](../../2014/database-engine/media/if-32x.gif "If language element icon")</span></span>|`If`|<span data-ttu-id="8023e-366">El operador `If` lleva a cabo el procesamiento condicional basado en una expresión.</span><span class="sxs-lookup"><span data-stu-id="8023e-366">The `If` operator carries out conditional processing based on an expression.</span></span> <span data-ttu-id="8023e-367">`If` es un elemento del lenguaje.</span><span class="sxs-lookup"><span data-stu-id="8023e-367">`If` is a language element.</span></span>|  
|<span data-ttu-id="8023e-368">None</span><span class="sxs-lookup"><span data-stu-id="8023e-368">None</span></span>|`Inner Join`|<span data-ttu-id="8023e-369">El operador lógico `Inner Join` devuelve todas las filas que cumplen la combinación de la primera entrada (superior) con la segunda entrada (inferior).</span><span class="sxs-lookup"><span data-stu-id="8023e-369">The `Inner Join` logical operator returns each row that satisfies the join of the first (top) input with the second (bottom) input.</span></span>|  
|<span data-ttu-id="8023e-370">![Icono del operador Insert (motor de base de datos)](../../2014/database-engine/media/insert-32x.gif "Icono del operador Insert (motor de base de datos)")</span><span class="sxs-lookup"><span data-stu-id="8023e-370">![Insert (Database Engine) operator icon](../../2014/database-engine/media/insert-32x.gif "Insert (Database Engine) operator icon")</span></span>|`Insert`|<span data-ttu-id="8023e-371">El `Insert` operador lógico inserta cada fila de su entrada en el objeto especificado en la `Argument` columna.</span><span class="sxs-lookup"><span data-stu-id="8023e-371">The `Insert` logical operator inserts each row from its input into the object specified in the `Argument` column.</span></span> <span data-ttu-id="8023e-372">El operador físico es `Table Insert`, `Index Insert` o `Clustered Index Insert`</span><span class="sxs-lookup"><span data-stu-id="8023e-372">The physical operator is either the `Table Insert`, `Index Insert`, or `Clustered Index Insert` operator.</span></span>|  
|<span data-ttu-id="8023e-373">![Icono del operador Inserted Scan](../../2014/database-engine/media/inserted-scan-32x.gif "Icono del operador Inserted Scan")</span><span class="sxs-lookup"><span data-stu-id="8023e-373">![Inserted scan operator icon](../../2014/database-engine/media/inserted-scan-32x.gif "Inserted scan operator icon")</span></span>|<span data-ttu-id="8023e-374">**Inserted Scan**</span><span class="sxs-lookup"><span data-stu-id="8023e-374">**Inserted Scan**</span></span>|<span data-ttu-id="8023e-375">El operador **Inserted Scan** recorre la tabla **insertada** .</span><span class="sxs-lookup"><span data-stu-id="8023e-375">The **Inserted Scan** operator scans the **inserted** table.</span></span> <span data-ttu-id="8023e-376">**Inserted Scan** es un operador lógico y físico.</span><span class="sxs-lookup"><span data-stu-id="8023e-376">**Inserted Scan** is a logical and physical operator.</span></span>|  
|<span data-ttu-id="8023e-377">![Icono del elemento del lenguaje Intrinsic](../../2014/database-engine/media/intrinsic-32x.gif "Icono del elemento del lenguaje Intrinsic")</span><span class="sxs-lookup"><span data-stu-id="8023e-377">![Intrinsic language element icon](../../2014/database-engine/media/intrinsic-32x.gif "Intrinsic language element icon")</span></span>|`Intrinsic`|<span data-ttu-id="8023e-378">El operador `Intrinsic` invoca una función [!INCLUDE[tsql](../includes/tsql-md.md)] interna.</span><span class="sxs-lookup"><span data-stu-id="8023e-378">The `Intrinsic` operator invokes an internal [!INCLUDE[tsql](../includes/tsql-md.md)] function.</span></span> <span data-ttu-id="8023e-379">`Intrinsic` es un elemento del lenguaje.</span><span class="sxs-lookup"><span data-stu-id="8023e-379">`Intrinsic` is a language element.</span></span>|  
|<span data-ttu-id="8023e-380">![Icono del operador de selección (catchall) de iterador](../../2014/database-engine/media/iterator-catch-all.gif "Icono del operador de selección (catchall) de iterador")</span><span class="sxs-lookup"><span data-stu-id="8023e-380">![Iterator catchall operator icon](../../2014/database-engine/media/iterator-catch-all.gif "Iterator catchall operator icon")</span></span>|`Iterator`|<span data-ttu-id="8023e-381">El icono de selección (catchall) `Iterator` se muestra cuando la lógica que genera planes de presentación gráficos no puede encontrar un icono adecuado para el iterador.</span><span class="sxs-lookup"><span data-stu-id="8023e-381">The `Iterator` catchall icon is displayed when a suitable icon for the iterator cannot be found by the logic that produces graphical Showplans.</span></span> <span data-ttu-id="8023e-382">Este icono no indica necesariamente una condición de error.</span><span class="sxs-lookup"><span data-stu-id="8023e-382">The catchall icon does not necessarily indicate an error condition.</span></span> <span data-ttu-id="8023e-383">Hay tres iconos de selección (catchall): azul (para iteradores), naranja (para cursores) y verde (para construcciones del lenguaje [!INCLUDE[tsql](../includes/tsql-md.md)] ).</span><span class="sxs-lookup"><span data-stu-id="8023e-383">There are three catchall icons: blue (for iterators), orange (for cursors), and green (for [!INCLUDE[tsql](../includes/tsql-md.md)] language constructs).</span></span>|  
|<span data-ttu-id="8023e-384">![Icono del operador Bookmark Lookup](../../2014/database-engine/media/bookmark-lookup-32x.gif "Icono del operador Bookmark Lookup")</span><span class="sxs-lookup"><span data-stu-id="8023e-384">![Bookmark lookup operator icon](../../2014/database-engine/media/bookmark-lookup-32x.gif "Bookmark lookup operator icon")</span></span>|`Key Lookup`|<span data-ttu-id="8023e-385">El `Key Lookup` operador es una búsqueda de marcadores en una tabla con un índice clúster.</span><span class="sxs-lookup"><span data-stu-id="8023e-385">The `Key Lookup` operator is a bookmark lookup on a table with a clustered index.</span></span> <span data-ttu-id="8023e-386">La `Argument` columna contiene el nombre del índice clúster y la clave de agrupación en clústeres utilizada para buscar la fila en el índice clúster.</span><span class="sxs-lookup"><span data-stu-id="8023e-386">The `Argument` column contains the name of the clustered index and the clustering key used to look up the row in the clustered index.</span></span> <span data-ttu-id="8023e-387">`Key Lookup`siempre está acompañado por un `Nested Loops` operador.</span><span class="sxs-lookup"><span data-stu-id="8023e-387">`Key Lookup` is always accompanied by a `Nested Loops` operator.</span></span> <span data-ttu-id="8023e-388">Si la cláusula WITH Prefetch aparece en la `Argument` columna, el procesador de consultas ha determinado que es óptimo usar la captura previa asincrónica (lectura anticipada) al buscar marcadores en el índice clúster.</span><span class="sxs-lookup"><span data-stu-id="8023e-388">If the WITH PREFETCH clause appears in the `Argument` column, the query processor has determined that it is optimal to use asynchronous prefetching (read-ahead) when looking up bookmarks in the clustered index.</span></span><br /><br /> <span data-ttu-id="8023e-389">El uso de un `Key Lookup` operador en un plan de consulta indica que la consulta puede beneficiarse del ajuste del rendimiento.</span><span class="sxs-lookup"><span data-stu-id="8023e-389">The use of a `Key Lookup` operator in a query plan indicates that the query might benefit from performance tuning.</span></span> <span data-ttu-id="8023e-390">Por ejemplo, el rendimiento de las consultas se puede mejorar al agregar un índice de cobertura.</span><span class="sxs-lookup"><span data-stu-id="8023e-390">For example, query performance might be improved by adding a covering index.</span></span>|  
|<span data-ttu-id="8023e-391">![Icono del operador de cursor Keyset](../../2014/database-engine/media/keyset-32x.gif "Icono del operador de cursor Keyset")</span><span class="sxs-lookup"><span data-stu-id="8023e-391">![Keyset cursor operator icon](../../2014/database-engine/media/keyset-32x.gif "Keyset cursor operator icon")</span></span>|`Keyset`|<span data-ttu-id="8023e-392">El operador `Keyset` usa un cursor que puede ver las actualizaciones, pero no las inserciones que realizan los demás.</span><span class="sxs-lookup"><span data-stu-id="8023e-392">The `Keyset` operator uses a cursor that can see updates, but not inserts made by others.</span></span>|  
|<span data-ttu-id="8023e-393">![Icono de selección (catchall) de elementos de lenguaje](../../2014/database-engine/media/language-construct-catch-all.gif "Icono de selección (catchall) de elementos de lenguaje")</span><span class="sxs-lookup"><span data-stu-id="8023e-393">![Language element catchall icon](../../2014/database-engine/media/language-construct-catch-all.gif "Language element catchall icon")</span></span>|`Language Element`|<span data-ttu-id="8023e-394">El icono de selección (catchall) `Language Element` se muestra cuando la lógica que genera planes de presentación gráficos no puede encontrar un icono adecuado para el iterador.</span><span class="sxs-lookup"><span data-stu-id="8023e-394">The `Language Element` catchall icon is displayed when a suitable icon for the iterator cannot be found by the logic that produces graphical Showplans.</span></span> <span data-ttu-id="8023e-395">Este icono no indica necesariamente una condición de error.</span><span class="sxs-lookup"><span data-stu-id="8023e-395">The catchall icon does not necessarily indicate an error condition.</span></span> <span data-ttu-id="8023e-396">Hay tres iconos de selección (catchall): azul (para iteradores), naranja (para cursores) y verde (para construcciones del lenguaje [!INCLUDE[tsql](../includes/tsql-md.md)] ).</span><span class="sxs-lookup"><span data-stu-id="8023e-396">There are three catchall icons: blue (for iterators), orange (for cursors), and green (for [!INCLUDE[tsql](../includes/tsql-md.md)] language constructs).</span></span>|  
|<span data-ttu-id="8023e-397">![Icono del operador Spool](../../2014/database-engine/media/spool-32x.gif "Icono del operador Spool")</span><span class="sxs-lookup"><span data-stu-id="8023e-397">![Spool operator icon](../../2014/database-engine/media/spool-32x.gif "Spool operator icon")</span></span>|<span data-ttu-id="8023e-398">**Lazy Spool**</span><span class="sxs-lookup"><span data-stu-id="8023e-398">**Lazy Spool**</span></span>|<span data-ttu-id="8023e-399">El operador lógico **Lazy spool** almacena cada fila de su entrada en un objeto temporal oculto almacenado en la `tempdb` base de datos.</span><span class="sxs-lookup"><span data-stu-id="8023e-399">The **Lazy Spool** logical operator stores each row from its input in a hidden temporary object stored in the `tempdb` database.</span></span> <span data-ttu-id="8023e-400">Si el operador se está rebobinando (por ejemplo, por un `Nested Loops` operador) pero no se necesita ningún reenlace, se usan los datos de la cola en lugar de volver a examinar la entrada.</span><span class="sxs-lookup"><span data-stu-id="8023e-400">If the operator is rewound (for example, by a `Nested Loops` operator) but no rebinding is needed, the spooled data is used instead of rescanning the input.</span></span> <span data-ttu-id="8023e-401">Si es necesario volver a enlazar, se descartan los datos y se vuelve a generar el objeto de la cola; para ello se vuelve a recorrer la entrada (se vuelve a enlazar).</span><span class="sxs-lookup"><span data-stu-id="8023e-401">If rebinding is needed, the spooled data is discarded and the spool object is rebuilt by rescanning the (rebound) input.</span></span> <span data-ttu-id="8023e-402">El operador **Lazy Spool** crea su archivo de cola de un modo "perezoso", es decir, cada vez que el operador principal de la cola pide una fila, el operador de cola obtiene una fila de su operador de entrada y la almacena en la cola, en lugar de consumir todas las filas de una vez.</span><span class="sxs-lookup"><span data-stu-id="8023e-402">The **Lazy Spool** operator builds its spool file in a "lazy" manner, that is, each time the spool's parent operator asks for a row, the spool operator gets a row from its input operator and stores it in the spool, rather than consuming all rows at once.</span></span> <span data-ttu-id="8023e-403">Lazy Spool es un operador lógico.</span><span class="sxs-lookup"><span data-stu-id="8023e-403">Lazy Spool is a logical operator.</span></span>|  
|<span data-ttu-id="8023e-404">None</span><span class="sxs-lookup"><span data-stu-id="8023e-404">None</span></span>|`Left Anti Semi Join`|<span data-ttu-id="8023e-405">El operador `Left Anti Semi Join` devuelve todas las filas de la primera entrada (superior) cuando no hay ninguna fila coincidente en la segunda entrada (inferior).</span><span class="sxs-lookup"><span data-stu-id="8023e-405">The `Left Anti Semi Join` operator returns each row from the first (top) input when there is no matching row in the second (bottom) input.</span></span> <span data-ttu-id="8023e-406">Si no existe ningún predicado de combinación en la `Argument` columna, cada fila es una fila coincidente.</span><span class="sxs-lookup"><span data-stu-id="8023e-406">If no join predicate exists in the `Argument` column, each row is a matching row.</span></span> <span data-ttu-id="8023e-407">`Left Anti Semi Join` es un operador lógico.</span><span class="sxs-lookup"><span data-stu-id="8023e-407">`Left Anti Semi Join` is a logical operator.</span></span>|  
|<span data-ttu-id="8023e-408">None</span><span class="sxs-lookup"><span data-stu-id="8023e-408">None</span></span>|`Left Outer Join`|<span data-ttu-id="8023e-409">El operador `Left Outer Join` devuelve cada fila que cumple la combinación de la primera entrada (superior) con la segunda entrada (inferior).</span><span class="sxs-lookup"><span data-stu-id="8023e-409">The `Left Outer Join` operator returns each row that satisfies the join of the first (top) input with the second (bottom) input.</span></span> <span data-ttu-id="8023e-410">También devuelve las filas de la primera entrada que no tienen filas coincidentes en la segunda entrada.</span><span class="sxs-lookup"><span data-stu-id="8023e-410">It also returns any rows from the first input that had no matching rows in the second input.</span></span> <span data-ttu-id="8023e-411">Las filas que no coinciden en la segunda entrada se devuelven como valores NULL.</span><span class="sxs-lookup"><span data-stu-id="8023e-411">The nonmatching rows in the second input are returned as null values.</span></span> <span data-ttu-id="8023e-412">Si no existe ningún predicado de combinación en la `Argument` columna, cada fila es una fila coincidente.</span><span class="sxs-lookup"><span data-stu-id="8023e-412">If no join predicate exists in the `Argument` column, each row is a matching row.</span></span> <span data-ttu-id="8023e-413">`Left Outer Join` es un operador lógico.</span><span class="sxs-lookup"><span data-stu-id="8023e-413">`Left Outer Join` is a logical operator.</span></span>|  
|<span data-ttu-id="8023e-414">None</span><span class="sxs-lookup"><span data-stu-id="8023e-414">None</span></span>|`Left Semi Join`|<span data-ttu-id="8023e-415">El operador `Left Semi Join` devuelve todas las filas de la primera entrada (superior) cuando hay una fila coincidente en la segunda entrada (inferior).</span><span class="sxs-lookup"><span data-stu-id="8023e-415">The `Left Semi Join` operator returns each row from the first (top) input when there is a matching row in the second (bottom) input.</span></span> <span data-ttu-id="8023e-416">Si no existe ningún predicado de combinación en la `Argument` columna, cada fila es una fila coincidente.</span><span class="sxs-lookup"><span data-stu-id="8023e-416">If no join predicate exists in the `Argument` column, each row is a matching row.</span></span> <span data-ttu-id="8023e-417">`Left Semi Join` es un operador lógico.</span><span class="sxs-lookup"><span data-stu-id="8023e-417">`Left Semi Join` is a logical operator.</span></span>|  
|<span data-ttu-id="8023e-418">![Icono del operador Log Row Scan](../../2014/database-engine/media/log-row-scan-32x.gif "Icono del operador Log Row Scan")</span><span class="sxs-lookup"><span data-stu-id="8023e-418">![Log row scan operator icon](../../2014/database-engine/media/log-row-scan-32x.gif "Log row scan operator icon")</span></span>|`Log Row Scan`|<span data-ttu-id="8023e-419">El operador `Log Row Scan` recorre el registro de transacciones.</span><span class="sxs-lookup"><span data-stu-id="8023e-419">The `Log Row Scan` operator scans the transaction log.</span></span> <span data-ttu-id="8023e-420">`Log Row Scan` es un operador lógico y físico.</span><span class="sxs-lookup"><span data-stu-id="8023e-420">`Log Row Scan` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="8023e-421">![Icono del operador Merge Interval](../../2014/database-engine/media/merge-interval-32x.gif "Icono del operador Merge Interval")</span><span class="sxs-lookup"><span data-stu-id="8023e-421">![Merge interval operator icon](../../2014/database-engine/media/merge-interval-32x.gif "Merge interval operator icon")</span></span>|`Merge Interval`|<span data-ttu-id="8023e-422">El operador `Merge Interval` combina varios intervalos (que pueden superponerse) para producir intervalos mínimos que no se superponen y que se usan para buscar entradas de índice.</span><span class="sxs-lookup"><span data-stu-id="8023e-422">The `Merge Interval` operator merges multiple (potentially overlapping) intervals to produce minimal, nonoverlapping intervals that are then used to seek index entries.</span></span> <span data-ttu-id="8023e-423">Este operador aparece normalmente sobre uno o más `Compute Scalar` operadores sobre `Constant Scan` operadores, que construyen los intervalos (representados como columnas de una fila) que este operador combina.</span><span class="sxs-lookup"><span data-stu-id="8023e-423">This operator typically appears above one or more `Compute Scalar` operators over `Constant Scan` operators, which construct the intervals (represented as columns in a row) that this operator merges.</span></span> <span data-ttu-id="8023e-424">`Merge Interval` es un operador lógico y físico.</span><span class="sxs-lookup"><span data-stu-id="8023e-424">`Merge Interval` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="8023e-425">![Icono del operador Merge Join](../../2014/database-engine/media/merge-join-32x.gif "Icono del operador Merge Join")</span><span class="sxs-lookup"><span data-stu-id="8023e-425">![Merge join operator icon](../../2014/database-engine/media/merge-join-32x.gif "Merge join operator icon")</span></span>|<span data-ttu-id="8023e-426">**Merge Join**</span><span class="sxs-lookup"><span data-stu-id="8023e-426">**Merge Join**</span></span>|<span data-ttu-id="8023e-427">El operador **Merge Join** realiza las siguientes operaciones lógicas de combinación interna (inner join), combinación externa izquierda (left outer join), semicombinación izquierda (left semi join), antisemicombinación izquierda (left anti semi join), combinación externa derecha (right outer join), semicombinación derecha (right semi join), antisemicombinación derecha (right anti semi join) y unión (union).</span><span class="sxs-lookup"><span data-stu-id="8023e-427">The **Merge Join** operator performs the inner join, left outer join, left semi join, left anti semi join, right outer join, right semi join, right anti semi join, and union logical operations.</span></span><br /><br /> <span data-ttu-id="8023e-428">En la `Argument` columna, el operador **Merge join** contiene un predicado Merge:() si la operación realiza una combinación uno a varios, o un predicado de combinación de varios a varios, si la operación realiza una combinación de varios a varios.</span><span class="sxs-lookup"><span data-stu-id="8023e-428">In the `Argument` column, the **Merge Join** operator contains a MERGE:() predicate if the operation is performing a one-to-many join, or a MANY-TO-MANY MERGE:() predicate if the operation is performing a many-to-many join.</span></span> <span data-ttu-id="8023e-429">La `Argument` columna también incluye una lista separada por comas de las columnas utilizadas para realizar la operación.</span><span class="sxs-lookup"><span data-stu-id="8023e-429">The `Argument` column also includes a comma-separated list of columns used to perform the operation.</span></span> <span data-ttu-id="8023e-430">El operador **Merge Join** requiere dos entradas ordenadas por sus respectivas columnas, que se pueden realizar mediante la inserción de operaciones de ordenación explícitas en el plan de consulta.</span><span class="sxs-lookup"><span data-stu-id="8023e-430">The **Merge Join** operator requires two inputs sorted on their respective columns, possibly by inserting explicit sort operations into the query plan.</span></span> <span data-ttu-id="8023e-431">El operador Merge Join es especialmente eficaz si no se necesita un orden explícito, por ejemplo, si hay un índice idóneo de árbol b en la base de datos o si el orden se puede aprovechar en varias operaciones, como en una combinación de mezcla y una agrupación con acumulación.</span><span class="sxs-lookup"><span data-stu-id="8023e-431">Merge join is particularly effective if explicit sorting is not required, for example, if there is a suitable B-tree index in the database or if the sort order can be exploited for multiple operations, such as a merge join and grouping with roll up.</span></span> <span data-ttu-id="8023e-432">**Merge Join** es un operador físico.</span><span class="sxs-lookup"><span data-stu-id="8023e-432">**Merge Join** is a physical operator.</span></span>|  
|<span data-ttu-id="8023e-433">![Icono del operador Nested Loops](../../2014/database-engine/media/nested-loops-32x.gif "Icono del operador Nested Loops")</span><span class="sxs-lookup"><span data-stu-id="8023e-433">![Nested loops operator icon](../../2014/database-engine/media/nested-loops-32x.gif "Nested loops operator icon")</span></span>|`Nested Loops`|<span data-ttu-id="8023e-434">El operador `Nested Loops` realiza las operaciones lógicas de combinación interna, combinación externa izquierda, semicombinación izquierda y anti semicombinación.</span><span class="sxs-lookup"><span data-stu-id="8023e-434">The `Nested Loops` operator performs the inner join, left outer join, left semi join, and left anti semi join logical operations.</span></span> <span data-ttu-id="8023e-435">Las combinaciones de bucles anidados realizan una búsqueda en la tabla interna por cada fila de la tabla externa, normalmente mediante un índice.</span><span class="sxs-lookup"><span data-stu-id="8023e-435">Nested loops joins perform a search on the inner table for each row of the outer table, typically using an index.</span></span> <span data-ttu-id="8023e-436">El procesador de consultas decide, en función de los costos anticipados, si debe ordenar o no la entrada externa para mejorar la ubicación de las búsquedas en el índice sobre la entrada interna.</span><span class="sxs-lookup"><span data-stu-id="8023e-436">The query processor decides, based on anticipated costs, whether to sort the outer input in order to improve locality of the searches on the index over the inner input.</span></span> <span data-ttu-id="8023e-437">Todas las filas que cumplen el predicado (opcional) en la `Argument` columna se devuelven como corresponda, en función de la operación lógica que se realiza.</span><span class="sxs-lookup"><span data-stu-id="8023e-437">Any rows that satisfy the (optional) predicate in the `Argument` column are returned as applicable, based on the logical operation being performed.</span></span> <span data-ttu-id="8023e-438">`Nested Loops` es un operador físico.</span><span class="sxs-lookup"><span data-stu-id="8023e-438">`Nested Loops` is a physical operator.</span></span>|  
|<span data-ttu-id="8023e-439">![Icono del operador Nonclustered Index Delete](../../2014/database-engine/media/nonclust-index-delete-32x.gif "Icono del operador Nonclustered Index Delete")</span><span class="sxs-lookup"><span data-stu-id="8023e-439">![Nonclustered index delete operator icon](../../2014/database-engine/media/nonclust-index-delete-32x.gif "Nonclustered index delete operator icon")</span></span>|`Nonclustered Index Delete`|<span data-ttu-id="8023e-440">El `Nonclustered Index Delete` operador elimina las filas de entrada del índice no clúster especificado en la `Argument` columna.</span><span class="sxs-lookup"><span data-stu-id="8023e-440">The `Nonclustered Index Delete` operator deletes input rows from the nonclustered index specified in the `Argument` column.</span></span> <span data-ttu-id="8023e-441">`Nonclustered Index Delete` es un operador físico.</span><span class="sxs-lookup"><span data-stu-id="8023e-441">`Nonclustered Index Delete` is a physical operator.</span></span>|  
|<span data-ttu-id="8023e-442">![Icono del operador Nonclustered Index Insert](../../2014/database-engine/media/nonclust-index-insert-32x.gif "Icono del operador Nonclustered Index Insert")</span><span class="sxs-lookup"><span data-stu-id="8023e-442">![Nonclustered index insert operator icon](../../2014/database-engine/media/nonclust-index-insert-32x.gif "Nonclustered index insert operator icon")</span></span>|`Index Insert`|<span data-ttu-id="8023e-443">El `Index Insert` operador inserta filas de su entrada en el índice no clúster especificado en la `Argument` columna.</span><span class="sxs-lookup"><span data-stu-id="8023e-443">The `Index Insert` operator inserts rows from its input into the nonclustered index specified in the `Argument` column.</span></span> <span data-ttu-id="8023e-444">La columna `Argument` contiene también un predicado SET:(), que indica el valor en el que se establece cada columna.</span><span class="sxs-lookup"><span data-stu-id="8023e-444">The `Argument` column also contains a SET:() predicate, which indicates the value to which each column is set.</span></span> <span data-ttu-id="8023e-445">`Index Insert` es un operador físico.</span><span class="sxs-lookup"><span data-stu-id="8023e-445">`Index Insert` is a physical operator.</span></span>|  
|<span data-ttu-id="8023e-446">![Icono del operador Nonclustered Index Scan](../../2014/database-engine/media/nonclustered-index-scan-32x.gif "Icono del operador Nonclustered Index Scan")</span><span class="sxs-lookup"><span data-stu-id="8023e-446">![Nonclustered index scan operator icon](../../2014/database-engine/media/nonclustered-index-scan-32x.gif "Nonclustered index scan operator icon")</span></span>|`Index Scan`|<span data-ttu-id="8023e-447">El `Index Scan` operador recupera todas las filas del índice no clúster especificado en la `Argument` columna.</span><span class="sxs-lookup"><span data-stu-id="8023e-447">The `Index Scan` operator retrieves all rows from the nonclustered index specified in the `Argument` column.</span></span> <span data-ttu-id="8023e-448">Si aparece un predicado WHERE:() opcional en la `Argument` columna, solo se devuelven las filas que cumplen el predicado.</span><span class="sxs-lookup"><span data-stu-id="8023e-448">If an optional WHERE:() predicate appears in the `Argument` column, only those rows that satisfy the predicate are returned.</span></span> <span data-ttu-id="8023e-449">`Index Scan` es un operador lógico y físico.</span><span class="sxs-lookup"><span data-stu-id="8023e-449">`Index Scan` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="8023e-450">![Icono del operador Nonclustered Index Seek](../../2014/database-engine/media/index-seek-32x.gif "Icono del operador Nonclustered Index Seek")</span><span class="sxs-lookup"><span data-stu-id="8023e-450">![Nonclustered index seek operator icon](../../2014/database-engine/media/index-seek-32x.gif "Nonclustered index seek operator icon")</span></span>|`Index Seek`|<span data-ttu-id="8023e-451">El operador `Index Seek` usa la capacidad de búsqueda de los índices para recuperar filas de un índice no clúster.</span><span class="sxs-lookup"><span data-stu-id="8023e-451">The `Index Seek` operator uses the seeking ability of indexes to retrieve rows from a nonclustered index.</span></span> <span data-ttu-id="8023e-452">La `Argument` columna contiene el nombre del índice no clúster que se está usando.</span><span class="sxs-lookup"><span data-stu-id="8023e-452">The `Argument` column contains the name of the nonclustered index being used.</span></span> <span data-ttu-id="8023e-453">También contiene el predicado SEEK:().</span><span class="sxs-lookup"><span data-stu-id="8023e-453">It also contains the SEEK:() predicate.</span></span> <span data-ttu-id="8023e-454">El motor de almacenamiento utiliza el índice para procesar solamente las filas que cumplen el predicado SEEK:().</span><span class="sxs-lookup"><span data-stu-id="8023e-454">The storage engine uses the index to process only those rows that satisfy the SEEK:() predicate.</span></span> <span data-ttu-id="8023e-455">También se puede incluir un predicado WHERE:(), predicado que evaluará el motor de almacenamiento respecto a todas las filas que cumplan el predicado SEEK:() (no se utilizan los índices para esta comprobación).</span><span class="sxs-lookup"><span data-stu-id="8023e-455">It optionally may include a WHERE:() predicate, which the storage engine will evaluate against all rows that satisfy the SEEK:() predicate (it does not use the indexes to do this).</span></span> <span data-ttu-id="8023e-456">Si la `Argument` columna contiene la cláusula ordered, el procesador de consultas ha determinado que las filas deben devolverse en el orden en el que el índice no clúster las haya clasificado.</span><span class="sxs-lookup"><span data-stu-id="8023e-456">If the `Argument` column contains the ORDERED clause, the query processor has determined that the rows must be returned in the order in which the nonclustered index has sorted them.</span></span> <span data-ttu-id="8023e-457">Si no hay una cláusula ORDERED, el motor de almacenamiento busca el índice de la forma óptima (que no garantiza que el resultado se ordene).</span><span class="sxs-lookup"><span data-stu-id="8023e-457">If the ORDERED clause is not present, the storage engine searches the index in the optimal way (which does not guarantee that the output will be sorted).</span></span> <span data-ttu-id="8023e-458">Permitir que el resultado mantenga su ordenación puede ser menos eficiente que generar un resultado no ordenado.</span><span class="sxs-lookup"><span data-stu-id="8023e-458">Allowing the output to retain its ordering may be less efficient than producing nonsorted output.</span></span> <span data-ttu-id="8023e-459">`Index Seek` es un operador lógico y físico.</span><span class="sxs-lookup"><span data-stu-id="8023e-459">`Index Seek` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="8023e-460">![Icono del operador Nonclustered Index Spool](../../2014/database-engine/media/index-spool-32x.gif "Icono del operador Nonclustered Index Spool")</span><span class="sxs-lookup"><span data-stu-id="8023e-460">![Nonclustered index spool operator icon](../../2014/database-engine/media/index-spool-32x.gif "Nonclustered index spool operator icon")</span></span>|<span data-ttu-id="8023e-461">**Index Spool**</span><span class="sxs-lookup"><span data-stu-id="8023e-461">**Index Spool**</span></span>|<span data-ttu-id="8023e-462">El operador físico **index spool** contiene un predicado Seek:() en la `Argument` columna.</span><span class="sxs-lookup"><span data-stu-id="8023e-462">The **Index Spool** physical operator contains a SEEK:() predicate in the `Argument` column.</span></span> <span data-ttu-id="8023e-463">El operador **index spool** recorre sus filas de entrada, coloca una copia de cada fila en un archivo de cola oculto (almacenado en la `tempdb` base de datos y que solo existe durante la duración de la consulta) y genera un índice no clúster en las filas.</span><span class="sxs-lookup"><span data-stu-id="8023e-463">The **Index Spool** operator scans its input rows, placing a copy of each row in a hidden spool file (stored in the `tempdb` database and existing only for the lifetime of the query), and builds a nonclustered index on the rows.</span></span> <span data-ttu-id="8023e-464">Esto permite utilizar la capacidad de búsqueda de los índices para presentar solo las filas que cumplan el predicado SEEK:().</span><span class="sxs-lookup"><span data-stu-id="8023e-464">This allows you to use the seeking capability of indexes to output only those rows that satisfy the SEEK:() predicate.</span></span> <span data-ttu-id="8023e-465">Si el operador se está rebobinando (por ejemplo, por un `Nested Loops` operador) pero no se necesita ningún reenlace, se usan los datos de la cola en lugar de volver a examinar la entrada.</span><span class="sxs-lookup"><span data-stu-id="8023e-465">If the operator is rewound (for example, by a `Nested Loops` operator) but no rebinding is needed, the spooled data is used instead of rescanning the input.</span></span>|  
|<span data-ttu-id="8023e-466">![Icono del operador Nonclustered Index Update](../../2014/database-engine/media/nonclust-index-update-32x.gif "Icono del operador Nonclustered Index Update")</span><span class="sxs-lookup"><span data-stu-id="8023e-466">![Nonclustered index update operator icon](../../2014/database-engine/media/nonclust-index-update-32x.gif "Nonclustered index update operator icon")</span></span>|`Nonclustered Index Update`|<span data-ttu-id="8023e-467">El `Nonclustered Index Update` operador físico actualiza las filas de su entrada en el índice no clúster especificado en la `Argument` columna.</span><span class="sxs-lookup"><span data-stu-id="8023e-467">The `Nonclustered Index Update` physical operator updates rows from its input in the nonclustered index specified in the `Argument` column.</span></span> <span data-ttu-id="8023e-468">Si hay un predicado SET:(), se asigna este valor a todas las filas actualizadas.</span><span class="sxs-lookup"><span data-stu-id="8023e-468">If a SET:() predicate is present, each updated column is set to this value.</span></span> <span data-ttu-id="8023e-469">`Nonclustered Index Update` es un operador físico.</span><span class="sxs-lookup"><span data-stu-id="8023e-469">`Nonclustered Index Update` is a physical operator.</span></span>|  
|<span data-ttu-id="8023e-470">![Icono del operador Online Index Insert](../../2014/database-engine/media/online-index-32x.gif "Icono del operador Online Index Insert")</span><span class="sxs-lookup"><span data-stu-id="8023e-470">![Online index insert operator icon](../../2014/database-engine/media/online-index-32x.gif "Online index insert operator icon")</span></span>|<span data-ttu-id="8023e-471">**Online Index Insert**</span><span class="sxs-lookup"><span data-stu-id="8023e-471">**Online Index Insert**</span></span>|<span data-ttu-id="8023e-472">El operador físico **Online Index Insert** indica que una operación de crear, modificar o colocar índice se realiza en línea.</span><span class="sxs-lookup"><span data-stu-id="8023e-472">The **Online Index Insert** physical operator indicates that an index create, alter, or drop operation is performed online.</span></span> <span data-ttu-id="8023e-473">Es decir, los datos de la tabla subyacente permanecen disponible para los usuarios durante la operación de índice.</span><span class="sxs-lookup"><span data-stu-id="8023e-473">That is, the underlying table data remains available to users during the index operation.</span></span>|  
|<span data-ttu-id="8023e-474">None</span><span class="sxs-lookup"><span data-stu-id="8023e-474">None</span></span>|`Parallelism`|<span data-ttu-id="8023e-475">El `Parallelism` operador realiza las operaciones lógicas distribute streams, Gather streams y Repartition streams.</span><span class="sxs-lookup"><span data-stu-id="8023e-475">The `Parallelism` operator performs the distribute streams, gather streams, and repartition streams logical operations.</span></span> <span data-ttu-id="8023e-476">Las `Argument` columnas pueden contener un predicado Partition Columns:() con una lista separada por comas de las columnas en las que se van a crear particiones.</span><span class="sxs-lookup"><span data-stu-id="8023e-476">The `Argument` columns can contain a PARTITION COLUMNS:() predicate with a comma-separated list of the columns being partitioned.</span></span> <span data-ttu-id="8023e-477">Las `Argument` columnas también pueden contener un predicado order by:(), con una lista de las columnas para conservar el criterio de ordenación durante la creación de particiones.</span><span class="sxs-lookup"><span data-stu-id="8023e-477">The `Argument` columns can also contain an ORDER BY:() predicate, listing the columns to preserve the sort order for during partitioning.</span></span> <span data-ttu-id="8023e-478">`Parallelism` es un operador físico.</span><span class="sxs-lookup"><span data-stu-id="8023e-478">`Parallelism` is a physical operator.</span></span><br /><br /> <span data-ttu-id="8023e-479">Nota: si se ha compilado una consulta como consulta paralela, pero en tiempo de ejecución se ejecuta como consulta en serie, la salida del plan de presentación generada por SET STATISTICs XML o mediante la opción **incluir plan de ejecución real** de [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)] no contendrá el `RunTimeInformation` elemento del `Parallelism` operador.</span><span class="sxs-lookup"><span data-stu-id="8023e-479">Note: If a query has been compiled as a parallel query, but at run time it is run as a serial query, the Showplan output generated by SET STATISTICS XML or by using the **Include Actual Execution Plan** option in [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)] will not contain the `RunTimeInformation` element for the `Parallelism` operator.</span></span> <span data-ttu-id="8023e-480">En la salida de SET STATISTICs PROFILE, el recuento de filas real y el número real de ejecuciones mostrará ceros para el `Parallelism` operador.</span><span class="sxs-lookup"><span data-stu-id="8023e-480">In SET STATISTICS PROFILE output, the actual row counts and actual number of executes will display zeroes for the `Parallelism` operator.</span></span> <span data-ttu-id="8023e-481">Cuando se produce cualquiera de las condiciones, significa que el `Parallelism` operador solo se utilizó durante la compilación de la consulta y no en el plan de consulta en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="8023e-481">When either condition occurs, it means that the `Parallelism` operator was only used during query compilation and not in the run-time query plan.</span></span> <span data-ttu-id="8023e-482">Tenga en cuenta que a veces los planes de consulta paralelos se ejecutan en serie si existe una elevada carga simultánea en el servidor.</span><span class="sxs-lookup"><span data-stu-id="8023e-482">Note that sometimes parallel query plans are run in serial if there is a high concurrent load on the server.</span></span>|  
|<span data-ttu-id="8023e-483">![Icono del operador Parameter Table Scan](../../2014/database-engine/media/parameter-table-scan-32x.gif "Icono del operador Parameter Table Scan")</span><span class="sxs-lookup"><span data-stu-id="8023e-483">![Parameter table scan operator icon](../../2014/database-engine/media/parameter-table-scan-32x.gif "Parameter table scan operator icon")</span></span>|`Parameter Table Scan`|<span data-ttu-id="8023e-484">El operador `Parameter Table Scan` recorre una tabla que actúa como parámetro en la consulta actual.</span><span class="sxs-lookup"><span data-stu-id="8023e-484">The `Parameter Table Scan` operator scans a table that is acting as a parameter in the current query.</span></span> <span data-ttu-id="8023e-485">Normalmente, se usa para consultas INSERT en un procedimiento almacenado.</span><span class="sxs-lookup"><span data-stu-id="8023e-485">Typically, this is used for INSERT queries within a stored procedure.</span></span> <span data-ttu-id="8023e-486">`Parameter Table Scan` es un operador lógico y físico.</span><span class="sxs-lookup"><span data-stu-id="8023e-486">`Parameter Table Scan` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="8023e-487">None</span><span class="sxs-lookup"><span data-stu-id="8023e-487">None</span></span>|<span data-ttu-id="8023e-488">**Partial Aggregate**</span><span class="sxs-lookup"><span data-stu-id="8023e-488">**Partial Aggregate**</span></span>|<span data-ttu-id="8023e-489">**Partial Aggregate** se usa en planes paralelos.</span><span class="sxs-lookup"><span data-stu-id="8023e-489">**Partial Aggregate** is used in parallel plans.</span></span> <span data-ttu-id="8023e-490">Aplica una función de agregación a tantas filas de entrada como sea posible para que la escritura en el disco (también denominada "volcado") no sea necesaria.</span><span class="sxs-lookup"><span data-stu-id="8023e-490">It applies an aggregation function to as many input rows as possible so that writing to disk (known as a "spill") is not necessary.</span></span> <span data-ttu-id="8023e-491">`Hash Match`es el único operador físico (iterador) que implementa la agregación de la partición.</span><span class="sxs-lookup"><span data-stu-id="8023e-491">`Hash Match` is the only physical operator (iterator) that implements partition aggregation.</span></span> <span data-ttu-id="8023e-492">**Partial Aggregate** es un operador lógico.</span><span class="sxs-lookup"><span data-stu-id="8023e-492">**Partial Aggregate** is a logical operator.</span></span>|  
|<span data-ttu-id="8023e-493">![Icono del operador de cursor Population Query](../../2014/database-engine/media/poulation-query-32x.gif "Icono del operador de cursor Population Query")</span><span class="sxs-lookup"><span data-stu-id="8023e-493">![Population query cursor operator icon](../../2014/database-engine/media/poulation-query-32x.gif "Population query cursor operator icon")</span></span>|`Population Query`|<span data-ttu-id="8023e-494">El operador `Population Query` rellena la tabla de trabajo de un cursor cuando se abre el cursor.</span><span class="sxs-lookup"><span data-stu-id="8023e-494">The `Population Query` operator populates the work table of a cursor when the cursor is opened.</span></span>|  
|<span data-ttu-id="8023e-495">![Icono del operador de cursor Refresh Query](../../2014/database-engine/media/refresh-query-32x.gif "Icono del operador de cursor Refresh Query")</span><span class="sxs-lookup"><span data-stu-id="8023e-495">![Refresh query cursor operator icon](../../2014/database-engine/media/refresh-query-32x.gif "Refresh query cursor operator icon")</span></span>|`Refresh Query`|<span data-ttu-id="8023e-496">El operador `Refresh Query` captura los datos actuales de las filas del búfer de lectura.</span><span class="sxs-lookup"><span data-stu-id="8023e-496">The `Refresh Query` operator fetches current data for rows in the fetch buffer.</span></span>|  
|<span data-ttu-id="8023e-497">![Icono del operador Remote Delete](../../2014/database-engine/media/remote-delete-32x.gif "Icono del operador Remote Delete")</span><span class="sxs-lookup"><span data-stu-id="8023e-497">![Remote delete operator icon](../../2014/database-engine/media/remote-delete-32x.gif "Remote delete operator icon")</span></span>|`Remote Delete`|<span data-ttu-id="8023e-498">El operador `Remote Delete` elimina las filas de entrada de un objeto remoto.</span><span class="sxs-lookup"><span data-stu-id="8023e-498">The `Remote Delete` operator deletes the input rows from a remote object.</span></span> <span data-ttu-id="8023e-499">`Remote Delete` es un operador lógico y físico.</span><span class="sxs-lookup"><span data-stu-id="8023e-499">`Remote Delete` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="8023e-500">![Remote Index Seek (operador de SHOWPLAN)](../../2014/database-engine/media/remote-index-scan-32x.gif "Operador de plan de presentación Remote Index Seek")</span><span class="sxs-lookup"><span data-stu-id="8023e-500">![remote index seek showplan operator](../../2014/database-engine/media/remote-index-scan-32x.gif "remote index seek showplan operator")</span></span>|<span data-ttu-id="8023e-501">**Remote Index Scan**</span><span class="sxs-lookup"><span data-stu-id="8023e-501">**Remote Index Scan**</span></span>|<span data-ttu-id="8023e-502">El operador **Remote Index Scan** digitaliza el índice remoto especificado en la columna Argument.</span><span class="sxs-lookup"><span data-stu-id="8023e-502">The **Remote Index Scan** operator scans the remote index specified in the Argument column.</span></span> <span data-ttu-id="8023e-503">**Remote Index Scan** es un operador lógico y físico.</span><span class="sxs-lookup"><span data-stu-id="8023e-503">**Remote Index Scan** is a logical and physical operator.</span></span>|  
|<span data-ttu-id="8023e-504">![Remote Index Seek (operador de SHOWPLAN)](../../2014/database-engine/media/remote-index-seek-32x.gif "Operador de plan de presentación Remote Index Seek")</span><span class="sxs-lookup"><span data-stu-id="8023e-504">![remote index seek showplan operator](../../2014/database-engine/media/remote-index-seek-32x.gif "remote index seek showplan operator")</span></span>|<span data-ttu-id="8023e-505">**Remote Index Seek**</span><span class="sxs-lookup"><span data-stu-id="8023e-505">**Remote Index Seek**</span></span>|<span data-ttu-id="8023e-506">El operador **Remote Index Seek** usa la capacidad de búsqueda de un objeto de índice remoto para recuperar filas.</span><span class="sxs-lookup"><span data-stu-id="8023e-506">The **Remote Index Seek** operator uses the seeking ability of a remote index object to retrieve rows.</span></span> <span data-ttu-id="8023e-507">La `Argument` columna contiene el nombre del índice remoto que se está usando y el predicado Seek:().</span><span class="sxs-lookup"><span data-stu-id="8023e-507">The `Argument` column contains the name of the remote index being used and the SEEK:() predicate.</span></span> <span data-ttu-id="8023e-508">**Remote Index Seek** es un operador lógico y físico.</span><span class="sxs-lookup"><span data-stu-id="8023e-508">**Remote Index Seek** is a logical physical operator.</span></span>|  
|<span data-ttu-id="8023e-509">![Icono del operador Remote Insert](../../2014/database-engine/media/remote-insert-32x.gif "Icono del operador Remote Insert")</span><span class="sxs-lookup"><span data-stu-id="8023e-509">![Remote insert operator icon](../../2014/database-engine/media/remote-insert-32x.gif "Remote insert operator icon")</span></span>|<span data-ttu-id="8023e-510">**Remote Insert**</span><span class="sxs-lookup"><span data-stu-id="8023e-510">**Remote Insert**</span></span>|<span data-ttu-id="8023e-511">El operador **Remote Insert** inserta las filas de entrada en un objeto remoto.</span><span class="sxs-lookup"><span data-stu-id="8023e-511">The **Remote Insert** operator inserts the input rows into a remote object.</span></span> <span data-ttu-id="8023e-512">**Remote Insert** es un operador lógico y físico.</span><span class="sxs-lookup"><span data-stu-id="8023e-512">**Remote Insert** is a logical and physical operator.</span></span>|  
|<span data-ttu-id="8023e-513">![Icono del operador Remote Query](../../2014/database-engine/media/remote-query-32x.gif "Icono del operador Remote Query")</span><span class="sxs-lookup"><span data-stu-id="8023e-513">![Remote query operator icon](../../2014/database-engine/media/remote-query-32x.gif "Remote query operator icon")</span></span>|`Remote Query`|<span data-ttu-id="8023e-514">El operador `Remote Query` envía una consulta a un origen remoto.</span><span class="sxs-lookup"><span data-stu-id="8023e-514">The `Remote Query` operator submits a query to a remote source.</span></span> <span data-ttu-id="8023e-515">El texto de la consulta enviada al servidor remoto aparece en la `Argument` columna.</span><span class="sxs-lookup"><span data-stu-id="8023e-515">The text of the query sent to the remote server appears in the `Argument` column.</span></span> <span data-ttu-id="8023e-516">`Remote Query` es un operador lógico y físico.</span><span class="sxs-lookup"><span data-stu-id="8023e-516">`Remote Query` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="8023e-517">![Icono del operador Remote Scan](../../2014/database-engine/media/remote-scan-32x.gif "Icono del operador Remote Scan")</span><span class="sxs-lookup"><span data-stu-id="8023e-517">![Remote scan operator icon](../../2014/database-engine/media/remote-scan-32x.gif "Remote scan operator icon")</span></span>|`Remote Scan`|<span data-ttu-id="8023e-518">El operador `Remote Scan` recorre un objeto remoto.</span><span class="sxs-lookup"><span data-stu-id="8023e-518">The `Remote Scan` operator scans a remote object.</span></span> <span data-ttu-id="8023e-519">El nombre del objeto remoto aparece en la `Argument` columna.</span><span class="sxs-lookup"><span data-stu-id="8023e-519">The name of the remote object appears in the `Argument` column.</span></span> <span data-ttu-id="8023e-520">`Remote Scan` es un operador lógico y físico.</span><span class="sxs-lookup"><span data-stu-id="8023e-520">`Remote Scan` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="8023e-521">![Icono del operador Remote Update](../../2014/database-engine/media/remote-update-32x.gif "Icono del operador Remote Update")</span><span class="sxs-lookup"><span data-stu-id="8023e-521">![Remote update operator icon](../../2014/database-engine/media/remote-update-32x.gif "Remote update operator icon")</span></span>|`Remote Update`|<span data-ttu-id="8023e-522">El operador `Remote Update` actualiza las filas de entrada en un objeto remoto.</span><span class="sxs-lookup"><span data-stu-id="8023e-522">The `Remote Update` operator updates the input rows in a remote object.</span></span> <span data-ttu-id="8023e-523">`Remote Update` es un operador lógico y físico.</span><span class="sxs-lookup"><span data-stu-id="8023e-523">`Remote Update` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="8023e-524">![Icono del operador de paralelismo Repartition Streams](../../2014/database-engine/media/parallelism-repartition-stream.gif "Icono del operador de paralelismo Repartition Streams")</span><span class="sxs-lookup"><span data-stu-id="8023e-524">![Repartition streams parallelism operator icon](../../2014/database-engine/media/parallelism-repartition-stream.gif "Repartition streams parallelism operator icon")</span></span>|<span data-ttu-id="8023e-525">**Repartition Streams**</span><span class="sxs-lookup"><span data-stu-id="8023e-525">**Repartition Streams**</span></span>|<span data-ttu-id="8023e-526">El operador **Repartition Streams** usa varios flujos y produce varios flujos de registros.</span><span class="sxs-lookup"><span data-stu-id="8023e-526">The **Repartition Streams** operator consumes multiple streams and produces multiple streams of records.</span></span> <span data-ttu-id="8023e-527">No se cambia el contenido de los registros ni su formato.</span><span class="sxs-lookup"><span data-stu-id="8023e-527">The record contents and format are not changed.</span></span> <span data-ttu-id="8023e-528">Si el optimizador de consultas usa un filtro de mapas de bits, se reduce el número de filas del flujo de salida.</span><span class="sxs-lookup"><span data-stu-id="8023e-528">If the query optimizer uses a bitmap filter, the number of rows in the output stream is reduced.</span></span> <span data-ttu-id="8023e-529">Cada registro de un flujo de entrada se coloca en un flujo de salida.</span><span class="sxs-lookup"><span data-stu-id="8023e-529">Each record from an input stream is placed into one output stream.</span></span> <span data-ttu-id="8023e-530">Si el operador conserva el orden, se deben ordenar y mezclar todos los flujos de entrada en varios flujos de salida ordenados.</span><span class="sxs-lookup"><span data-stu-id="8023e-530">If this operator is order preserving, all input streams must be ordered and merged into several ordered output streams.</span></span> <span data-ttu-id="8023e-531">Si la salida tiene particiones, la `Argument` columna contiene un predicado Partition Columns:() y las columnas de partición. Si el resultado está ordenado, la `Argument` columna contiene un predicado order by:() y las columnas que se están ordenando.</span><span class="sxs-lookup"><span data-stu-id="8023e-531">If the output is partitioned, the `Argument` column contains a PARTITION COLUMNS:() predicate and the partitioning columns.If the output is ordered, the `Argument` column contains an ORDER BY:() predicate and the columns being ordered.</span></span> <span data-ttu-id="8023e-532">**Repartition Streams** es un operador lógico.</span><span class="sxs-lookup"><span data-stu-id="8023e-532">**Repartition Streams** is a logical operator.</span></span> <span data-ttu-id="8023e-533">Este operador solo se usa en los planes de consulta paralelos.</span><span class="sxs-lookup"><span data-stu-id="8023e-533">The operator is used only in parallel query plans.</span></span>|  
|<span data-ttu-id="8023e-534">![Icono del elemento del lenguaje Result](../../2014/database-engine/media/result-32x.gif "Icono del elemento del lenguaje Result")</span><span class="sxs-lookup"><span data-stu-id="8023e-534">![Result language element icon](../../2014/database-engine/media/result-32x.gif "Result language element icon")</span></span>|`Result`|<span data-ttu-id="8023e-535">El operador `Result` incluye los datos devueltos al final de un plan de consulta.</span><span class="sxs-lookup"><span data-stu-id="8023e-535">The `Result` operator is the data returned at the end of a query plan.</span></span> <span data-ttu-id="8023e-536">Suele ser el elemento raíz de un plan de presentación.</span><span class="sxs-lookup"><span data-stu-id="8023e-536">This is usually the root element of a Showplan.</span></span> <span data-ttu-id="8023e-537">`Result` es un elemento del lenguaje.</span><span class="sxs-lookup"><span data-stu-id="8023e-537">`Result` is a language element.</span></span>|  
|<span data-ttu-id="8023e-538">![Icono del operador RID Lookup](../../2014/database-engine/media/rid-nonclust-locate-32x.gif "Icono del operador RID Lookup")</span><span class="sxs-lookup"><span data-stu-id="8023e-538">![RID lookup operator icon](../../2014/database-engine/media/rid-nonclust-locate-32x.gif "RID lookup operator icon")</span></span>|`RID Lookup`|<span data-ttu-id="8023e-539">`RID Lookup` es una búsqueda de marcadores en un montón que usa un identificador de fila suministrado (RID).</span><span class="sxs-lookup"><span data-stu-id="8023e-539">`RID Lookup` is a bookmark lookup on a heap using a supplied row identifier (RID).</span></span> <span data-ttu-id="8023e-540">La `Argument` columna contiene la etiqueta de marcador utilizada para buscar la fila en la tabla y el nombre de la tabla en la que se busca la fila.</span><span class="sxs-lookup"><span data-stu-id="8023e-540">The `Argument` column contains the bookmark label used to look up the row in the table and the name of the table in which the row is looked up.</span></span> <span data-ttu-id="8023e-541">`RID Lookup` siempre va acompañado de NESTED LOOP JOIN.</span><span class="sxs-lookup"><span data-stu-id="8023e-541">`RID Lookup` is always accompanied by a NESTED LOOP JOIN.</span></span> <span data-ttu-id="8023e-542">`RID Lookup` es un operador físico.</span><span class="sxs-lookup"><span data-stu-id="8023e-542">`RID Lookup` is a physical operator.</span></span> <span data-ttu-id="8023e-543">Para obtener más información sobre las búsquedas por marcador, vea "[Bookmark Lookup](https://go.microsoft.com/fwlink/?LinkId=132568)" (en inglés) en el blog de SQL Server en MSDN.</span><span class="sxs-lookup"><span data-stu-id="8023e-543">For more information about bookmark lookups, see "[Bookmark Lookup](https://go.microsoft.com/fwlink/?LinkId=132568)" on the MSDN SQL Server blog.</span></span>|  
|<span data-ttu-id="8023e-544">None</span><span class="sxs-lookup"><span data-stu-id="8023e-544">None</span></span>|`Right Anti Semi Join`|<span data-ttu-id="8023e-545">El operador `Right Anti Semi Join` muestra todas las filas de la segunda entrada (inferior) para las que no hay una fila coincidente en la primera entrada (superior).</span><span class="sxs-lookup"><span data-stu-id="8023e-545">The `Right Anti Semi Join` operator outputs each row from the second (bottom) input when a matching row in the first (top) input does not exist.</span></span> <span data-ttu-id="8023e-546">Una fila coincidente se define como una fila que satisface el predicado de la `Argument` columna (si no existe ningún predicado, cada fila es una fila coincidente).</span><span class="sxs-lookup"><span data-stu-id="8023e-546">A matching row is defined as a row that satisfies the predicate in the `Argument` column (if no predicate exists, each row is a matching row).</span></span> <span data-ttu-id="8023e-547">`Right Anti Semi Join` es un operador lógico.</span><span class="sxs-lookup"><span data-stu-id="8023e-547">`Right Anti Semi Join` is a logical operator.</span></span>|  
|<span data-ttu-id="8023e-548">None</span><span class="sxs-lookup"><span data-stu-id="8023e-548">None</span></span>|`Right Outer Join`|<span data-ttu-id="8023e-549">El operador `Right Outer Join` devuelve cada fila que cumple la combinación de la segunda entrada (inferior) con cada fila coincidente de la primera entrada (superior).</span><span class="sxs-lookup"><span data-stu-id="8023e-549">The `Right Outer Join` operator returns each row that satisfies the join of the second (bottom) input with each matching row from the first (top) input.</span></span> <span data-ttu-id="8023e-550">También devolverá las filas de la segunda entrada que no tengan filas coincidentes en la primera entrada, combinadas con NULL (nulo).</span><span class="sxs-lookup"><span data-stu-id="8023e-550">It also returns any rows from the second input that had no matching rows in the first input, joined with NULL.</span></span> <span data-ttu-id="8023e-551">Si no existe ningún predicado de combinación en la `Argument` columna, cada fila es una fila coincidente.</span><span class="sxs-lookup"><span data-stu-id="8023e-551">If no join predicate exists in the `Argument` column, each row is a matching row.</span></span> <span data-ttu-id="8023e-552">`Right Outer Join` es un operador lógico.</span><span class="sxs-lookup"><span data-stu-id="8023e-552">`Right Outer Join` is a logical operator.</span></span>|  
|<span data-ttu-id="8023e-553">None</span><span class="sxs-lookup"><span data-stu-id="8023e-553">None</span></span>|`Right Semi Join`|<span data-ttu-id="8023e-554">El operador `Right Semi Join` devuelve todas las filas de la segunda entrada (inferior) para las que haya una fila coincidente en la primera entrada (superior).</span><span class="sxs-lookup"><span data-stu-id="8023e-554">The `Right Semi Join` operator returns each row from the second (bottom) input when there is a matching row in the first (top) input.</span></span> <span data-ttu-id="8023e-555">Si no existe ningún predicado de combinación en la `Argument` columna, cada fila es una fila coincidente.</span><span class="sxs-lookup"><span data-stu-id="8023e-555">If no join predicate exists in the `Argument` column, each row is a matching row.</span></span> <span data-ttu-id="8023e-556">`Right Semi Join` es un operador lógico.</span><span class="sxs-lookup"><span data-stu-id="8023e-556">`Right Semi Join` is a logical operator.</span></span>|  
|<span data-ttu-id="8023e-557">![Icono del operador Row Count Spool](../../2014/database-engine/media/remote-count-spool-32x.gif "Icono del operador Row Count Spool")</span><span class="sxs-lookup"><span data-stu-id="8023e-557">![Row count spool operator icon](../../2014/database-engine/media/remote-count-spool-32x.gif "Row count spool operator icon")</span></span>|<span data-ttu-id="8023e-558">**Row Count Spool**</span><span class="sxs-lookup"><span data-stu-id="8023e-558">**Row Count Spool**</span></span>|<span data-ttu-id="8023e-559">El operador **Row Count Spool** recorre la entrada, cuenta el número de filas que hay y devuelve ese número de filas sin datos.</span><span class="sxs-lookup"><span data-stu-id="8023e-559">The **Row Count Spool** operator scans the input, counting how many rows are present and returning the same number of rows without any data in them.</span></span> <span data-ttu-id="8023e-560">Este operador se utiliza cuando es importante comprobar la existencia de las filas, en lugar de los datos que éstas contienen.</span><span class="sxs-lookup"><span data-stu-id="8023e-560">This operator is used when it is important to check for the existence of rows, rather than the data contained in the rows.</span></span> <span data-ttu-id="8023e-561">Por ejemplo, si un `Nested Loops` operador realiza una operación de semicombinación izquierda y el predicado de combinación se aplica a la entrada interna, se puede colocar una cola de recuento de filas en la parte superior de la entrada interna del `Nested Loops` operador.</span><span class="sxs-lookup"><span data-stu-id="8023e-561">For example, if a `Nested Loops` operator performs a left semi join operation and the join predicate applies to inner input, a row count spool may be placed at the top of the inner input of the `Nested Loops` operator.</span></span> <span data-ttu-id="8023e-562">A continuación, el `Nested Loops` operador puede determinar el número de filas que genera la cola de recuento de filas (dado que los datos reales del lado interno no son necesarios) para determinar si se debe devolver la fila externa.</span><span class="sxs-lookup"><span data-stu-id="8023e-562">Then the `Nested Loops` operator can determine how many rows are output by the row count spool (because the actual data from the inner side is not needed) to determine whether to return the outer row.</span></span> <span data-ttu-id="8023e-563">**Row Count Spool** es un operador físico.</span><span class="sxs-lookup"><span data-stu-id="8023e-563">**Row Count Spool** is a physical operator.</span></span>|  
|<span data-ttu-id="8023e-564">![Icono del operador Segment](../../2014/database-engine/media/segment-32x.gif "Icono del operador Segment")</span><span class="sxs-lookup"><span data-stu-id="8023e-564">![Segment operator icon](../../2014/database-engine/media/segment-32x.gif "Segment operator icon")</span></span>|<span data-ttu-id="8023e-565">**Segmento**</span><span class="sxs-lookup"><span data-stu-id="8023e-565">**Segment**</span></span>|<span data-ttu-id="8023e-566">**Segment** es un operador físico y lógico.</span><span class="sxs-lookup"><span data-stu-id="8023e-566">**Segment** is a physical and a logical operator.</span></span> <span data-ttu-id="8023e-567">Divide el conjunto de entrada en segmentos basados en el valor de una o varias columnas.</span><span class="sxs-lookup"><span data-stu-id="8023e-567">It divides the input set into segments based on the value of one or more columns.</span></span> <span data-ttu-id="8023e-568">Estas columnas se muestran como argumentos en el operador **Segment** .</span><span class="sxs-lookup"><span data-stu-id="8023e-568">These columns are shown as arguments in the **Segment** operator.</span></span> <span data-ttu-id="8023e-569">A continuación, muestra un segmento cada vez.</span><span class="sxs-lookup"><span data-stu-id="8023e-569">The operator then outputs one segment at a time.</span></span>|  
|<span data-ttu-id="8023e-570">None</span><span class="sxs-lookup"><span data-stu-id="8023e-570">None</span></span>|`Segment Repartition`|<span data-ttu-id="8023e-571">En un plan de consulta paralelo, a veces hay regiones conceptuales de iteradores.</span><span class="sxs-lookup"><span data-stu-id="8023e-571">In a parallel query plan, sometimes there are conceptual regions of iterators.</span></span> <span data-ttu-id="8023e-572">Todos los iteradores de una región así se pueden ejecutar mediante subprocesos paralelos.</span><span class="sxs-lookup"><span data-stu-id="8023e-572">All of the iterators within such a region can be executed by parallel threads.</span></span> <span data-ttu-id="8023e-573">Las regiones en sí deben ejecutarse en serie.</span><span class="sxs-lookup"><span data-stu-id="8023e-573">The regions themselves must be executed serially.</span></span> <span data-ttu-id="8023e-574">Algunos de los iteradores `Parallelism` de una región individual se denominan `Branch Repartition`.</span><span class="sxs-lookup"><span data-stu-id="8023e-574">Some of the `Parallelism` iterators within an individual region are called `Branch Repartition`.</span></span> <span data-ttu-id="8023e-575">El iterador `Parallelism` situado en el límite de dos de estas regiones se denomina `Segment Repartition`.</span><span class="sxs-lookup"><span data-stu-id="8023e-575">The `Parallelism` iterator at the boundary of two such regions is called `Segment Repartition`.</span></span> <span data-ttu-id="8023e-576">`Branch Repartition` y `Segment Repartition` son operadores lógicos.</span><span class="sxs-lookup"><span data-stu-id="8023e-576">`Branch Repartition` and `Segment Repartition` are logical operators.</span></span>|  
|<span data-ttu-id="8023e-577">![Icono del operador Sequence](../../2014/database-engine/media/sequence-32x.gif "Icono del operador Sequence")</span><span class="sxs-lookup"><span data-stu-id="8023e-577">![Sequence operator icon](../../2014/database-engine/media/sequence-32x.gif "Sequence operator icon")</span></span>|`Sequence`|<span data-ttu-id="8023e-578">El operador `Sequence` controla los planes de actualización grandes.</span><span class="sxs-lookup"><span data-stu-id="8023e-578">The `Sequence` operator drives wide update plans.</span></span> <span data-ttu-id="8023e-579">Funcionalmente, ejecuta cada entrada en secuencia (de principio a fin).</span><span class="sxs-lookup"><span data-stu-id="8023e-579">Functionally, it executes each input in sequence (top to bottom).</span></span> <span data-ttu-id="8023e-580">Normalmente, cada entrada es una actualización de un objeto diferente.</span><span class="sxs-lookup"><span data-stu-id="8023e-580">Each input is usually an update of a different object.</span></span> <span data-ttu-id="8023e-581">Solo devuelve las filas que proceden de su última entrada (inferior).</span><span class="sxs-lookup"><span data-stu-id="8023e-581">It returns only those rows that come from its last (bottom) input.</span></span> <span data-ttu-id="8023e-582">`Sequence` es un operador lógico y físico.</span><span class="sxs-lookup"><span data-stu-id="8023e-582">`Sequence` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="8023e-583">![Icono del operador Sequence Project](../../2014/database-engine/media/sequence-project-32x.gif "Icono del operador Sequence Project")</span><span class="sxs-lookup"><span data-stu-id="8023e-583">![Sequence project operator icon](../../2014/database-engine/media/sequence-project-32x.gif "Sequence project operator icon")</span></span>|`Sequence Project`|<span data-ttu-id="8023e-584">El operador `Sequence Project` agrega columnas para realizar cálculos sobre un conjunto ordenado.</span><span class="sxs-lookup"><span data-stu-id="8023e-584">The `Sequence Project` operator adds columns to perform computations over an ordered set.</span></span> <span data-ttu-id="8023e-585">Divide el conjunto de entrada en segmentos basados en el valor de una o varias columnas.</span><span class="sxs-lookup"><span data-stu-id="8023e-585">It divides the input set into segments based on the value of one or more columns.</span></span> <span data-ttu-id="8023e-586">A continuación, muestra un segmento cada vez.</span><span class="sxs-lookup"><span data-stu-id="8023e-586">The operator then outputs one segment at a time.</span></span> <span data-ttu-id="8023e-587">En el operador `Sequence Project`, las columnas se muestran como argumentos.</span><span class="sxs-lookup"><span data-stu-id="8023e-587">These columns are shown as arguments in the `Sequence Project` operator.</span></span> <span data-ttu-id="8023e-588">`Sequence Project` es un operador lógico y físico.</span><span class="sxs-lookup"><span data-stu-id="8023e-588">`Sequence Project` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="8023e-589">![Icono del operador de cursor Snapshot](../../2014/database-engine/media/snapshot-32x.gif "Icono del operador de cursor Snapshot")</span><span class="sxs-lookup"><span data-stu-id="8023e-589">![Snapshot cursor operator icon](../../2014/database-engine/media/snapshot-32x.gif "Snapshot cursor operator icon")</span></span>|<span data-ttu-id="8023e-590">**Instantánea**</span><span class="sxs-lookup"><span data-stu-id="8023e-590">**Snapshot**</span></span>|<span data-ttu-id="8023e-591">El operador **Snapshot** crea un cursor que no detecta las modificaciones realizadas por otros.</span><span class="sxs-lookup"><span data-stu-id="8023e-591">The **Snapshot** operator creates a cursor that does not see changes made by others.</span></span>|  
|<span data-ttu-id="8023e-592">![Icono del operador Sort](../../2014/database-engine/media/sort-32x.gif "Icono del operador Sort")</span><span class="sxs-lookup"><span data-stu-id="8023e-592">![Sort operator icon](../../2014/database-engine/media/sort-32x.gif "Sort operator icon")</span></span>|`Sort`|<span data-ttu-id="8023e-593">El `Sort` operador ordena todas las filas entrantes.</span><span class="sxs-lookup"><span data-stu-id="8023e-593">The `Sort` operator sorts all incoming rows.</span></span> <span data-ttu-id="8023e-594">La `Argument` columna contiene un predicado DISTINCT order by:() si esta operación quita los duplicados, o un predicado order by:() con una lista separada por comas de las columnas que se están ordenando.</span><span class="sxs-lookup"><span data-stu-id="8023e-594">The `Argument` column contains either a DISTINCT ORDER BY:() predicate if duplicates are removed by this operation, or an ORDER BY:() predicate with a comma-separated list of the columns being sorted.</span></span> <span data-ttu-id="8023e-595">Las columnas llevan como prefijo el valor ASC, si el orden de las columnas es ascendente, o el valor DESC, si es descendente.</span><span class="sxs-lookup"><span data-stu-id="8023e-595">The columns are prefixed with the value ASC if the columns are sorted in ascending order, or the value DESC if the columns are sorted in descending order.</span></span> <span data-ttu-id="8023e-596">`Sort` es un operador lógico y físico.</span><span class="sxs-lookup"><span data-stu-id="8023e-596">`Sort` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="8023e-597">![Icono del operador Split](../../2014/database-engine/media/split-32x.gif "Icono del operador Split")</span><span class="sxs-lookup"><span data-stu-id="8023e-597">![Split operator icon](../../2014/database-engine/media/split-32x.gif "Split operator icon")</span></span>|`Split`|<span data-ttu-id="8023e-598">El `Split` operador se usa para optimizar el procesamiento de actualizaciones.</span><span class="sxs-lookup"><span data-stu-id="8023e-598">The `Split` operator is used to optimize update processing.</span></span> <span data-ttu-id="8023e-599">Divide cada operación de actualización en una operación de eliminación y una operación de inserción.</span><span class="sxs-lookup"><span data-stu-id="8023e-599">It splits each update operation into a delete and an insert operation.</span></span> <span data-ttu-id="8023e-600">`Split` es un operador lógico y físico.</span><span class="sxs-lookup"><span data-stu-id="8023e-600">`Split` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="8023e-601">![Icono del operador Spool](../../2014/database-engine/media/spool-32x.gif "Icono del operador Spool")</span><span class="sxs-lookup"><span data-stu-id="8023e-601">![Spool operator icon](../../2014/database-engine/media/spool-32x.gif "Spool operator icon")</span></span>|<span data-ttu-id="8023e-602">**Spool**</span><span class="sxs-lookup"><span data-stu-id="8023e-602">**Spool**</span></span>|<span data-ttu-id="8023e-603">El operador **spool** guarda un resultado de consulta intermedio en la `tempdb` base de datos.</span><span class="sxs-lookup"><span data-stu-id="8023e-603">The **Spool** operator saves an intermediate query result to the `tempdb` database.</span></span>|  
|<span data-ttu-id="8023e-604">![Icono del operador Stream Aggregate](../../2014/database-engine/media/stream-aggregate-32x.gif "Icono del operador Stream Aggregate")</span><span class="sxs-lookup"><span data-stu-id="8023e-604">![Stream aggregate operator icon](../../2014/database-engine/media/stream-aggregate-32x.gif "Stream aggregate operator icon")</span></span>|`Stream Aggregate`|<span data-ttu-id="8023e-605">El operador `Stream Aggregate` agrupa las filas por una o varias columnas y, a continuación, calcula una o varias expresiones agregadas devueltas por la consulta.</span><span class="sxs-lookup"><span data-stu-id="8023e-605">The `Stream Aggregate` operator groups rows by one or more columns and then calculates one or more aggregate expressions returned by the query.</span></span> <span data-ttu-id="8023e-606">El resultado de este operador puedes ser utilizado por operadores posteriores de la consulta, devuelto al cliente, o ambas cosas.</span><span class="sxs-lookup"><span data-stu-id="8023e-606">The output of this operator can be referenced by later operators in the query, returned to the client, or both.</span></span> <span data-ttu-id="8023e-607">El operador `Stream Aggregate` requiere una entrada ordenada por las columnas dentro de sus grupos.</span><span class="sxs-lookup"><span data-stu-id="8023e-607">The `Stream Aggregate` operator requires input ordered by the columns within its groups.</span></span> <span data-ttu-id="8023e-608">El optimizador usará un operador `Sort` antes de este operador si un operador `Sort` anterior no ha ordenado ya los datos o debido a una búsqueda o recorrido de índice ordenado.</span><span class="sxs-lookup"><span data-stu-id="8023e-608">The optimizer will use a `Sort` operator prior to this operator if the data is not already sorted due to a prior `Sort` operator or due to an ordered index seek or scan.</span></span> <span data-ttu-id="8023e-609">En la instrucción SHOWPLAN_ALL o en el plan de ejecución gráfico de [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)] , las columnas del predicado Group by se enumeran en la `Argument` columna y las expresiones de agregado se enumeran en la columna **valores definidos** .</span><span class="sxs-lookup"><span data-stu-id="8023e-609">In the SHOWPLAN_ALL statement or the graphical execution plan in [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)], the columns in the GROUP BY predicate are listed in the `Argument` column, and the aggregate expressions are listed in the **Defined Values** column.</span></span> <span data-ttu-id="8023e-610">`Stream Aggregate` es un operador físico.</span><span class="sxs-lookup"><span data-stu-id="8023e-610">`Stream Aggregate` is a physical operator.</span></span>|  
|<span data-ttu-id="8023e-611">![Icono del operador Switch](../../2014/database-engine/media/switch-32x.gif "Icono del operador Switch")</span><span class="sxs-lookup"><span data-stu-id="8023e-611">![Switch operator icon](../../2014/database-engine/media/switch-32x.gif "Switch operator icon")</span></span>|<span data-ttu-id="8023e-612">**Switch**</span><span class="sxs-lookup"><span data-stu-id="8023e-612">**Switch**</span></span>|<span data-ttu-id="8023e-613">**Switch** es un tipo especial de iterador de concatenación que tiene *n* entradas.</span><span class="sxs-lookup"><span data-stu-id="8023e-613">**Switch** is a special type of concatenation iterator that has *n* inputs.</span></span> <span data-ttu-id="8023e-614">A cada operador **Switch** se asocia una expresión.</span><span class="sxs-lookup"><span data-stu-id="8023e-614">An expression is associated with each **Switch** operator.</span></span> <span data-ttu-id="8023e-615">Dependiendo del valor devuelto de la expresión (entre 0 y *n*-1), **Switch** copia el flujo de entrada correspondiente en el flujo de salida.</span><span class="sxs-lookup"><span data-stu-id="8023e-615">Depending on the return value of the expression (between 0 and *n*-1), **Switch** copies the appropriate input stream to the output stream.</span></span> <span data-ttu-id="8023e-616">Un uso de **Switch** consiste en implementar planes de consulta en los que participan cursores de avance rápido con determinados operadores, como el operador **TOP** .</span><span class="sxs-lookup"><span data-stu-id="8023e-616">One use of **Switch** is to implement query plans involving fast forward cursors with certain operators such as the **TOP** operator.</span></span> <span data-ttu-id="8023e-617">**Switch** es un operador lógico y físico.</span><span class="sxs-lookup"><span data-stu-id="8023e-617">**Switch** is both a logical and physical operator.</span></span>|  
|<span data-ttu-id="8023e-618">![Icono del operador Table Delete](../../2014/database-engine/media/table-delete-32x.gif "Icono del operador Table Delete")</span><span class="sxs-lookup"><span data-stu-id="8023e-618">![Table delete operator icon](../../2014/database-engine/media/table-delete-32x.gif "Table delete operator icon")</span></span>|`Table Delete`|<span data-ttu-id="8023e-619">El `Table Delete` operador físico elimina las filas de la tabla especificada en la `Argument` columna del plan de ejecución de la consulta.</span><span class="sxs-lookup"><span data-stu-id="8023e-619">The `Table Delete` physical operator deletes rows from the table specified in the `Argument` column of the query execution plan.</span></span>|  
|<span data-ttu-id="8023e-620">![Icono del operador Table Insert](../../2014/database-engine/media/table-insert-32x.gif "Icono del operador Table Insert")</span><span class="sxs-lookup"><span data-stu-id="8023e-620">![Table insert operator icon](../../2014/database-engine/media/table-insert-32x.gif "Table insert operator icon")</span></span>|`Table Insert`|<span data-ttu-id="8023e-621">El `Table Insert` operador inserta filas de su entrada en la tabla especificada en la `Argument` columna del plan de ejecución de la consulta.</span><span class="sxs-lookup"><span data-stu-id="8023e-621">The `Table Insert` operator inserts rows from its input into the table specified in the `Argument` column of the query execution plan.</span></span> <span data-ttu-id="8023e-622">La columna `Argument` contiene también un predicado SET:(), que indica el valor en el que se establece cada columna.</span><span class="sxs-lookup"><span data-stu-id="8023e-622">The `Argument` column also contains a SET:() predicate, which indicates the value to which each column is set.</span></span> <span data-ttu-id="8023e-623">Si `Table Insert` no tiene elementos secundarios para los valores de inserción, se obtendrá la fila insertada del propio operador Insert.</span><span class="sxs-lookup"><span data-stu-id="8023e-623">If `Table Insert` has no children for insert values, then the row inserted is taken from the Insert operator itself.</span></span> <span data-ttu-id="8023e-624">`Table Insert` es un operador físico.</span><span class="sxs-lookup"><span data-stu-id="8023e-624">`Table Insert` is a physical operator.</span></span>|  
|<span data-ttu-id="8023e-625">![Operador Table Merge](../../2014/database-engine/media/table-merge-32x.gif "Operador Table Merge")</span><span class="sxs-lookup"><span data-stu-id="8023e-625">![Table merge operator](../../2014/database-engine/media/table-merge-32x.gif "Table merge operator")</span></span>|<span data-ttu-id="8023e-626">**Table Merge**</span><span class="sxs-lookup"><span data-stu-id="8023e-626">**Table Merge**</span></span>|<span data-ttu-id="8023e-627">El operador **Table Merge** aplica un flujo de datos de mezcla a un montón.</span><span class="sxs-lookup"><span data-stu-id="8023e-627">The **Table Merge** operator applies a merge data stream to a heap.</span></span> <span data-ttu-id="8023e-628">El operador elimina, actualiza o inserta filas en la tabla especificada en la `Argument` columna del operador.</span><span class="sxs-lookup"><span data-stu-id="8023e-628">The operator deletes, updates, or inserts rows in the table specified in the `Argument` column of the operator.</span></span> <span data-ttu-id="8023e-629">La operación real realizada depende del valor en tiempo de ejecución de la columna **Action** especificada en la `Argument` columna del operador.</span><span class="sxs-lookup"><span data-stu-id="8023e-629">The actual operation performed depends on the run-time value of the **ACTION** column specified in the `Argument` column of the operator.</span></span> <span data-ttu-id="8023e-630">**Table Merge** es un operador físico.</span><span class="sxs-lookup"><span data-stu-id="8023e-630">**Table Merge** is a physical operator.</span></span>|  
|<span data-ttu-id="8023e-631">![Icono del operador Table Scan](../../2014/database-engine/media/table-scan-32x.gif "Icono del operador Table Scan")</span><span class="sxs-lookup"><span data-stu-id="8023e-631">![Table scan operator icon](../../2014/database-engine/media/table-scan-32x.gif "Table scan operator icon")</span></span>|`Table Scan`|<span data-ttu-id="8023e-632">El `Table Scan` operador recupera todas las filas de la tabla especificada en la `Argument` columna del plan de ejecución de la consulta.</span><span class="sxs-lookup"><span data-stu-id="8023e-632">The `Table Scan` operator retrieves all rows from the table specified in the `Argument` column of the query execution plan.</span></span> <span data-ttu-id="8023e-633">Si aparece un predicado WHERE:() en la `Argument` columna, solo se devuelven las filas que cumplen el predicado.</span><span class="sxs-lookup"><span data-stu-id="8023e-633">If a WHERE:() predicate appears in the `Argument` column, only those rows that satisfy the predicate are returned.</span></span> <span data-ttu-id="8023e-634">`Table Scan` es un operador lógico y físico.</span><span class="sxs-lookup"><span data-stu-id="8023e-634">`Table Scan` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="8023e-635">![Icono del operador Table Spool](../../2014/database-engine/media/table-spool-32x.gif "Icono del operador Table Spool")</span><span class="sxs-lookup"><span data-stu-id="8023e-635">![Table spool operator icon](../../2014/database-engine/media/table-spool-32x.gif "Table spool operator icon")</span></span>|<span data-ttu-id="8023e-636">**Table Spool**</span><span class="sxs-lookup"><span data-stu-id="8023e-636">**Table Spool**</span></span>|<span data-ttu-id="8023e-637">El operador **Table Spool** recorre la entrada y coloca una copia de cada fila en una tabla de cola oculta almacenada en la base de datos [tempdb](../relational-databases/databases/tempdb-database.md) y que solo existe durante la duración de la consulta.</span><span class="sxs-lookup"><span data-stu-id="8023e-637">The **Table Spool** operator scans the input and places a copy of each row in a hidden spool table that is stored in the [tempdb](../relational-databases/databases/tempdb-database.md) database and existing only for the lifetime of the query.</span></span> <span data-ttu-id="8023e-638">Si el operador se está rebobinando (por ejemplo, por un `Nested Loops` operador) pero no se necesita ningún reenlace, se usan los datos de la cola en lugar de volver a examinar la entrada.</span><span class="sxs-lookup"><span data-stu-id="8023e-638">If the operator is rewound (for example, by a `Nested Loops` operator) but no rebinding is needed, the spooled data is used instead of rescanning the input.</span></span> <span data-ttu-id="8023e-639">**Table Spool** es un operador físico.</span><span class="sxs-lookup"><span data-stu-id="8023e-639">**Table Spool** is a physical operator.</span></span>|  
|<span data-ttu-id="8023e-640">![Icono del operador Table Update](../../2014/database-engine/media/table-update-32x.gif "Icono del operador Table Update")</span><span class="sxs-lookup"><span data-stu-id="8023e-640">![Table update operator icon](../../2014/database-engine/media/table-update-32x.gif "Table update operator icon")</span></span>|`Table Update`|<span data-ttu-id="8023e-641">El `Table Update` operador físico actualiza las filas de entrada en la tabla especificada en la `Argument` columna del plan de ejecución de la consulta.</span><span class="sxs-lookup"><span data-stu-id="8023e-641">The `Table Update` physical operator updates input rows in the table specified in the `Argument` column of the query execution plan.</span></span> <span data-ttu-id="8023e-642">El predicado SET:() determina el valor de cada columna actualizada.</span><span class="sxs-lookup"><span data-stu-id="8023e-642">The SET:() predicate determines the value of each updated column.</span></span> <span data-ttu-id="8023e-643">Se puede hacer referencia a estos valores en la cláusula SET o en cualquier parte del operador, y en cualquier parte de esta consulta.</span><span class="sxs-lookup"><span data-stu-id="8023e-643">These values may be referenced in the SET clause or elsewhere within this operator as well as elsewhere within this query.</span></span>|  
|<span data-ttu-id="8023e-644">![Icono del operador Table-valued Function](../../2014/database-engine/media/table-valued-function-32x.gif "Icono del operador Table-valued Function")</span><span class="sxs-lookup"><span data-stu-id="8023e-644">![Table-valued function operator icon](../../2014/database-engine/media/table-valued-function-32x.gif "Table-valued function operator icon")</span></span>|<span data-ttu-id="8023e-645">**Table-valued Function**</span><span class="sxs-lookup"><span data-stu-id="8023e-645">**Table-valued Function**</span></span>|<span data-ttu-id="8023e-646">El operador **Table-valued Function** evalúa una función con valores de tabla ( [!INCLUDE[tsql](../includes/tsql-md.md)] o CLR) y almacena las filas resultantes en la base de datos [tempdb](../relational-databases/databases/tempdb-database.md) .</span><span class="sxs-lookup"><span data-stu-id="8023e-646">The **Table-valued Function** operator evaluates a table-valued function (either [!INCLUDE[tsql](../includes/tsql-md.md)] or CLR), and stores the resulting rows in the [tempdb](../relational-databases/databases/tempdb-database.md) database.</span></span> <span data-ttu-id="8023e-647">Cuando los iteradores principales solicitan las filas, la **función con valores de tabla** devuelve las filas de `tempdb` .</span><span class="sxs-lookup"><span data-stu-id="8023e-647">When the parent iterators request the rows, **Table-valued Function** returns the rows from `tempdb`.</span></span><br /><br /> <span data-ttu-id="8023e-648">Las consultas con llamadas a funciones con valores de tablas generan planes de consultas con el iterador de la **Table-valued Function** .</span><span class="sxs-lookup"><span data-stu-id="8023e-648">Queries with calls to table-valued functions generate query plans with the **Table-valued Function** iterator.</span></span> <span data-ttu-id="8023e-649">**Table-valued Function** se puede evaluar con valores de parámetro diferentes:</span><span class="sxs-lookup"><span data-stu-id="8023e-649">**Table-valued Function** can be evaluated with different parameter values:</span></span><br /><br /> <span data-ttu-id="8023e-650">**Table-valued Function XML Reader** escribe un BLOB XML como parámetro y genera un conjunto de filas que representa los nodos XML en el orden del documento XML.</span><span class="sxs-lookup"><span data-stu-id="8023e-650">**Table-valued Function XML Reader** inputs an XML BLOB as a parameter and produces a rowset representing XML nodes in XML document order.</span></span> <span data-ttu-id="8023e-651">Otros parámetros de entrada pueden restringir los nodos XML devueltos a un subconjunto del documento XML.</span><span class="sxs-lookup"><span data-stu-id="8023e-651">Other input parameters may restrict XML nodes returned to a subset of XML document.</span></span><br /><br /> <span data-ttu-id="8023e-652">**Table Valued Function XML Reader with XPath filter** es un tipo especial de **XML Reader Table-valued Function** que restringe la salida a los nodos XML que satisfacen una expresión XPath.</span><span class="sxs-lookup"><span data-stu-id="8023e-652">**Table Valued Function XML Reader with XPath filter** is a special type of **XML Reader Table-valued Function** that restricts output to XML nodes satisfying an XPath expression.</span></span><br /><br /> <br /><br /> <span data-ttu-id="8023e-653">**Table-valued Function** es un operador lógico y físico.</span><span class="sxs-lookup"><span data-stu-id="8023e-653">**Table-valued Function** is a logical and physical operator.</span></span>|  
|<span data-ttu-id="8023e-654">![Icono del operador Top](../../2014/database-engine/media/top-32x.gif "Icono del operador Top")</span><span class="sxs-lookup"><span data-stu-id="8023e-654">![Top operator icon](../../2014/database-engine/media/top-32x.gif "Top operator icon")</span></span>|<span data-ttu-id="8023e-655">**Top** (Principales)</span><span class="sxs-lookup"><span data-stu-id="8023e-655">**Top**</span></span>|<span data-ttu-id="8023e-656">El operador **Top** recorre la entrada y solo devuelve el primer número o porcentaje especificado de filas, basándose en un criterio de ordenación si es posible.</span><span class="sxs-lookup"><span data-stu-id="8023e-656">The **Top** operator scans the input, returning only the first specified number or percent of rows, possibly based on a sort order.</span></span> <span data-ttu-id="8023e-657">La `Argument` columna puede contener una lista de las columnas en las que se comprueban los vínculos.</span><span class="sxs-lookup"><span data-stu-id="8023e-657">The `Argument` column can contain a list of the columns that are being checked for ties.</span></span> <span data-ttu-id="8023e-658">En los planes de actualización, se usa el operador **Top** para aplicar límites de recuento de filas.</span><span class="sxs-lookup"><span data-stu-id="8023e-658">In update plans, the **Top** operator is used to enforce row count limits.</span></span> <span data-ttu-id="8023e-659">**Top** es un operador lógico y físico.</span><span class="sxs-lookup"><span data-stu-id="8023e-659">**Top** is a logical and physical operator.</span></span> <span data-ttu-id="8023e-660">**Top** es un operador lógico y físico.</span><span class="sxs-lookup"><span data-stu-id="8023e-660">**Top** is a logical and physical operator.</span></span>|  
|<span data-ttu-id="8023e-661">None</span><span class="sxs-lookup"><span data-stu-id="8023e-661">None</span></span>|<span data-ttu-id="8023e-662">**Top N Sort**</span><span class="sxs-lookup"><span data-stu-id="8023e-662">**Top N Sort**</span></span>|<span data-ttu-id="8023e-663">El **orden Top N** es similar al `Sort` iterador, excepto en que solo se necesitan las primeras *N* filas y no en el conjunto de resultados completo.</span><span class="sxs-lookup"><span data-stu-id="8023e-663">**Top N Sort** is similar to the `Sort` iterator, except that only the first *N* rows are needed, and not the entire result set.</span></span> <span data-ttu-id="8023e-664">Para valores pequeños de *N*, el motor de ejecución de consultas de [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] intenta realizar toda la operación de ordenación en memoria.</span><span class="sxs-lookup"><span data-stu-id="8023e-664">For small values of *N*, the [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] query execution engine attempts to perform the entire sort operation in memory.</span></span> <span data-ttu-id="8023e-665">Para valores grandes de *N*, el motor de ejecución de consultas recurre al método más genérico de ordenación, en el que *N* no es un parámetro.</span><span class="sxs-lookup"><span data-stu-id="8023e-665">For large values of *N*, the query execution engine resorts to the more generic method of sorting to which *N* is not a parameter.</span></span>|  
|<span data-ttu-id="8023e-666">![Icono del operador extendido (UDX)](../../2014/database-engine/media/udx-32x.gif "Icono del operador extendido (UDX)")</span><span class="sxs-lookup"><span data-stu-id="8023e-666">![Extended operator (UDX) icon](../../2014/database-engine/media/udx-32x.gif "Extended operator (UDX) icon")</span></span>|`UDX`|<span data-ttu-id="8023e-667">Los operadores extendidos (UDX) implementan una de las múltiples operaciones XQuery y XPath de [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span><span class="sxs-lookup"><span data-stu-id="8023e-667">Extended Operators (UDX) implement one of many XQuery and XPath operations in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="8023e-668">Todos los operadores UDX son operadores lógicos y físicos.</span><span class="sxs-lookup"><span data-stu-id="8023e-668">All UDX operators are both logical and physical operators.</span></span><br /><br /> <span data-ttu-id="8023e-669">El operador extendido (UDX) `FOR XML` se utiliza para serializar el conjunto de filas relacional que introduce en la representación XML en una única columna BLOB de una única fila de salida.</span><span class="sxs-lookup"><span data-stu-id="8023e-669">Extended operator (UDX) `FOR XML` is used to serialize the relational row set it inputs into XML representation in a single BLOB column in a single output row.</span></span> <span data-ttu-id="8023e-670">Es un operador de agregado XML que depende del orden.</span><span class="sxs-lookup"><span data-stu-id="8023e-670">It is an order sensitive XML aggregation operator.</span></span><br /><br /> <span data-ttu-id="8023e-671">El operador extendido (UDX) `XML SERIALIZER` es un operador de agregado XML que depende del orden.</span><span class="sxs-lookup"><span data-stu-id="8023e-671">Extended operator (UDX) `XML SERIALIZER` is an order sensitive XML aggregation operator.</span></span> <span data-ttu-id="8023e-672">Especifica filas que representan nodos XML o valores escalares de XQuery en el orden del documento XML y produce un objeto BLOB XML serializado en una única columna XML de una única fila de salida.</span><span class="sxs-lookup"><span data-stu-id="8023e-672">It inputs rows representing XML nodes or XQuery scalars in XML document order and produces a serialized XML BLOB in a single XML column in a single output row.</span></span><br /><br /> <span data-ttu-id="8023e-673">El operador extendido (UDX) `XML FRAGMENT SERIALIZER` es un tipo especial de `XML SERIALIZER` que se utiliza para procesar filas de entrada que representan fragmentos XML que se insertan en la extensión de modificación de datos de inserción XQuery.</span><span class="sxs-lookup"><span data-stu-id="8023e-673">Extended operator (UDX) `XML FRAGMENT SERIALIZER` is a special type of `XML SERIALIZER` that is used for processing input rows representing XML fragments being inserted in XQuery insert data modification extension.</span></span><br /><br /> <span data-ttu-id="8023e-674">El operador extendido (UDX) `XQUERY STRING` evalúa el valor de cadena XQuery de las filas de entrada que representan nodos XML.</span><span class="sxs-lookup"><span data-stu-id="8023e-674">Extended operator (UDX) `XQUERY STRING` evaluates the XQuery string value of input rows representing XML nodes.</span></span> <span data-ttu-id="8023e-675">Es un operador de agregado de cadena que depende del orden.</span><span class="sxs-lookup"><span data-stu-id="8023e-675">It is an order sensitive string aggregation operator.</span></span> <span data-ttu-id="8023e-676">Produce una fila con columnas que representa el valor escalar de XQuery que contiene el valor de cadena de la entrada.</span><span class="sxs-lookup"><span data-stu-id="8023e-676">It outputs one row with columns representing the XQuery scalar that contains string value of the input.</span></span><br /><br /> <span data-ttu-id="8023e-677">El operador extendido (UDX) `XQUERY LIST DECOMPOSER` es un operador de descomposición de lista XQuery.</span><span class="sxs-lookup"><span data-stu-id="8023e-677">Extended operator (UDX) `XQUERY LIST DECOMPOSER` is an XQuery list decomposition operator.</span></span> <span data-ttu-id="8023e-678">Para cada fila de entrada que representa un nodo XML, produce una o varias filas, cada una de las cuales representa un valor escalar de XQuery que contiene un valor de elemento de lista si la entrada es de tipo lista XSD.</span><span class="sxs-lookup"><span data-stu-id="8023e-678">For each input row representing an XML node it produces one or more rows each representing XQuery scalar containing a list element value if the input is of XSD list type.</span></span><br /><br /> <span data-ttu-id="8023e-679">El operador extendido (UDX) `XQUERY DATA` evalúa la función XQuery fn:data() en la entrada que representa nodos XML.</span><span class="sxs-lookup"><span data-stu-id="8023e-679">Extended operator (UDX) `XQUERY DATA` evaluates the XQuery fn:data() function on input representing XML nodes.</span></span> <span data-ttu-id="8023e-680">Es un operador de agregado de cadena que depende del orden.</span><span class="sxs-lookup"><span data-stu-id="8023e-680">It is an order sensitive string aggregation operator.</span></span> <span data-ttu-id="8023e-681">Genera una fila con columnas que representa el valor escalar de XQuery que contiene el resultado de **fn:data()** .</span><span class="sxs-lookup"><span data-stu-id="8023e-681">It outputs one row with columns representing XQuery scalar that contains the result of **fn:data()**.</span></span><br /><br /> <span data-ttu-id="8023e-682">El operador extendido `XQUERY CONTAINS` evalúa la función XQuery fn:contains() en la entrada que representa nodos XML.</span><span class="sxs-lookup"><span data-stu-id="8023e-682">Extended operator `XQUERY CONTAINS` evaluates the XQuery fn:contains() function on input representing XML nodes.</span></span> <span data-ttu-id="8023e-683">Es un operador de agregado de cadena que depende del orden.</span><span class="sxs-lookup"><span data-stu-id="8023e-683">It is an order sensitive string aggregation operator.</span></span> <span data-ttu-id="8023e-684">Genera una fila con columnas que representa el valor escalar de XQuery que contiene el resultado de **fn:contains()** .</span><span class="sxs-lookup"><span data-stu-id="8023e-684">It outputs one row with columns representing XQuery scalar that contains the result of **fn:contains()**.</span></span><br /><br /> <span data-ttu-id="8023e-685">El operador extendido `UPDATE XML NODE` actualiza el nodo XML en la extensión de modificación de datos de reemplazo de XQuery en el método **Modify ()** en el tipo XML.</span><span class="sxs-lookup"><span data-stu-id="8023e-685">Extended operator `UPDATE XML NODE` updates XML node in the XQuery replace data modification extension in the **modify()** method on XML type.</span></span>|  
|<span data-ttu-id="8023e-686">None</span><span class="sxs-lookup"><span data-stu-id="8023e-686">None</span></span>|<span data-ttu-id="8023e-687">**Unión**</span><span class="sxs-lookup"><span data-stu-id="8023e-687">**Union**</span></span>|<span data-ttu-id="8023e-688">El operador **Union** recorre varias entradas, obtiene cada fila recorrida y quita los duplicados.</span><span class="sxs-lookup"><span data-stu-id="8023e-688">The **Union** operator scans multiple inputs, outputting each row scanned and removing duplicates.</span></span> <span data-ttu-id="8023e-689">**Union** es un operador lógico.</span><span class="sxs-lookup"><span data-stu-id="8023e-689">**Union** is a logical operator.</span></span>|  
|<span data-ttu-id="8023e-690">![Icono del operador Update (motor de base de datos)](../../2014/database-engine/media/update-32x.gif "Icono del operador Update (motor de base de datos)")</span><span class="sxs-lookup"><span data-stu-id="8023e-690">![Update (Database Engine) operator icon](../../2014/database-engine/media/update-32x.gif "Update (Database Engine) operator icon")</span></span>|`Update`|<span data-ttu-id="8023e-691">El `Update` operador actualiza cada fila de su entrada en el objeto especificado en la `Argument` columna del plan de ejecución de la consulta.</span><span class="sxs-lookup"><span data-stu-id="8023e-691">The `Update` operator updates each row from its input in the object specified in the `Argument` column of the query execution plan.</span></span> <span data-ttu-id="8023e-692">`Update` es un operador lógico.</span><span class="sxs-lookup"><span data-stu-id="8023e-692">`Update` is a logical operator.</span></span> <span data-ttu-id="8023e-693">El operador físico es `Table Update`, `Index Update` o `Clustered Index Update`.</span><span class="sxs-lookup"><span data-stu-id="8023e-693">The physical operator is `Table Update`, `Index Update`, or `Clustered Index Update`.</span></span>|  
|<span data-ttu-id="8023e-694">![Icono del elemento del lenguaje While](../../2014/database-engine/media/while-32x.gif "Icono del elemento del lenguaje While")</span><span class="sxs-lookup"><span data-stu-id="8023e-694">![While language element icon](../../2014/database-engine/media/while-32x.gif "While language element icon")</span></span>|`While`|<span data-ttu-id="8023e-695">El operador `While` implementa el bucle while de [!INCLUDE[tsql](../includes/tsql-md.md)].</span><span class="sxs-lookup"><span data-stu-id="8023e-695">The `While` operator implements the [!INCLUDE[tsql](../includes/tsql-md.md)] while loop.</span></span> <span data-ttu-id="8023e-696">`While` es un elemento del lenguaje</span><span class="sxs-lookup"><span data-stu-id="8023e-696">`While` is a language element</span></span>|  
|<span data-ttu-id="8023e-697">![Icono del operador Table Spool](../../2014/database-engine/media/table-spool-32x.gif "Icono del operador Table Spool")</span><span class="sxs-lookup"><span data-stu-id="8023e-697">![Table spool operator icon](../../2014/database-engine/media/table-spool-32x.gif "Table spool operator icon")</span></span>|`Window Spool`|<span data-ttu-id="8023e-698">El operador `Window Spool` expande cada fila del conjunto de filas que representa la ventana asociada con él.</span><span class="sxs-lookup"><span data-stu-id="8023e-698">The `Window Spool` operator expands each row into the set of rows that represents the window associated with it.</span></span> <span data-ttu-id="8023e-699">En una consulta, la cláusula OVER define la ventana de un conjunto de resultados de la consulta y, a continuación, una función de ventana calcula un valor para cada fila de la ventana.</span><span class="sxs-lookup"><span data-stu-id="8023e-699">In a query, the OVER clause defines the window within a query result set and a window function then computes a value for each row in the window.</span></span> <span data-ttu-id="8023e-700">`Window Spool` es un operador lógico y físico.</span><span class="sxs-lookup"><span data-stu-id="8023e-700">`Window Spool` is a logical and physical operator.</span></span>|  
  
  
