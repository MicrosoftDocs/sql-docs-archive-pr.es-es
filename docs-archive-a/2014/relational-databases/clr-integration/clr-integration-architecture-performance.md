---
title: Rendimiento de la integración CLR | Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: clr
ms.topic: reference
helpviewer_keywords:
- common language runtime [SQL Server], performance
- common language runtime [SQL Server], compilation process
- performance [CLR integration]
ms.assetid: 7ce2dfc0-4b1f-4dcb-a979-2c4f95b4cb15
author: rothja
ms.author: jroth
ms.openlocfilehash: 33e45039ed98ea3df607df1714b3c6108ec17c35
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 08/04/2020
ms.locfileid: "87747619"
---
# <a name="performance-of-clr-integration"></a><span data-ttu-id="0db3e-102">Rendimiento de la integración CLR</span><span class="sxs-lookup"><span data-stu-id="0db3e-102">Performance of CLR Integration</span></span>
  <span data-ttu-id="0db3e-103">En este tema se describen algunas de las opciones de diseño que mejoran el rendimiento de la [!INCLUDE[msCoName](../../../includes/msconame-md.md)] [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] integración con el [!INCLUDE[msCoName](../../../includes/msconame-md.md)] Common Language Runtime de .NET Framework (CLR).</span><span class="sxs-lookup"><span data-stu-id="0db3e-103">This topic discusses some of the design choices that enhance the performance of [!INCLUDE[msCoName](../../../includes/msconame-md.md)] [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] integration with the [!INCLUDE[msCoName](../../../includes/msconame-md.md)] .NET Framework common language runtime (CLR).</span></span>  
  
## <a name="the-compilation-process"></a><span data-ttu-id="0db3e-104">El proceso de compilación</span><span class="sxs-lookup"><span data-stu-id="0db3e-104">The Compilation Process</span></span>  
 <span data-ttu-id="0db3e-105">Durante la compilación de expresiones SQL, cuando se encuentra una referencia a una rutina administrada, se genera un código auxiliar de lenguaje intermedio de [!INCLUDE[msCoName](../../../includes/msconame-md.md)] (MSIL).</span><span class="sxs-lookup"><span data-stu-id="0db3e-105">During compilation of SQL expressions, when a reference to a managed routine is encountered, a [!INCLUDE[msCoName](../../../includes/msconame-md.md)] intermediate language (MSIL) stub is generated.</span></span> <span data-ttu-id="0db3e-106">Este código auxiliar incluye el código para calcular referencias de los parámetros de rutina de [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] a CLR, invocar la función y devolver el resultado.</span><span class="sxs-lookup"><span data-stu-id="0db3e-106">This stub includes code to marshal the routine parameters from [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] to the CLR, invoke the function, and return the result.</span></span> <span data-ttu-id="0db3e-107">Este código de "unión" está basado en el tipo y la dirección del parámetro (entrada, salida o referencia).</span><span class="sxs-lookup"><span data-stu-id="0db3e-107">This "glue" code is based on the type of parameter and on parameter direction (in, out, or reference).</span></span>  
  
 <span data-ttu-id="0db3e-108">El código de unión habilita las optimizaciones específicas del tipo y asegura una eficaz aplicación de la semántica de [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)], como el control de excepciones estándar, de nulabilidad, de facetas de restricción y por valor.</span><span class="sxs-lookup"><span data-stu-id="0db3e-108">The glue code enables type-specific optimizations and ensures efficient enforcement of [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] semantics, such as nullability, constraining facets, by-value, and standard exception handling.</span></span> <span data-ttu-id="0db3e-109">Al generar código para los tipos exactos de los argumentos, se evitan los costos de la conversión de tipos o de la creación de objetos contenedores (denominada "conversión boxing") dentro de los límites de la invocación.</span><span class="sxs-lookup"><span data-stu-id="0db3e-109">By generating code for the exact types of the arguments, you avoid type coercion or wrapper object creation costs (called "boxing") across the invocation boundary.</span></span>  
  
 <span data-ttu-id="0db3e-110">El código auxiliar generado se compila a continuación en código nativo y se optimiza para la arquitectura de hardware concreta en la que se ejecuta [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)], utilizando los servicios de compilación JIT (Just In Time) de CLR.</span><span class="sxs-lookup"><span data-stu-id="0db3e-110">The generated stub is then compiled to native code and optimized for the particular hardware architecture on which [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] executes, using the JIT (just-in-time) compilation services of the CLR.</span></span> <span data-ttu-id="0db3e-111">Los servicios JIT se invocan en el nivel de método y permiten al entorno de hospedaje de [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] crear una unidad de compilación única que abarca la ejecución de CLR y [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span><span class="sxs-lookup"><span data-stu-id="0db3e-111">The JIT services are invoked at the method level and allow the [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] hosting environment to create a single compilation unit that spans both [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] and CLR execution.</span></span> <span data-ttu-id="0db3e-112">Una vez compilado el código auxiliar, el puntero resultante a la función se convierte en la implementación de la función durante la ejecución.</span><span class="sxs-lookup"><span data-stu-id="0db3e-112">Once the stub is compiled, the resulting function pointer becomes the run-time implementation of the function.</span></span> <span data-ttu-id="0db3e-113">Este enfoque de generación de código garantiza que no haya ningún costo de invocación adicional relacionado con el acceso a los metadatos o el reflejo durante la ejecución.</span><span class="sxs-lookup"><span data-stu-id="0db3e-113">This code generation approach ensures that there are no additional invocation costs related to reflection or metadata access at run time.</span></span>  
  
### <a name="fast-transitions-between-sql-server-and-clr"></a><span data-ttu-id="0db3e-114">Transiciones rápidas entre SQL Server y CLR</span><span class="sxs-lookup"><span data-stu-id="0db3e-114">Fast Transitions Between SQL Server and CLR</span></span>  
 <span data-ttu-id="0db3e-115">El proceso de compilación produce un puntero a función al que se puede llamar durante la ejecución desde código nativo.</span><span class="sxs-lookup"><span data-stu-id="0db3e-115">The compilation process yields a function pointer that can be called at run time from native code.</span></span> <span data-ttu-id="0db3e-116">En el caso de funciones definidas por el usuario con valores escalares, esta invocación de función se produce fila por fila.</span><span class="sxs-lookup"><span data-stu-id="0db3e-116">In the case of scalar-valued user-defined functions, this function invocation happens on a per-row basis.</span></span> <span data-ttu-id="0db3e-117">Para minimizar el costo de la transición entre [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] y CLR, las instrucciones que contienen cualquier invocación administrada tienen un paso de inicio para identificar el dominio de la aplicación de destino.</span><span class="sxs-lookup"><span data-stu-id="0db3e-117">To minimize the cost of transitioning between [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] and the CLR, statements that contain any managed invocation have a startup step to identify the target application domain.</span></span> <span data-ttu-id="0db3e-118">Este paso de identificación reduce el costo de la transición para cada fila.</span><span class="sxs-lookup"><span data-stu-id="0db3e-118">This identification step reduces the cost of transitioning for each row.</span></span>  
  
## <a name="performance-considerations"></a><span data-ttu-id="0db3e-119">Consideraciones de rendimiento</span><span class="sxs-lookup"><span data-stu-id="0db3e-119">Performance Considerations</span></span>  
 <span data-ttu-id="0db3e-120">A continuación se resumen las consideraciones de rendimiento específicas para la integración CLR en [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span><span class="sxs-lookup"><span data-stu-id="0db3e-120">The following summarizes performance considerations specific to CLR integration in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="0db3e-121">Puede encontrar información más detallada en "[using CLR Integration in SQL Server 2005](https://go.microsoft.com/fwlink/?LinkId=50332)" en el sitio web de MSDN.</span><span class="sxs-lookup"><span data-stu-id="0db3e-121">More detailed information can be found in "[Using CLR Integration in SQL Server 2005](https://go.microsoft.com/fwlink/?LinkId=50332)" on the MSDN Web site.</span></span> <span data-ttu-id="0db3e-122">Puede encontrar información general sobre el rendimiento del código administrado en "[mejorar el rendimiento y la escalabilidad de las aplicaciones .net](https://go.microsoft.com/fwlink/?LinkId=50333)" en el sitio web de MSDN.</span><span class="sxs-lookup"><span data-stu-id="0db3e-122">General information regarding managed code performance can be found in "[Improving .NET Application Performance and Scalability](https://go.microsoft.com/fwlink/?LinkId=50333)" on the MSDN Web site.</span></span>  
  
### <a name="user-defined-functions"></a><span data-ttu-id="0db3e-123">Funciones definidas por el usuario</span><span class="sxs-lookup"><span data-stu-id="0db3e-123">User-Defined Functions</span></span>  
 <span data-ttu-id="0db3e-124">Las funciones CLR se benefician de una ruta de invocación más rápida que la de las funciones definidas por el usuario de [!INCLUDE[tsql](../../../includes/tsql-md.md)].</span><span class="sxs-lookup"><span data-stu-id="0db3e-124">CLR functions benefit from a quicker invocation path than that of [!INCLUDE[tsql](../../../includes/tsql-md.md)] user-defined functions.</span></span> <span data-ttu-id="0db3e-125">Además, el código administrado ofrece una gran ventaja de rendimiento con respecto a [!INCLUDE[tsql](../../../includes/tsql-md.md)] en lo que se refiere al código de procedimiento, el cálculo y la manipulación de cadenas.</span><span class="sxs-lookup"><span data-stu-id="0db3e-125">Additionally, managed code has a decisive performance advantage over [!INCLUDE[tsql](../../../includes/tsql-md.md)] in terms of procedural code, computation, and string manipulation.</span></span> <span data-ttu-id="0db3e-126">Las funciones de CLR que requieren una gran cantidad de cálculo y que no proporcionan acceso a datos se escriben mejor en código administrado.</span><span class="sxs-lookup"><span data-stu-id="0db3e-126">CLR functions that are computing-intensive and that do not perform data access are better written in managed code.</span></span> <span data-ttu-id="0db3e-127">En cambio, las funciones de [!INCLUDE[tsql](../../../includes/tsql-md.md)] sí proporcionan acceso a datos de forma más eficiente que la integración CLR.</span><span class="sxs-lookup"><span data-stu-id="0db3e-127">[!INCLUDE[tsql](../../../includes/tsql-md.md)] functions do, however, perform data access more efficiently than CLR integration.</span></span>  
  
### <a name="user-defined-aggregates"></a><span data-ttu-id="0db3e-128">Funciones de agregado definidas por el usuario</span><span class="sxs-lookup"><span data-stu-id="0db3e-128">User-Defined Aggregates</span></span>  
 <span data-ttu-id="0db3e-129">El código administrado puede mejorar significativamente el rendimiento de la agregación basada en cursor.</span><span class="sxs-lookup"><span data-stu-id="0db3e-129">Managed code can significantly outperform cursor-based aggregation.</span></span> <span data-ttu-id="0db3e-130">La realización del código administrado suele ser algo más lenta que la de las funciones de agregado integradas de [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span><span class="sxs-lookup"><span data-stu-id="0db3e-130">Managed code generally performs slightly slower than built-in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] aggregate functions.</span></span> <span data-ttu-id="0db3e-131">Si existe una función de agregado integrada nativa, se recomienda utilizarla.</span><span class="sxs-lookup"><span data-stu-id="0db3e-131">We recommend that if a native built-in aggregate function exists, you should use it.</span></span> <span data-ttu-id="0db3e-132">En los casos en que la agregación que se necesita no se admite de forma nativa, piense en utilizar una función de agregado definida por el usuario de CLR en lugar de una implementación basada en cursor para obtener un mejor rendimiento.</span><span class="sxs-lookup"><span data-stu-id="0db3e-132">In cases in which the needed aggregation is not natively supported, consider a CLR user-defined aggregate over a cursor-based implementation for performance reasons.</span></span>  
  
### <a name="streaming-table-valued-functions"></a><span data-ttu-id="0db3e-133">Funciones con valores de tabla de transmisión por secuencias</span><span class="sxs-lookup"><span data-stu-id="0db3e-133">Streaming Table-Valued Functions</span></span>  
 <span data-ttu-id="0db3e-134">Después de invocar una función, las aplicaciones suelen necesitar devolver una tabla.</span><span class="sxs-lookup"><span data-stu-id="0db3e-134">Applications often need to return a table as a result of invoking a function.</span></span> <span data-ttu-id="0db3e-135">Entre los ejemplos se incluye la lectura de datos tabulares de un archivo como parte de una operación de importación y la conversión de valores separados por comas en una representación relacional.</span><span class="sxs-lookup"><span data-stu-id="0db3e-135">Examples include reading tabular data from a file as part of an import operation, and converting comma-separated-values to a relational representation.</span></span> <span data-ttu-id="0db3e-136">Normalmente, esto se puede llevar a cabo materializando y rellenando la tabla de resultados antes de que pueda consumirla el autor de las llamadas.</span><span class="sxs-lookup"><span data-stu-id="0db3e-136">Typically, you can accomplish this by materializing and populating the result table before it can be consumed by the caller.</span></span> <span data-ttu-id="0db3e-137">La integración de CLR en [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] introduce una función con valores de tabla de transmisión por secuencias (STVF), que es un nuevo mecanismo de extensibilidad.</span><span class="sxs-lookup"><span data-stu-id="0db3e-137">The integration of the CLR into [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] introduces a new extensibility mechanism called a streaming table-valued function (STVF).</span></span> <span data-ttu-id="0db3e-138">Las STVF administradas funcionan mejor que las implementaciones de procedimiento almacenado extendido comparables.</span><span class="sxs-lookup"><span data-stu-id="0db3e-138">Managed STVFs perform better than comparable extended stored procedure implementations.</span></span>  
  
 <span data-ttu-id="0db3e-139">Las STVF son funciones administradas que devuelven una interfaz `IEnumerable`.</span><span class="sxs-lookup"><span data-stu-id="0db3e-139">STVFs are managed functions that return an `IEnumerable` interface.</span></span> <span data-ttu-id="0db3e-140">`IEnumerable` tiene métodos para navegar por el conjunto de resultados devuelto por la STVF.</span><span class="sxs-lookup"><span data-stu-id="0db3e-140">`IEnumerable` has methods to navigate the result set returned by the STVF.</span></span> <span data-ttu-id="0db3e-141">Cuando se invoca la STVF, la interfaz `IEnumerable` devuelta se conecta directamente al plan de consulta.</span><span class="sxs-lookup"><span data-stu-id="0db3e-141">When the STVF is invoked, the returned `IEnumerable` is directly connected to the query plan.</span></span> <span data-ttu-id="0db3e-142">El plan de consulta llama a los métodos `IEnumerable` cuando necesita capturar filas.</span><span class="sxs-lookup"><span data-stu-id="0db3e-142">The query plan calls `IEnumerable` methods when it needs to fetch rows.</span></span> <span data-ttu-id="0db3e-143">Este modelo de iteración permite utilizar los resultados inmediatamente después de que se genere la primera fila, en lugar de esperar hasta que se rellene la tabla completa.</span><span class="sxs-lookup"><span data-stu-id="0db3e-143">This iteration model allows results to be consumed immediately after the first row is produced, instead of waiting until the entire table is populated.</span></span> <span data-ttu-id="0db3e-144">Reduce también significativamente la cantidad de memoria que se utiliza al invocar la función.</span><span class="sxs-lookup"><span data-stu-id="0db3e-144">It also significantly reduces the memory consumed by invoking the function.</span></span>  
  
### <a name="arrays-vs-cursors"></a><span data-ttu-id="0db3e-145">Matrices frente a cursores</span><span class="sxs-lookup"><span data-stu-id="0db3e-145">Arrays vs. Cursors</span></span>  
 <span data-ttu-id="0db3e-146">Cuando los cursores de [!INCLUDE[tsql](../../../includes/tsql-md.md)] deben recorrer datos que se expresan más fácilmente como una matriz, se puede utilizar el código administrado con significativas mejoras del rendimiento.</span><span class="sxs-lookup"><span data-stu-id="0db3e-146">When [!INCLUDE[tsql](../../../includes/tsql-md.md)] cursors must traverse data that is more easily expressed as an array, managed code can be used with significant performance gains.</span></span>  
  
### <a name="string-data"></a><span data-ttu-id="0db3e-147">Datos de cadena</span><span class="sxs-lookup"><span data-stu-id="0db3e-147">String Data</span></span>  
 <span data-ttu-id="0db3e-148">Los datos de caracteres de [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)], como `varchar`, pueden ser del tipo SqlString o SqlChars en funciones administradas.</span><span class="sxs-lookup"><span data-stu-id="0db3e-148">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] character data, such as `varchar`, can be of the type SqlString or SqlChars in managed functions.</span></span> <span data-ttu-id="0db3e-149">Las variables SqlString crean una instancia del valor completo en la memoria.</span><span class="sxs-lookup"><span data-stu-id="0db3e-149">SqlString variables create an instance of the entire value into memory.</span></span> <span data-ttu-id="0db3e-150">Las variables SqlChars proporcionan una interfaz de transmisión por secuencias que se puede utilizar para lograr mejores rendimiento y escalabilidad sin crear una instancia del valor completo en la memoria.</span><span class="sxs-lookup"><span data-stu-id="0db3e-150">SqlChars variables provide a streaming interface that can be used to achieve better performance and scalability by not creating an instance of the entire value into memory.</span></span> <span data-ttu-id="0db3e-151">Esto se vuelve especialmente importante para los datos de objetos grandes (LOB).</span><span class="sxs-lookup"><span data-stu-id="0db3e-151">This becomes particularly important for large object (LOB) data.</span></span> <span data-ttu-id="0db3e-152">Además, se puede tener acceso a los datos XML del servidor a través de una interfaz de transmisión por secuencias devuelta por `SqlXml.CreateReader()`.</span><span class="sxs-lookup"><span data-stu-id="0db3e-152">Additionally, server XML data can be accessed through a streaming interface returned by `SqlXml.CreateReader()`.</span></span>  
  
### <a name="clr-vs-extended-stored-procedures"></a><span data-ttu-id="0db3e-153">CLR frente a los procedimientos almacenados extendidos</span><span class="sxs-lookup"><span data-stu-id="0db3e-153">CLR vs. Extended Stored Procedures</span></span>  
 <span data-ttu-id="0db3e-154">Las interfaces de programación de aplicaciones (API) de Microsoft.SqlServer.Server que permiten a los procedimientos administrados devolver conjuntos de resultados al cliente funcionan mejor que las API de Servicios abiertos de datos (ODS) utilizadas por los procedimientos almacenados extendidos.</span><span class="sxs-lookup"><span data-stu-id="0db3e-154">The Microsoft.SqlServer.Server application programming interfaces (APIs) that allow managed procedures to send result sets back to the client perform better than the Open Data Services (ODS) APIs used by extended stored procedures.</span></span> <span data-ttu-id="0db3e-155">Además, las API de System.Data.SqlServer admiten tipos de datos como `xml`, `varchar(max)`, `nvarchar(max)` y `varbinary(max)` introducidos en [!INCLUDE[ssVersion2005](../../../includes/ssversion2005-md.md)], mientras que las API de ODS no se han ampliado para admitir los nuevos tipos de datos.</span><span class="sxs-lookup"><span data-stu-id="0db3e-155">Furthermore, the System.Data.SqlServer APIs support data types such as `xml`, `varchar(max)`, `nvarchar(max)`, and `varbinary(max)`, introduced in [!INCLUDE[ssVersion2005](../../../includes/ssversion2005-md.md)], while the ODS APIs have not been extended to support the new data types.</span></span>  
  
 <span data-ttu-id="0db3e-156">Con código administrado, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] administra el uso de los recursos como la memoria, los subprocesos y la sincronización.</span><span class="sxs-lookup"><span data-stu-id="0db3e-156">With managed code, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] manages use of resources such as memory, threads, and synchronization.</span></span> <span data-ttu-id="0db3e-157">Esto se debe a que las API administradas que exponen estos recursos se implementan sobre el administrador de recursos de [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span><span class="sxs-lookup"><span data-stu-id="0db3e-157">This is because the managed APIs that expose these resources are implemented on top of the [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] resource manager.</span></span> <span data-ttu-id="0db3e-158">En cambio, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] no tiene ninguna vista o control sobre el uso de recursos del procedimiento almacenado extendido.</span><span class="sxs-lookup"><span data-stu-id="0db3e-158">Conversely, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] has no view or control over the resource usage of the extended stored procedure.</span></span> <span data-ttu-id="0db3e-159">Por ejemplo, si un procedimiento almacenado extendido usa demasiados recursos de la CPU o de la memoria, con [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] no hay ninguna manera de detectarlo o controlarlo.</span><span class="sxs-lookup"><span data-stu-id="0db3e-159">For example, if an extended stored procedure consumes too much CPU or memory resources, there is no way to detect or control this with [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="0db3e-160">Sin embargo, con el código administrado, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] puede detectar que un subproceso determinado no ha producido resultados durante un largo período de tiempo y, a continuación, puede obligar a la tarea a producir resultados para que se pueda programar otro trabajo.</span><span class="sxs-lookup"><span data-stu-id="0db3e-160">With managed code, however, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] can detect that a given thread has not yielded for a long period of time, and then force the task to yield so that other work can be scheduled.</span></span> <span data-ttu-id="0db3e-161">Por consiguiente, el uso de código administrado aporta una mayor escalabilidad y una mejor utilización de los recursos del sistema.</span><span class="sxs-lookup"><span data-stu-id="0db3e-161">Consequently, using managed code provides for better scalability and system resource usage.</span></span>  
  
 <span data-ttu-id="0db3e-162">El código administrado puede hacer que se produzca una sobrecarga adicional necesaria para mantener el entorno de ejecución y realizar comprobaciones de seguridad.</span><span class="sxs-lookup"><span data-stu-id="0db3e-162">Managed code may incur additional overhead necessary to maintain the execution environment and perform security checks.</span></span> <span data-ttu-id="0db3e-163">Así ocurre, por ejemplo, cuando se ejecuta en [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] y se requieren numerosas transacciones de código administrado a código nativo (ya que [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] necesita llevar a cabo un mantenimiento adicional en los valores específicos de los subprocesos al salir del código nativo y volver al mismo.</span><span class="sxs-lookup"><span data-stu-id="0db3e-163">This is the case, for example, when running inside [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] and numerous transitions from managed to native code are required (because [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] needs to do additional maintenance on thread-specific settings when moving out to native code and back).</span></span> <span data-ttu-id="0db3e-164">Por ello, los procedimientos almacenados extendidos pueden obtener resultados bastante mejores que el código administrado que se ejecuta en [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] cuando hay transiciones frecuentes entre código administrado y código nativo.</span><span class="sxs-lookup"><span data-stu-id="0db3e-164">Consequently, extended stored procedures can significantly outperform managed code running inside [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] for cases in which there are frequent transitions between managed and native code.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="0db3e-165">No se recomienda desarrollar nuevos procedimientos almacenados extendidos, puesto que esta característica ha quedado desusada.</span><span class="sxs-lookup"><span data-stu-id="0db3e-165">It is recommended that you do not develop new extended stored procedures, because this feature has been deprecated.</span></span>  
  
### <a name="native-serialization-for-user-defined-types"></a><span data-ttu-id="0db3e-166">Serialización nativa para los tipos definidos por el usuario</span><span class="sxs-lookup"><span data-stu-id="0db3e-166">Native Serialization for User-Defined Types</span></span>  
 <span data-ttu-id="0db3e-167">Los tipos definidos por el usuario (UDT) están diseñados como un mecanismo de extensibilidad para el sistema de tipo escalar.</span><span class="sxs-lookup"><span data-stu-id="0db3e-167">User-defined types (UDTs) are designed as an extensibility mechanism for the scalar type system.</span></span> [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] <span data-ttu-id="0db3e-168">implementa un formato de serialización para UDT denominado `Format.Native`.</span><span class="sxs-lookup"><span data-stu-id="0db3e-168">implements a serialization format for UDTs called `Format.Native`.</span></span> <span data-ttu-id="0db3e-169">Durante la compilación se examina la estructura del tipo para generar el MSIL personalizado para esa definición de tipo concreta.</span><span class="sxs-lookup"><span data-stu-id="0db3e-169">During compilation, the structure of the type is examined to generate MSIL that is customized for that particular type definition.</span></span>  
  
 <span data-ttu-id="0db3e-170">La serialización nativa es la implementación predeterminada para [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span><span class="sxs-lookup"><span data-stu-id="0db3e-170">Native serialization is the default implementation for [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="0db3e-171">La serialización definida por el usuario invoca un método definido por el autor de tipo para realizar la serialización.</span><span class="sxs-lookup"><span data-stu-id="0db3e-171">User-defined serialization invokes a method defined by the type author to do the serialization.</span></span> <span data-ttu-id="0db3e-172">Se debe utilizar la serialización `Format.Native` siempre que sea posible para obtener el máximo rendimiento.</span><span class="sxs-lookup"><span data-stu-id="0db3e-172">`Format.Native` serialization should be used when possible for best performance.</span></span>  
  
### <a name="normalization-of-comparable-udts"></a><span data-ttu-id="0db3e-173">Normalización de tipos definidos por el usuario comparables</span><span class="sxs-lookup"><span data-stu-id="0db3e-173">Normalization of Comparable UDTs</span></span>  
 <span data-ttu-id="0db3e-174">Las operaciones relacionales, como ordenar y comparar tipos definidos por el usuario (UDT), funcionan directamente en la representación binaria del valor.</span><span class="sxs-lookup"><span data-stu-id="0db3e-174">Relational operations, such as sorting and comparing UDTs, operate directly on the binary representation of the value.</span></span> <span data-ttu-id="0db3e-175">Esto se logra almacenando en disco una representación normalizada (ordenada de forma binaria) del estado del UDT.</span><span class="sxs-lookup"><span data-stu-id="0db3e-175">This is accomplished by storing a normalized (binary ordered) representation of the state of the UDT on disk.</span></span>  
  
 <span data-ttu-id="0db3e-176">La normalización tiene dos ventajas: abarata considerablemente la operación de comparación al evitar la creación de la instancia de tipo y la sobrecarga de la invocación de métodos; y crea un dominio binario para el UDT que permite la creación de histogramas, índices e histogramas para los valores del tipo.</span><span class="sxs-lookup"><span data-stu-id="0db3e-176">Normalization has two benefits: it makes the comparison operation considerably less expensive by avoiding the construction of the type instance and the method invocation overhead; and it creates a binary domain for the UDT, enabling the construction of histograms, indexes, and histograms for values of the type.</span></span> <span data-ttu-id="0db3e-177">Por consiguiente, los UDT normalizados tienen un perfil de rendimiento muy similar al de los tipos integrados nativos para las operaciones que no implican la invocación de métodos.</span><span class="sxs-lookup"><span data-stu-id="0db3e-177">Consequently, normalized UDTs have a very similar performance profile to the native built-in types for operations that do not involve method invocation.</span></span>  
  
### <a name="scalable-memory-usage"></a><span data-ttu-id="0db3e-178">Uso de memoria escalable</span><span class="sxs-lookup"><span data-stu-id="0db3e-178">Scalable Memory Usage</span></span>  
 <span data-ttu-id="0db3e-179">Para que la recolección de elementos no utilizados administrada se ejecute y escale correctamente en [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)], evite grandes asignaciones únicas.</span><span class="sxs-lookup"><span data-stu-id="0db3e-179">In order for managed garbage collection to perform and scale well in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)], avoid large, single allocation.</span></span> <span data-ttu-id="0db3e-180">Las asignaciones con un tamaño superior a 88 kilobytes (KB) se colocarán en el montón de objeto grande, lo que hará que la recolección de elementos no utilizados se ejecute y escale mucho peor que muchas asignaciones más pequeñas.</span><span class="sxs-lookup"><span data-stu-id="0db3e-180">Allocations greater than 88 kilobytes (KB) in size will be placed on the Large Object Heap, which will cause garbage collection to perform and scale much worse than many smaller allocations.</span></span> <span data-ttu-id="0db3e-181">Por ejemplo, si necesita asignar una matriz multidimensional grande, es preferible asignar una matriz escalonada (dispersa).</span><span class="sxs-lookup"><span data-stu-id="0db3e-181">For example, if you need to allocate a large multi-dimensional array, it is better to allocate a jagged (scattered) array.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="0db3e-182">Consulte también</span><span class="sxs-lookup"><span data-stu-id="0db3e-182">See Also</span></span>  
 [<span data-ttu-id="0db3e-183">Tipos definidos por el usuario CLR</span><span class="sxs-lookup"><span data-stu-id="0db3e-183">CLR User-Defined Types</span></span>](../clr-integration-database-objects-user-defined-types/clr-user-defined-types.md)  
  
  
